<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL数据库基础入门与实战]]></title>
    <url>%2F2019%2F07%2F28%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[常见数据库 关系型数据库：MySQL、Oracle、SQL Server、JDBC、DB2等。 非关系型数据库：Redis、MongoDB、NoSQL等。 关系型数据库主要是用来描述实体与实体之间的关系，实实在在存在的事物。例如：男生和女生、学生和班级、员工和部门。 非关系型数据库非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。(本章主要讲关系型数据库) MySQL数据库服务器MySQL数据库：数据库管理软件。 服务器：就是一台电脑，这台安装相关的服务器软件，这些软件监听不同的端口号，根据用户访问的端口号，提供不同的服务。 数据库：通常一个应用对应一个数据库。 MySQL的SQL语句 SQL：Structure Query Languages结构化查询语言 数据定义语言(DDL)：定义数据库，数据表的结构：create(创建)、drop(删除)、alter(修改) 数据操纵语言(DML)：主要是用来操作数据：insert(插入)、update(修改)、delete(删除) 数据控制语言(DCL)：定义访问权限，取消访问权限，安全设置 grant 数据查询语言(DQL)：select(查询) from子句 where子句 数据库的CRUD的操作前置知识： 登录数据库：mysql –uroot –proot 退出数据库：exit、quit、\q、Ctrl+c 退出当前命令行：\c 复制命令行的内容：标记-&gt;选择内容-&gt;回车，不用Ctrl+C 导出数据库文件： 进入MySQL的安装目录的bin目录，如：D:\Program Files (x86)\MySQL\MySQLServer5.0\bin 用cmd打开 输入命令:mysqldump –h localhost –u root –p 数据库名字&gt;导出路径 1mysqldump –h localhost –u root –p worker&gt;e:worker.sql 启动MySQL服务：net start mysql 关闭MySQL服务：net stop mysql 创建数据库:create database 数据库名字; 1create database test; 创建数据库的时候，指定字符集 create database 数据库的名字 character set 字符集; 1create database test character set utf8; create database 数据库的名字 character set 字符集 collate 校对规则; 1create database test character utf8 collate utf8_bin; 查看数据库：show create database 数据库名字; 查看所有数据库 1show databases; 注意：三个文件不可删information_schema 相关信息约束performance_schema 相关表现约束mysql 修改数据库的操作修改数据库的字符集 alter database 数据库的名字 character set 字符集 1alter database test character set gbk; 删除数据库drop database 数据库名字; 切换数据库(选中数据库)use 数据库名字; ###查看当前正在使用的数据库 1select database (); 表的CRUD操作### 创建表 12345create database 数据库名字 create table 表名( 列名 列的类型(长度) 约束, 列名2 列的类型(长度) 约束 ); 列的类型 列的约束主键约束：primary key唯一约束：unique非空约束：not null 123456create table student(sid int primary key,sname varchar(10),sex int,age int); 查看表查看所有的表 1show tables; 查看表的创建过程 show create table 表名; 1show create table student; 查看表的结构 1desc student; 修改表添加(add)，修改列(modify)，修改列名(change)，删除列(drop)，修改表名(rename)，修改表的字符集 添加列(add) alter table 表名 add 列名 列的类型 列的约束 1alter table student add score int not null; 修改列(modify) 1alter table student modify sex varchar(2); 修改列名(change) 1alter table student change sex gender varchar(2); 删除列(drop) 1alter table student drop score; 修改表名(rename) 1rename table student to students; 修改表的字符集 1alter table student character set gbk; 删除表1drop table students; 移动列的顺序alter table 表名 modify 字段名 字段类型 after 字段alter table student modify sex int(11) after sname;(移动到sname后面)alter table student modify sex int(11) first;(移动到最前面) SQL完成对表中数据的CRUD的操作插入数据insert into 表名(列名1,列名2,列名3) values(值1,值2,值3); 1insert into student(sid,sname,sex,age) values(1,'zhangsan',1,22); 简单写法(插入部分列列名不可省略) 1insert into student values(2, 'zhangsan',1,22); 批量插入 1234insert into student values(3, 'zhangsan',1,22),(4, 'zhangsan',1,22),(5, 'zhangsan',1,22); 查看表中数据1select * from student; 解决表中插入数据中文乱码的问题1、 设置数据库的表字符编码为jbk；2、 停止MySQL服务(net stop mysql)；3、 找到MySQL的安装路径，找到my.ini文件，把default-character-set=utf8修改为default-character-set=gbk；4、 启动MySQL服务(net start mysql)，重新登录数据库。 删除记录delete from 表名 [where 条件] 1delete from student where sid=5; 把表中数据全部删除 1delete from student; 问题：delete删除数据和truncate删除数据有什么差别？delete:DML一条一条删除表中的数据truncate:DDL先删除表再重建表关于哪条执行效率高，具体要看表中的数据如果数据比较少，delete比较高效如果数据比较多，truncate比较高效 更新表记录update 表名 set 列名=列的值，列名2=列名2的值 [where 条件]如果参数是字符串、日期 要加上单引号 1update student set sname= '张三' where sid=5; 1update student set sname= '李四' ,sex='1'; 查询记录select [distinct] [ * ] [列名,列名2] from 表名 [where 条件] 说明：distinct：去除重复的数据select：选择显示哪些列的内容 简单查询查询所有 select * from 表名 查询姓名和性别 1select sname,sex from student; 别名查询，as的关键字，as关键字可以省略 表别名select s.sname,s.sex from student as s;(主要用在多表查询) 列别名select sname as 姓名,age as 年龄 from student; 去掉重复的值 1select age from student; 1select distinct age from student; 说明：select： 运算查询：仅在查询结果上做了运算 1select * ,age*2 from student; 1select * ,age*2 as 两倍年龄 from student; 条件查询[where关键字] 查询年龄大于20的学生 1select * from student where age &gt; 20; where 后的条件写法 说明：关系运算符：&gt; &gt;= &lt; &lt;= != &lt;&gt;&lt;&gt; 不等于 标准SQL语法!= 不等于 非标准SQL语法 查询学生年龄不等于20的所有学生 1select * from student where age &lt;&gt; 20; 1select * from student where age != 20; 查询年龄在20到30之间 1select * from student where age &gt; 20 and age &lt; 30; 使用 between… and… 查询 1select * from student where age between 20 and 30; 逻辑运算：and , or , not 查询年龄小于15 或者年龄大于20 1select * from student where age &lt; 15 or age &gt; 20; 复杂查询 模糊查询 —like： _ :代表的是一个字符% :代表的是多个字符 查询姓名中带有 张 的所有学生 ‘%张%’ 1select * from student where sname like '%张%'; 查询第二名字是三的所有学生 ‘_张%’ 1select * from student where sname like '_张%'; —in 在某个范围获得值 查询年龄在20,21,22里面的所有学生 1select * from student where age in (20,21,22); 排序查询 order by 关键字asc :ascend 升序(默认的排序方式)desc:descend 降序 查询所有学生的年龄，按照年龄进行排序 1select * from student order by age; 查询所有学生的年龄，按照年龄进行降序排序 1select * from student order by age desc; 查询学生姓名有 张 的学生，按年龄排序 查询学生姓名有 张 的所有学生 1select * from student where sname like '%张%'; 进行排序得出结果 1select * from student where sname like '%张%' order by age asc; 聚合函数sum(): 求和avg(): 求平均值count(): 统计数据max(): 最大值min(): 最小值 获得所有商品价格的总和 select sum(价格名称) from 表名; 1select sum(price) from product; 获得所商品的平均价格 1select avg(price) from product; 获得所有商品的个数 1select count(*) from product; 注意：where 条件后面不能接聚合函数 查出商品价格大于平均的所有商品 查出所有商品 1select from product; 大于平均价格 1select avg(price) from product; 如平均价格为100 1select * from product where price &gt; 100; 或者(子查询) 1select * from product where price &gt; (select avg(price) from product); 分组group by 根据cno字段分组，分组后统计商品的个数 1select cno,count(*) from product group by cno; 根据cno分组，分组统计每组商品的平均价格，并且商品平均价格 &gt; 60 123select cno,avg(price)from product group by cnohaving avg(price) &gt; 60; 说明：having 关键字 可以接聚合函数 出现在分组之后where 关键字 它是不可以接聚合函数 出现在在分组之前 编写顺序 S..F..W..G..H..O 1select..from..where..group by..having..order by 执行顺序 F..W..G..H..S..O 1from..where..group by..having..select..order by SQL多表操作SQL 会创建多表及多表的关系 需求:分类表和商品表之间是不是有关系? 如果有关系,在数据库中如何表示这种关系 12345create table category(cid int primary key auto_increment,cname varchar(10), cdesc varchar(31)); 12345insert into category values(null,'手机数码','电子产品,黑马生产');insert into category values(null,'鞋靴箱包','江南皮鞋厂倾情打造');insert into category values(null,'香烟酒水','黄鹤楼,茅台,二锅头');insert into category values(null,'酸奶饼干','娃哈哈,蒙牛酸酸乳');insert into category values(null,'馋嘴零食','瓜子花生,八宝粥,辣条'); 1select * from category; 1select cname,cdesc from category; 所有商品1.商品ID2.商品名称3.商品的价格4.生产日期5.商品分类ID 商品和商品分类 : 所属关系 1234567create table product(pid int primary key auto_increment,pname varchar(10),price double,pdate timestamp,cno int); 12345678insert into product values(null,'小米mix4',998,null,1);insert into product values(null,'锤子',2888,null,1);insert into product values(null,'阿迪王',99,null,2);insert into product values(null,'老村长',88,null,3);insert into product values(null,'劲酒',35,null,3);insert into product values(null,'小熊饼干',1,null,4);insert into product values(null,'卫龙辣条',1,null,5);insert into product values(null,'旺旺大饼',1,null,5); 多表之间的关系如何来维护外键约束: foreign key 给product中的这个cno 添加一个外键约束 1alter table product add foreign key(cno) references category(cid); 建数据库原则通常情况下,一个项目/应用建一个数据库 多表之间的建表原则 一对多 : 商品和分类建表原则: 在多的一方添加一个外键,指向一的一方的主键 多对多: 老师和学生, 学生和课程建表原则: 建立一张中间表,将多对多的关系,拆分成一对多的关系,中间表至少要有两个外键,分别指向原来的那两张表 一对一: 班级和班长, 公民和身份证, 国家和国旗 建表原则:将一对一的情况,当作是一对多情况处理,在任意一张表添加一个外键,并且这个外键要唯一,指向另外一张表直接将两张表合并成一张表将两张表的主键建立起连接,让两张表里面主键相等实际用途: 用的不是很多.(拆表操作)相亲网站:个人信息 : 姓名,性别,年龄,身高,体重,三围,兴趣爱好,(年收入,特长,学历, 职业, 择偶目标,要求)拆表操作 : 将个人的常用信息和不常用信息,减少表的臃肿, 网上商城表实例的分析:用户购物流程(用户表、订单表、商品表、商品分类表) 用户表 (用户的ID,用户名,密码,手机) 123456create table user( uid int primary key auto_increment, username varchar(31), password varchar(31), phone varchar(11) ); 1insert into user values(1,'zhangsan','123','13811118888'); 订单表 (订单编号,总价,订单时间 ,地址,外键用户的ID) 12345678create table orders( oid int primary key auto_increment, sum int not null, otime timestamp, address varchar(100), uno int, foreign key(uno) references user(uid) ); 12insert into orders values(1,200,null,'黑马前台旁边小黑屋',1);insert into orders values(2,250,null,'黑马后台旁边1702',1); 商品表 (商品ID, 商品名称,商品价格,外键cno) 1234567create table product( pid int primary key auto_increment, pname varchar(10), price double, cno int, foreign key(cno) references category(cid) ); 12345678insert into product values(null,'小米mix4',998,1);insert into product values(null,'锤子',2888,1);insert into product values(null,'阿迪王',99,2);insert into product values(null,'老村长',88,3);insert into product values(null,'劲酒',35,3);insert into product values(null,'小熊饼干',1,4);insert into product values(null,'卫龙辣条',1,5);insert into product values(null,'旺旺大饼',1,5); 订单项: 中间表(订单ID,商品ID,商品数量,订单项总价) 12345678create table orderitem( ono int, pno int, foreign key(ono) references orders(oid), foreign key(pno) references product(pid), ocount int, subsum double); 给1号订单添加商品 200块钱的商品 12insert into orderitem values(1,7,100,100);insert into orderitem values(1,8,101,100); 给2号订单添加商品 250块钱的商品 () 12insert into orderitem values(2,5,1,35);insert into orderitem values(2,3,3,99); 商品分类表(分类ID,分类名称,分类描述) 12345create table category( cid int primary key auto_increment, cname varchar(15), cdesc varchar(100) ); 12345insert into category values(null,'手机数码','电子产品,黑马生产');insert into category values(null,'鞋靴箱包','江南皮鞋厂倾情打造');insert into category values(null,'香烟酒水','黄鹤楼,茅台,二锅头');insert into category values(null,'酸奶饼干','娃哈哈,蒙牛酸酸乳');insert into category values(null,'馋嘴零食','瓜子花生,八宝粥,辣条'); 多表之间的关系如何维护外键约束 : foreign key 添加一个外键: 1alter table product add foreign key(cno) references category(cid); 删除的时候, 先删除外键关联的所有数据,再才能删除分类的数据 建表原则一对多:建表原则: 在多的一方增加一个外键,指向一的一方 多对多:建表原则: 将多对多转成一对多的关系,创建一张中间表 一对一: 不常用, 拆表操作建表原则: 将两张表合并成一张表将两张表的主键建立起关系将一对一的关系当作一对多的关系去处理 主键约束:默认就是不能为空, 唯一外键都是指向另外一张表的主键主键一张表只能有一个 ##### 唯一约束:列面的内容, 必须是唯一, 不能出现重复情况, 为空唯一约束不可以作为其它表的外键可以有多个唯一约束 一对多 : 建表原则: 在多的一方添加一个外键,指向一的一方 多对多: 建表原则: 拆成一对多 创建一张中间表, 至少要有两个外键, 指向原来的表 一对一: 建表原则: 合并一张表, 将主键建立关系 , 将它当作一对多的情况来处理 交叉连接查询(笛卡尔积)1SELECT * FROM product; 1SELECT * FROM category; 笛卡尔积 ,查出来是两张表的乘积 ,查出来的结果没有意义 1SELECT * FROM product,category; 过滤出有意义的数据1SELECT * FROM product,category WHERE cno=cid; 1SELECT * FROM product AS p,category AS c WHERE p.cno=c.cid; 1SELECT * FROM product p,category c WHERE p.cno=c.cid; 数据准备 1INSERT INTO product VALUES(NULL,'耐克帝',10,NULL); 内连接查询隐式内链接 1SELECT * FROM product p,category c WHERE p.cno=c.cid; 显示内链接 1SELECT * FROM product p INNER JOIN category c ON p.cno=c.cid; 区别: 隐式内链接: 在查询出结果的基础上去做的WHERE条件过滤 显示内链接: 带着条件去查询结果, 执行效率要高 左外连接 左外连接,会将左表中的所有数据都查询出来, 如果右表中没有对应的数据,用NULL代替 1SELECT * FROM product p LEFT OUTER JOIN category c ON p.cno=c.cid; 准备工作 1INSERT INTO category VALUES(100,'电脑办公','电脑叉叉差'); 右外连接: 会将右表所有数据都查询出来, 如果左表没有对应数据的话, 用NULL代替 1SELECT * FROM product p RIGHT OUTER JOIN category c ON p.cno=c.cid; 分页查询 每页数据数据3起始索引从0第1页: 0第2页: 3起始索引: index 代表显示第几页 页数从1开始每页显示3条数据 1startIndex = (index-1)*3 第一个参数是索引第二个参数显示的个数 12select * from product limit 0,3;select * from product limit 3,3; 子查询查询出(商品名称,商品分类名称)信息查询分类名称为手机数码的所有商品 查询分类名为手机数码的ID 1select * from category where cname ='手机数码'; 得出ID为1的结果 1SELECT * FROM product WHERE cno = (SELECT cid FROM category WHERE cname='手机数码'); 查询出(商品名称,商品分类名称)信息 左连接 1SELECT p.pname,c.cname FROM product p LEFT OUTER JOIN category c ON p.cno = c.cid; 子查询 1SELECT pname ,(SELECT cname FROM category c WHERE p.cno=c.cid ) AS 商品分类名称 FROM product p; 总结下面这张表时本章的主要内容]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务技术——Tomcat]]></title>
    <url>%2F2019%2F07%2F27%2FWeb%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Tomcat%2F</url>
    <content type="text"><![CDATA[服务器 其实服务器就是一台电脑。 配置比一般的电脑要好。 Web服务器软件 客户端在浏览器的地址栏上输入地址 ，然后web服务器软件，接收请求，然后响应消息。处理客户端的请求， 返回资源 | 信息。 Web应用：需要服务器支撑 服务器 所属公司 Tomcat-----------Apache WebLogic---------BEA WebSphere--------IBM IIS--------------微软Tomcat安装 直接解压 ，然后找到bin目录下的startup.bat文件启动。 启动之后，如果能够正常看到黑窗口，表明已经成功安装。 为了确保万无一失， 最好在浏览器的地址栏上输入 ： http://localhost:8080 , 如果有看到如下内容就表明成功了。 如果双击了startup.bat, 看到一闪而过的情形，一般都是 JDK的环境变量没有配置。 Tomcat目录介绍bin：包含了一些jar , bat文件 。 startup.bat conf：tomcat的配置，如 server.xml web.xml lib：tomcat运行所需的jar文件 logs：运行的日志文件 temp：临时文件 webapps：发布到tomcat服务器上的项目，就存放在这个目录。 work：jsp翻译成class文件存放地如何把一个项目发布到Tomcat中 需求： 如何能让其他的电脑访问我这台电脑上的资源？ 在电脑新建stu.xml文件，内容如下 1234&lt;person&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt;&lt;/person&gt; 直接拷贝stu.xml文件到webapps/ROOT目录下， 在浏览器里面访问默认访问方式：http://localhost:8080/stu.xml 可以使用IP地址访问：http://192.168.43.139:8080/stu.xml 注意： 如果Tomcat在运行需要重新启动，否则会报404错误。 需要把xml文件改为UTF-8编码，否则会报错。解决方法是使用记事本打开xml文件，选择文件——&gt;另存为，“编码”格式选则UTF-8，点击保存。 在webaps下面新建一个文件夹xml , 然后拷贝文件放置到这个文件夹中http://localhost:8080/xml/stu.xml 也可以使用IP地址访问：http://192.168.43.139:8080/xml/stu.xml 说明： http://localhost:8080 ： 其实对应的是到webapps/roothttp://localhost:8080/xml/ : 对应是 webapps/xml 配置虚拟路径(一) 查看使用文档说明 使用localhost：8080 打开tomcat首页， 在左侧找到tomcat的文档入口， 点击进去后， 在左侧接着找到 Context入口，点击进入。 也可以输入地址访问：http://localhost:8080/docs/config/context.html 在conf/server.xml 找到host元素节点 12&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; 加入以下内容 1&lt;Context docBase="D:\xml02" path="/a"&gt;&lt;/Context&gt; 在D盘新建xml02文件夹，在文件夹下新建person.xml文件，内容如下 12345&lt;person&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;body&gt;这里是虚拟路径&lt;/body&gt;&lt;/person&gt; 说明: 1). docBase： 项目的路径地址，如： D:\xml02\person.xml。 2). path : 对应的虚拟路径 一定要以/打头。 在浏览器地址栏上输入：http://localhost:8080/a/person.xml 配置虚拟路径(二) 在tomcat/conf/catalina/localhost/ 文件夹下新建一个xml文件，名字可以自己定义。如person.xml。 在person.xml文件里面写入以下内容 12&lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;Context docBase="D:\xml02"&gt;&lt;/Context&gt; 在浏览器上面访问：http://localhost:8080/person/person.xml 注意： XML文件的名字也就是项目部署成功后的web根路径，如定义这person.xml,那么后面的访问路径就是http://ip:port/person。 给Eclipse配置Tomcat 在server里面 右键新建一个服务器， 选择到Apache分类， 找到对应的Tomcat版本， 接着一步一步配置即可。 配置完毕后， 在server 里面， 右键刚才的服务器，然后Open ， 找到上面的Server Location , 选择中间的 Use Tomcat installation… 创建Web工程， 在WebContent下定义html文件， 右键工程， run as server 程序架构 C/S(Client/Server) QQ、微信、LOL 优点： 有一部分代码写在客户端， 用户体验比较好。 缺点： 服务器更新，客户端也要随着更新。 占用资源大。 B/S(Browser/Server) 网页游戏 ， WebQQ … 优点： 客户端只要有浏览器就可以了。 占用资源小， 不用更新。 缺点： 用户体验不佳。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接技术——JDBC(Java DataBase Connectivity)]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94JDBC%2F</url>
    <content type="text"><![CDATA[为什么会出现JDBC SUN公司提供的一种数据库访问规则、规范, 由于数据库种类较多，并且Java语言使用比较广泛，SUN公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的Java程序只要使用SUN公司提供的JDBC驱动即可。 使用JDBC的基本步骤 注册驱动： 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 建立连接：参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。 12//DriverManager.getConnection("jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb"); conn = DriverManager.getConnection("jdbc:mysql://localhost/student", "root", "root"); 创建statement：跟数据库打交道，一定需要这个对象。 1st = conn.createStatement(); 执行sql ，得到ResultSet：执行查询，得到结果集。 12String sql = "select * from t_stu";rs = st.executeQuery(sql); 遍历结果集：遍历查询每一条记录 。 123456while(rs.next())&#123; int id = rs.getInt("id"); String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println("id="+id + "===name="+name+"==age="+age); &#125; 释放资源： 1234567if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException sqlEx) &#123; &#125; // ignore rs = null; &#125;... JDBC 工具类构建 资源释放工作的整合 驱动防二次注册 1). river 这个类里面有静态代码块，一上来就执行了，所以等同于我们注册了两次驱动。 其实没这个必要的。 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 2). 静态代码块 ——&gt;类加载了，就执行。 1java.sql.DriverManager.registerDriver(new Driver()); 3).最后形成以下代码即可。 1Class.forName("com.mysql.jdbc.Driver"); 使用properties配置文件 1). 在src底下声明一个文件 xxx.properties ，里面的内容如下： 1234driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost/studentname=rootpassword=root 2). 在工具类里面，使用静态代码块，读取属性 123456789101112131415161718192021static&#123; try &#123; //创建一个属性配置对象 Properties properties = new Properties(); InputStream is = new FileInputStream("jdbc.properties"); //对应文件位于工程根目录 //使用类加载器，去读取src底下的资源文件。 后面在servlet //对应文件位于src目录底下 //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties"); //导入输入流。 properties.load(is); //读取属性 driverClass = properties.getProperty("driverClass"); url = properties.getProperty("url"); name = properties.getProperty("name"); password = properties.getProperty("password"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; ​ 数据库(SQL)的CRUD insert INSERT INTO t_stu (NAME , age) VALUES (&apos;wangqiang&apos;,28) //INSERT INTO t_stu VALUES (NULL,&apos;wangqiang2&apos;,28) 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "insert into t_stu values(null , 'aobama' , 59)";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql); if(result &gt;0 )&#123; System.out.println("添加成功");&#125;else&#123; System.out.println("添加失败");&#125; delete DELETE FROM t_stu WHERE id = 6 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "delete from t_stu where name='aobama'";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql); if(result &gt;0 )&#123; System.out.println("删除成功");&#125;else&#123; System.out.println("删除失败");&#125; query SELECT * FROM t_stu 12345678910111213141516// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();// 3. 执行sql语句，返回ResultSetString sql = "select * from t_stu";rs = st.executeQuery(sql);// 4. 遍历结果集while (rs.next()) &#123; String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println(name + " " + age); &#125; update UPDATE t_stu SET age = 38 WHERE id = 1; 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "update t_stu set age = 26 where name ='qyq'";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql);if(result &gt;0 )&#123; System.out.println("更新成功");&#125;else&#123; System.out.println("更新失败");&#125; 使用单元测试，测试代码 定义一个类， TestXXX , 里面定义方法 testXXX. 添加Junit的支持。右键工程 — add Library — Junit — Junit4 在方法的上面加上注解 ， 其实就是一个标记。 1234@Testpublic void testQuery() &#123; ...&#125; 光标选中方法名字，然后右键执行单元测试。 或者是打开outline视图， 然后选择方法右键执行。 Dao模式 Data Access Object 数据访问对象 新建一个dao的接口， 里面声明数据库访问规则 12345678910/** * 定义操作数据库的方法 */public interface UserDao &#123; /** * 查询所有 */ void findAll();&#125; 新建一个dao的实现类，具体实现早前定义的规则 123456789101112131415161718192021222324252627282930 public class UserDaoImpl implements UserDao&#123; @Override public void findAll() &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1. 获取连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); String sql = "select * from t_user"; rs = st.executeQuery(sql); while(rs.next())&#123; String userName = rs.getString("username"); String password = rs.getString("password"); System.out.println(userName+"="+password); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, st, rs); &#125; &#125;&#125; 直接使用实现 12345@Testpublic void testFindAll()&#123; UserDao dao = new UserDaoImpl(); dao.findAll();&#125; Statement安全问题 Statement执行 ，其实是拼接sql语句的。即先拼接sql语句，然后在一起执行。 123456789String sql = "select * from t_user where username='"+ username +"' and password='"+ password +"'";UserDao dao = new UserDaoImpl();dao.login("admin", "100234khsdf88' or '1=1"); SELECT * FROM t_user WHERE username='admin' AND PASSWORD='100234khsdf88' or '1=1' //前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 rs = st.executeQuery(sql); PrepareStatement 该对象就是替换前面的statement对象。 相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。 123456String sql = "insert into t_user values(null , ? , ?)";ps = conn.prepareStatement(sql); //给占位符赋值 从左到右数过来，1 代表第一个问号， 永远都是从1开始。ps.setString(1, userName); ps.setString(2, password); ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务技术——Servlet]]></title>
    <url>%2F2019%2F07%2F25%2FWeb%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Servlet%2F</url>
    <content type="text"><![CDATA[Servlet是什么? 其实就是一个Java程序，运行在我们的Web服务器上，用于接收和响应客户端的HTTP请求。 更多的是配合动态资源来做。 当然静态资源也需要使用到Servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet Servlet执行过程第一步：类的定义1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.huang.servlet;import java.io.IOException;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;/** * *@author 黄远志 *@date 2019年7月4日下午7:08:19 *@GitHub https://github.com/huangyuanzhi1997 */public class HelloServlet implements Servlet &#123; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println("HelloServlet"); &#125; @Override public void destroy() &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void init(ServletConfig config) throws ServletException &#123; &#125;&#125; 第二步：Servlet的配置1234567891011&lt;!-- 向tomcat报告， 我这个应用里面有这个servlet，名字叫做HelloServlet , 具体的路径是com.huang.servlet.HelloServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.huang.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 注册servlet的映射。 servletName : 找到上面注册的具体servlet，url-pattern: 在地址栏上的path一定要以/打头 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 找到Tomcat应用 找到项目 找web.xml，然后在里面找到url-pattern，有没有哪一个patten的内容是/a 找到servlet-mapping中的那个servlet-name【HelloServlet】 找到上面定义的servlet元素中的servlet-naem【HelloServlet】 找到下面定义的servlet-class，然后开始创建该类的实例 继而执行该servlet中的service方法 Servlet的通用写法Servlet (接口) | | GenericServlet | | HttpServlet （用于处理http的请求）定义一个类，继承HttpServlet 复写doGet 和 doPost12345678910111213141516171819202122232425262728293031323334353637package com.huang.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * *@author 黄远志 *@date 2019年7月4日下午7:51:01 *@GitHub https://github.com/huangyuanzhi1997 */public class HelloServlet02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("HelloServlet02..."); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); System.out.println("get..."); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); System.out.println("post..."); &#125;&#125; Servlet的生命周期 生命周期 从创建到销毁的一段时间。 生命周期方法 从创建到销毁，所调用的那些方法。 init方法 在创建该Servlet的实例时，就执行该方法。 一个Servlet只会初始化一次， init方法只会执行一次。 默认情况下是 ： 初次访问该Servlet，才会创建实例。 service方法 只要客户端来了一个请求，那么就执行这个方法了。 该方法可以被执行很多次。 一次请求，对应一次service方法的调用。 destroy方法 servlet销毁的时候，就会执行该方法。 1). 该项目从Tomcat的里面移除。 2). 正常关闭Tomcat就会执行 shutdown.bat。 doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。 让Servlet创建实例的时机提前 默认情况下，只有在初次访问Servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么有没有方法可以让这个初始化的时机提前一点。 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 12345&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt; 为什么需要有这个ServletConfig Servlet的配置，通过这个对象，可以获取Servlet在配置的时候一些信息 先说 ， 再写怎么用， 最后说有什么用。 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。它的代码放置在了自己的servlet类里面。 刚好这个Servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个Servlet的公司，在注册Servlet的时候，必须要在web.xml里面，声明init-params 在开发当中比较少用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
