<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringMVC概述]]></title>
    <url>%2F2019%2F08%2F12%2FSpringMVC%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[SpringMVC简介第一个SpringMVC程序SpringMVC执行流程再解&lt;url-pattern/&gt;绝对路径与相对路径]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring与DAO]]></title>
    <url>%2F2019%2F08%2F10%2FSpring%E4%B8%8EDAO%2F</url>
    <content type="text"><![CDATA[Spring 所使用的操作数据库的技术： JDBC 模板的使用和 Spring 对于事务的管理。 JDBC 模板的使用，是 IoC 的应用，将 JDBC 模板对象注入给了 Dao 层的实现类。 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。 Spring与JDBC模板为了避免直接使用 JDBC 而带来的复杂且冗长的代码， Spring 提供了一个强有力的模板类——JdbcTemplate 来简化 JDBC 操作。并且，数据源 DataSource 对象与模板 JdbcTemplate 对象均可通过 Bean 的形式定义在配置文件中，充分发挥了依赖注入的威力。 数据源的配置使用 JDBC 模板，首先需要配置好数据源，数据源直接以 Bean 的形式配置在 Spring 配置文件中。根据数据源的不同，其配置方式不同。常用数据源的配置方式有三种： Spring 默认的数据源 DBCP 数据源 C3P0 数据源 Spring 默认的数据源Spring 默认的数据源为 DriverManagerDataSource，其有一个属性 DriverClassName，用于接收 DB 驱动。 1234567&lt;!-- 注册数据源：Spring内置连接池 --&gt;&lt;bean id="myDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt;&lt;/bean&gt; DriverManagerDataSource 类继承自 AbstractDriverBasedDataSource。其有三个属性用于接收连接数据库的 URL、用户名与密码。 DBCP 数据源DBCP(DataBase Connection Pool)，是 apache 下的项目，DBCP 数据源是 BasicDataSource，其有 driverClassName、 url、 username、 password 四个 DB 连接属性。 1234567&lt;!-- 注册数据源：DBCP --&gt;&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt;&lt;/bean&gt; C3P0 数据源C3P0 数据源是 ComboPooledDataSource ，其有 DriverClass、JdbcUrl、 User、 Password 四个 DB 连接属性。 1234567&lt;!-- 注册数据源：C3P0 --&gt;&lt;bean id="myDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt; 从属性文件读取数据库连接信息为了便于维护，可以将数据库连接信息写入到属性文件中，使 Spring 配置文件从中读取数据。 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.user=rootjdbc.password=123456 Spring 配置文件从属性文件中读取数据时，需要在&lt;property/&gt;的 value 属性中使用${ }，将在属性文件中定义的 key 括起来，以引用指定属性的值。 该属性文件若要被 Spring 配置文件读取，其必须在配置文件中进行注册。注册方式有两种： &lt;bean/&gt;方式 &lt;context&gt;方式 &lt;bean/&gt;方式以 PropertyPlaceholderConfigurer 类的 bean 实例的方式进行注册。该类有一个属性 location，用于指定属性文件的位置。 1234&lt;!-- 注册属性文件：方式一 --&gt;&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties"/&gt;&lt;/bean&gt; &lt;context:property-placeholder/&gt;方式12&lt;!-- 注册属性文件：方式二 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; 注意：该方式要求在 Spring 配置文件头部加入 context 的约束，&lt;context:property-placeholder/&gt;标签中有一个属性 location，用于指定属性文件的位置。 配置JDBC模板JDBC 模板类 JdbcTemplate 从其父类 JdbcAccessor 继承了一个属性 dataSource，用于接收数据源。 12345&lt;!-- 注册JdbcTemplate --&gt;&lt;bean id="myJdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt; Dao实现类继承JdbcDaoSupportJdbcDaoSupport 类中有一个属性 JdbcTemplate，用于接收 JDBC 模板。所以 Dao 实现类继承了 JdbcDaoSupport 类后，也就具有了 JDBC 模板属性。在配置文件中，只要将模板对象注入即可。 对DB的增、删、改操作JdbcTemplate 类中提供了对 DB 进行修改、查询的方法。 Dao 实现类使用继承自 JdbcDaoSupport 的 getTemplate()方法，可以获取到 JDBC 模板对象。 123456789101112public interface IStudentDao &#123; void insertStudent(Student student); void deleteById(int id); void updateStudent(Student student); List&lt;String&gt; selectAllStudentsNames(); String selectStudentNameById(int id); List&lt;Student&gt; selectAllStudents(); Student selectStudnetById(int id);&#125; 对 DB 的增、删、改都是通过 update()方法实现的。该方法常用的重载方法有两个： 1public int update ( String sql) 1public int update ( String sql, Object… args) 第 1 个参数为要执行的 sql 语句，第 2 个参数为要执行的 sql 语句中所包含的动态参数。其返回值为所影响记录的条数。一般不用。 对DB的查询操作JDBC 模板的查询结果均是以对象的形式返回。根据返回对象类型的不同，可以将查询分为两类： 简单对象查询：查询结果为 String、 Integer 等简单对象类型，或该类型做为元素的集合类型，如 List&lt;String&gt;等。 自定义对象查询：查询结果为自定义类型，如 User 等，或该类型做为元素的集合类型，如 List&lt;User&gt;等。 简单对象查询常用的简单对象查询方法有：查询结果为单个对象的 queryForObject()与查询结果为 List的 queryForList()。 1pubic T queryForObject (String sql, Class&lt;T&gt; type, Object... args) 1pubic List&lt;T&gt; queryForList (String sql, Class&lt;T&gt; type, Object... args) 1234567891011@Overridepublic List&lt;String&gt; selectAllStudentsNames() &#123; String sql = "select name from student"; return this.getJdbcTemplate().queryForList(sql, String.class);&#125;@Overridepublic String selectStudentNameById(int id) &#123; String sql = "select name from student where id=?"; return this.getJdbcTemplate().queryForObject(sql, String.class, id);&#125; 自定义对象查询常用的自定义对象查询方法有：查询结果为单个对象的 queryForObject()与查询结果为List 的 query()。 1pubic T queryForObject (String sql, RowMapper&lt;T&gt; m , Object... args) 1pubic List&lt;T&gt; query (String sql, RowMapper&lt;T &gt; m, Object... args) RowMapper 为记录映射接口，用于将查询结果集中每一条记录包装为指定对象。该接口中有一个方法需要实现： 1public Object mapRow(ResultSet rs, int rowNum) 参数 rowNum 表示总的结果集中当前行的行号，但参数 rs 并不表示总的结果集，而是表示 rowNum 所代表的当前行的记录所定义的结果集，仅仅是当前行的结果。一般来说，该方法体中就是实现将查询结果中当前行的数据包装为一个指定对象。 123456789101112131415public class StudentRowMapper implements RowMapper&lt;Student&gt; &#123; // rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到 // 这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度 // 来说，只要能执行到这个方法，就说明这里的rs不会是空的 @Override public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Student student = new Student(); student.setId(rs.getInt("id")); student.setName(rs.getString("name")); student.setAge(rs.getInt("age")); return student; &#125;&#125; 1234567891011@Overridepublic List&lt;Student&gt; selectAllStudents() &#123; String sql = "select id,name,age from student"; return this.getJdbcTemplate().query(sql, new StudentRowMapper());&#125;@Overridepublic Student selectStudnetById(int id) &#123; String sql = "select id,name,age from student where id=?"; return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);&#125; 注意：JdbcTemplate 对象是多例的，即系统会为每一个使用模板对象的线程（方法）创建一个 JdbcTemplate 实例，并且在该线程（方法）结束时，自动释放 JdbcTemplate 实例。所以在每次使用 JdbcTemplate 对象时，都需要通过 getJdbcTemplate()方法获取。 Spring的事务管理事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理： 使用 Spring 的事务代理工厂管理事务 使用 Spring 的事务注解管理事务 使用 AspectJ 的 AOP 配置管理事务 Spring事务管理APISpring 的事务管理，主要用到两个事务相关的接口。 1. 事务管理器接口事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。 常用的两个实现类 DataSourceTransactionManager：使用 JDBC 或 iBatis 进行持久化数据时使用。 HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。 Spring 的回滚方式Spring 事务的默认回滚方式是： 发生运行时异常时回滚，发生受查异常时提交。对于受查异常，也可以手工设置其回滚方式。 错误与异常 Throwable 类是 Java 语言中所有错误或异常的超类。只有当对象是此类(或其子类之一)的实例时， 才能通过 Java 虚拟机或者 Java 的 throw 语句抛出。 Error 是程序在运行过程中出现的无法处理的错误，比如OutOfMemoryError、ThreadDeath、 NoSuchMethodError 等。当这些错误发生时，程序是无法处理（捕获或抛出）的， JVM 一般会终止线程。 程序在编译和运行时出现的另一类错误称之为异常，它是 JVM 通知程序员的一种方式。通过这种方式，让程序员知道已经或可能出现错误，要求程序员对其进行处理。 异常分为运行时异常与受查异常： 运行时异常， 是 RuntimeException 类或其子类 ， 即只有在运行时才出现的异常。如，NullPointerException、 ArrayIndexOutOfBoundsException、 IllegalArgumentException 等均属于运行时异常。这些异常由 JVM 抛出，在编译时不要求必须处理（捕获或抛出）。但，只要代码编写足够仔细，程序足够健壮，运行时异常是可以避免的。(Hibernate 异常 HibernateException 也属于运行时异常)。 受查异常，也叫编译时异常，即在代码编写时要求必须捕获或抛出的异常，若不处理，则无法通过编译。如 SQLException， ClassNotFoundException， IOException 等都属于受查异常。 RuntimeException 及其子类以外的异常，均属于受查异常。当然，用户自定义的 Exception 的子类，即用户自定义的异常也属受查异常。 定义异常时，只要未明确声明定义的为 RuntimeException 的子类，那么定义的就是受查异常。 2. 事务定义接口事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量： 事务隔离级别、事务传播行为、事务默认超时时限， 及对它们的操作。 定义了五个事务隔离级别常量这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX。 DEFAULT： 采用 DB 默认的事务隔离级别。 MySql 的默认为 REPEATABLE_READ； Oracle 默认为 READ_COMMITTED。 READ_UNCOMMITTED： 读未提交。 未解决任何并发问题。 READ_COMMITTED： 读已提交。解决脏读，存在不可重复读与幻读。 REPEATABLE_READ： 可重复读。解决脏读、不可重复读，存在幻读。 SERIALIZABLE： 串行化。不存在并发问题。 定义了七个事务传播行为常量谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如， A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。 事务传播行为常量都是以 PROPAGATION_ 开头，形如 PROPAGATION_XXX。 REQUIRED： 指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。 SUPPORTS： 指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。 MANDATORY： 指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。 REQUIRES_NEW： 总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。 NOT_SUPPORTED： 指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。 NEVER： 指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。 NESTED： 指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。 定义了默认事务超时时常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。 注意：事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。 程序举例需求：实现模拟购买股票。存在两个实体：银行账户 Account 与股票账户 Stock。当要购买股票时，需要从 Account 中扣除相应金额的存款，然后在 Stock 中增加相应的股票数量。而在这个过程中，可能会抛出一个用户自定义的异常。异常的抛出，将会使两个操作回滚。 实现步骤： 1. 创建数据库表 2. 创建实体类123456public class Account &#123; private Integer aid; private String aname; private double balance; //余额&#125; 123456public class Stock &#123; private Integer sid; private String sname; //股票名称 private int count; //股票数量&#125; 3. 定义 service 的实现类根据需求，我们可以先定义 Service 实现类，自动生成 Service 接口、Dao 接口和异常类，以减少代码写入。 123456789101112131415161718192021222324252627282930313233343536public class BuyStockServiceImpl implements IBuyStockService &#123; private IAccountDao adao; private IStockDao sdao; public void setAdao(IAccountDao adao) &#123; this.adao = adao; &#125; public void setSdao(IStockDao sdao) &#123; this.sdao = sdao; &#125; @Override public void openAccount(String aname, double money) &#123; adao.insertAccount(aname,money); &#125; @Override public void openStock(String sname, int amount) &#123; sdao.insertStock(sname,amount); &#125; @Override public void buyStock(String aname, double money, String sname, int amount) throws BuyStockException &#123; boolean isBuy = true; adao.updateAccount(aname,money,isBuy); if(1 == 1) &#123; throw new BuyStockException("购买股票异常"); &#125; sdao.updateStock(sname,amount,isBuy); &#125;&#125; 4. 定义 Service 接口1234567public interface IBuyStockService &#123; void openAccount(String aname,double money); void openStock(String sname, int amount); void buyStock(String aname,double money,String sname,int amount) throws BuyStockException;&#125; 5. 定义 dao 接口1234567public interface IAccountDao &#123; void insertAccount(String aname, double money); void updateAccount(String aname, double money, boolean isBuy);&#125; 1234567public interface IStockDao &#123; void insertStock(String sname, int amount); void updateStock(String sname, int amount, boolean isBuy);&#125; 6. 定义异常类12345678910public class BuyStockException extends Exception &#123; public BuyStockException() &#123; super(); &#125; public BuyStockException(String message) &#123; super(message); &#125;&#125; 7. 定义 dao 实现类123456789101112131415161718public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123; @Override public void insertAccount(String aname, double money) &#123; String sql = "insert into account(aname, balance) values(?,?)"; this.getJdbcTemplate().update(sql, aname, money); &#125; @Override public void updateAccount(String aname, double money, boolean isBuy) &#123; String sql = "update account set balance=balance+? where aname=?"; if (isBuy) &#123; sql = "update account set balance=balance-? where aname=?"; &#125; this.getJdbcTemplate().update(sql, money, aname); &#125;&#125; 12345678910111213141516171819public class StockDaoImpl extends JdbcDaoSupport implements IStockDao &#123; @Override public void insertStock(String sname, int amount) &#123; String sql = "insert into stock(sname,count) values(?,?)"; this.getJdbcTemplate().update(sql, sname,amount); &#125; @Override public void updateStock(String sname, int amount, boolean isBuy) &#123; String sql = "update stock set count=count-? where sname=?"; if (isBuy) &#123; sql = "update stock set count=count+? where sname=?"; &#125; this.getJdbcTemplate().update(sql, amount,sname); &#125;&#125; 8. 定义 Spring 配置文件(IoC应用)123456789101112131415161718192021222324&lt;!-- 注册数据源：C3P0 --&gt;&lt;bean id="myDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt;&lt;!-- 注册属性文件 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;!-- 注册Dao --&gt;&lt;bean id="accountDao" class="com.huang.dao.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt;&lt;bean id="stockDao" class="com.huang.dao.StockDaoImpl"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt;&lt;!-- 注册Service --&gt;&lt;bean id="buyStockService" class="com.huang.service.BuyStockServiceImpl"&gt; &lt;property name="adao" ref="accountDao"/&gt; &lt;property name="sdao" ref="stockDao"/&gt;&lt;/bean&gt; 9. 定义测试类1234567891011121314151617181920212223242526public class MyTest &#123; private IBuyStockService service; @Before public void before() &#123; // 创建容器对象，加载Spring配置文件 String resource = "applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); service = (IBuyStockService) ac.getBean("buyStockService"); &#125; @Test public void test01() &#123; service.openAccount("张三", 10000); service.openStock("现代学院", 0); &#125; @Test public void test02() throws BuyStockException &#123; service.buyStock("张三", 2000, "现代学院", 5); &#125; &#125; 10. 运行结果 使用Spring的事务代理工厂管理事务该方式是，需要为目标类，即 Service 的实现类创建事务代理。事务代理使用的类是 TransactionProxyFactoryBean，该类需要初始化如下一些属性： （1） transactionManager：事务管理器（2） target：目标对象，即 Service 实现类对象（3） transactionAttributes：事务属性 1. 修改 Spring 配置文件(AOP应用)1234567891011121314151617181920&lt;!-- 注册事务管理器 --&gt;&lt;bean id="myTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt;&lt;!-- 生成事务代理对象 --&gt;&lt;bean id="serviceProxy" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt; &lt;property name="transactionManager" ref="myTransactionManager"/&gt; &lt;property name="target" ref="buyStockService"/&gt; &lt;property name="transactionAttributes"&gt; &lt;props&gt; &lt;prop key="open*"&gt;ISOLATION_DEFAULT,PROPAGATION_REQUIRED&lt;/prop&gt; &lt;!-- -异常：表示发生指定异常后回滚，这时的异常通常是受查异常 +异常：表示发生指定异常后提交，这时的异常通常是运行时异常 --&gt; &lt;prop key="buyStock"&gt;ISOLATION_DEFAULT,PROPAGATION_REQUIRED, -BuyStockException&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 2. 修改测试类1service = (IBuyStockService) ac.getBean("serviceProxy"); 使用Spring的事物注解管理事务通过@Transactional 注解方式，也可将事务织入到相应方法中。而使用注解方式，只需在配置文件中加入一个 tx 标签，以告诉 spring 使用注解来完成事务的织入。该标签只需指定一个属性，事务管理器。 @Transactional 的所有可选属性如下所示： propagation： 用于设置事务传播属性。该属性类型为 Propagation 枚举，默认值为 Propagation.REQUIRED。 isolation： 用于设置事务的隔离级别。该属性类型为 Isolation 枚举 ，默认值为 Isolation.DEFAULT。 readOnly： 用于设置该方法对数据库的操作是否是只读的。该属性为 boolean，默认值为 false。 timeout： 用于设置本操作与数据库连接的超时时限。单位为秒，类型为 int，默认值为-1，即没有时限。 rollbackFor： 指定需要回滚的异常类。类型为 Class[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。 rollbackForClassName： 指定需要回滚的异常类类名。类型为 String[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。 noRollbackFor： 指定不需要回滚的异常类。类型为 Class[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。 noRollbackForClassName： 指定不需要回滚的异常类类名。类型为 String[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。 注意：@Transactional 若用在方法上，只能用于 public 方法上。对于其他非 public方法，如果加上了注解@Transactional，虽然 Spring 不会报错，但不会将指定事务织入到该方法中。因为 Spring 会忽略掉所有非 public 方法上的@Transaction 注解。若@Transaction 注解在类上，则表示该类上所有的方法均将在执行时织入事务。 1. 修改 Spring 配置文件(AOP应用)1234567&lt;!-- 注册事务管理器 --&gt;&lt;bean id="myTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt;&lt;!-- 注册事务注解驱动 --&gt;&lt;tx:annotation-driven transaction-manager="myTransactionManager"/&gt; 2. 修改测试类1service = (IBuyStockService) ac.getBean("buyStockService"); 3. 在 Service 实现类方法上添加注解 使用AspectJ的AOP配置管理事务使用 XML 配置事务代理的方式的不足是，每个目标类都需要配置事务代理。当目标类较多，配置文件会变得非常臃肿。使用 XML 配置顾问方式可以自动为每个符合切入点表达式的类生成事务代理。 修改配置文件(AOP应用)123456789101112131415161718192021&lt;!-- 注册事务管理器 --&gt;&lt;bean id="myTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt;&lt;!-- 注册事务通知 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="myTransactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 这里指定的是：为每一个连接点指定所要应用的事务属性 --&gt; &lt;tx:method name="open*" isolation="DEFAULT" propagation="REQUIRED"/&gt; &lt;tx:method name="buyStock" isolation="DEFAULT" propagation="REQUIRED" rollback-for="BuyStockException"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- AOP配置 --&gt;&lt;aop:config&gt; &lt;!-- 这里指定的是切入点 --&gt; &lt;aop:pointcut expression="execution(* *..service.*.*(..))" id="myPointcut"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPointcut"/&gt;&lt;/aop:config&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>DAO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring与AOP]]></title>
    <url>%2F2019%2F08%2F08%2FSpring%E4%B8%8EAOP%2F</url>
    <content type="text"><![CDATA[AOP 简介AOP（Aspect Orient Programming），面向切面编程，是面向对象编程 OOP 的一种补充。面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。AOP 底层采用两种动态代理模式实现： JDK 的动态代理与 CGLIB 的动态代理。 AOP 编程术语1. 切面切面(Aspect)泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面有通知与顾问。实际就是对主业务逻辑的一种增强。 2. 织入织入(Weaving)是指将切面代码插入到目标对象的过程。 3. 连接点连接点(JoinPoint)指可以被切面织入的方法。通常业务接口中的方法均为连接点。 4. 切入点切入点(Pointcut)指切面具体织入的方法。注意，被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改的，不能被增强的。 5. 目标对象目标对象(Target)指将要被增强的对象，即包含主业务逻辑的类的对象 。 6. 通知通知(Advice)是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。换个角度来说， 通知定义了增强代码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同(切入点定义切入的位置，通知定义切入的时间)。 7. 顾问顾问(Advisor)是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。 通知 Advice通知（Advice），切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。 常用通知有：前置通知、后置通知、环绕通知、异常处理通知。 通知详解通知（Advice）是 Spring 提供的一种切面（Aspect）。但其功能过于简单：只能将切面织入到目标类的所有目标方法中， 无法完成将切面织入到指定目标方法中。 前置通知定义前置通知，需要实现 MethodBeforeAdvice 接口。该接口中有一个方法 before()，会在目标方法执行之前执行。 前置通知的特点： 在目标方法执行之前先执行。 不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行。 不改变目标方法执行的结果。 （1） 定义业务接口与目标类 1234567public interface ISomeService &#123; //主业务方法 void doFirst(); //主业务方法 void doSecond();&#125; 12345678910111213141516//目标类public class SomeServiceImpl implements ISomeService &#123; //目标方法 @Override public void doFirst() &#123; System.out.println("执行doFirst()方法"); &#125; //目标方法 @Override public void doSecond() &#123; System.out.println("执行doSecond()方法"); &#125;&#125; （2） 定义前置通知 123456789101112131415//前置通知public class MyMethodBeforeAdvice implements MethodBeforeAdvice &#123; /** *当前方法在目标方法执行之前执行 *method：目标方法 *args：目标方法的参数列表 *target：目标对象 */ @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("执行前置通知方法"); &#125; &#125; （3） 定义 Spring 配置文件 1234567891011121314&lt;!-- 注册目标对象 --&gt;&lt;bean id="someService" class="com.huang.aop01.SomeServiceImpl"/&gt;&lt;!-- 注册切面：通知 --&gt;&lt;bean id="myAdvice" class="com.huang.aop01.MyMethodBeforeAdvice"/&gt;&lt;!-- 生成代理对象 --&gt;&lt;bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;!-- &lt;property name="targetName" value="someService"/&gt; --&gt; &lt;!-- 指定目标对象 --&gt; &lt;property name="target" ref="someService"/&gt; &lt;!-- 指定切面 --&gt; &lt;property name="interceptorNames" value="myAdvice"/&gt;&lt;/bean&gt; （4） 定义测试类 1234567891011121314public class MyTest &#123; @Test public void test01() &#123; String resource = "com/huang/aop01/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); //serviceProxy为代理对象，而非目标对象 ISomeService service = (ISomeService) ac.getBean("serviceProxy"); service.doFirst(); System.out.println("----------------------"); service.doSecond(); &#125;&#125; （5） 运行结果 使用 Debug 查看后台运行情况，可以看到代理生成使用的是 JDK 代理机制。 后置通知定义后置通知，需要实现接口AfterReturningAdvice。该接口中有一个方法afterReturning()，会在目标方法执行之后执行。后置通知的特点： 在目标方法执行之后执行。 不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行。 不改变目标方法执行的结果。 （1） 修改业务接口与目标类 1String doSecond(); 123456//目标方法@Overridepublic String doSecond() &#123; System.out.println("执行doSecond()方法"); return "abcde";&#125; （2） 定义后置通知 1234567891011121314public class MyAfterReturningAdvice implements AfterReturningAdvice &#123; @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("执行后置通知方法 returnValue= " + returnValue); if (returnValue != null) &#123; returnValue = ((String) returnValue).toUpperCase(); System.out.println("修改过的结果 returnValue=" + returnValue); &#125; &#125;&#125; （3） 修改 Spring 配置文件 12&lt;!-- 注册切面：通知 --&gt; &lt;bean id="myAdvice" class="com.huang.aop02.MyAfterReturningAdvice"/&gt; （4） 修改测试类 1234567891011@Testpublic void test01() &#123; String resource = "com/huang/aop02/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); //serviceProxy为代理对象，而非目标对象 ISomeService service = (ISomeService) ac.getBean("serviceProxy"); service.doFirst(); System.out.println("----------------------"); String result = service.doSecond(); System.out.println(result);&#125; 环绕通知定义环绕通知，需要实现 MethodInterceptor 接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。 （1） 定义后置通知 123456789101112131415public class MyMethodInterceptor implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println("执行环绕通知：目标方法执行之前"); Object result = invocation.proceed(); System.out.println("执行环绕通知：目标方法执行之后"); if (result != null) &#123; result = ((String)result).toUpperCase(); &#125; return result; &#125;&#125; （2） 修改 Spring 配置文件 12&lt;!-- 注册切面：通知 --&gt;&lt;bean id="myAdvice" class="com.huang.aop03.MyMethodInterceptor"/&gt; 异常通知定义异常通知，需要实现 ThrowsAdvice 接口。该接口的主要作用是，在目标方法抛出异常后，根据异常的不同做出相应的处理。当该接口处理完异常后，会简单地将异常再次抛出给目标方法。 不过，这个接口较为特殊，从形式上看，该接口中没有必须要实现的方法。但，这个接口却确实有必须要实现的方法 afterThrowing()。这个方法重载了四种形式。由于使用时，一般只使用其中一种，该接口定义为标识接口（没有方法的接口）。 这四种方法中，常用的形式如下： 1public void afterThrowing(自定义的异常类 e) 这里的参数 e 为，与具体业务相关的用户自定义的异常类对象。容器会根据异常类型的不同，自动选择不同的该方法执行。这些方法的执行是在目标方法执行结束后执行的。 （1） 定义异常类的父类 1234567891011public class UserException extends Exception &#123; public UserException() &#123; super(); &#125; public UserException(String message) &#123; super(message); &#125;&#125; （2） 定义两个异常类的子类 12345678910public class UsernameException extends UserException &#123; public UsernameException() &#123; super(); &#125; public UsernameException(String message) &#123; super(message); &#125;&#125; 1234567891011public class PasswordException extends UserException &#123; public PasswordException() &#123; super(); &#125; public PasswordException(String message) &#123; super(message); &#125;&#125; （3） 定义业务接口。要抛出异常父类 123456//主业务借口public interface ISomeService &#123; //目标方法 boolean login(String username,String password) throws UserException;&#125; （4） 定义目标类 12345678910111213141516171819//目标类public class SomeServiceImpl implements ISomeService &#123; @Override public boolean login(String username, String password) throws UserException &#123; if (!"huang".equals(username)) &#123; throw new UsernameException("用户名输错了"); &#125; if (!"111".equals(password)) &#123; throw new PasswordException("密码输错了"); &#125;// double a = 3 / 0; return true; &#125;&#125; （5） 定义异常通知 123456789101112131415161718192021public class MyThrowsAdvice implements ThrowsAdvice &#123; // 当目标方法抛出UsernameException异常时，执行当前方法 public void afterThrowing(UserException ex) &#123; System.out.println("发生用户名异常 ex = " + ex.getMessage()); &#125; // 当目标方法抛出PasswordException异常时，执行当前方法 public void afterThrowing(PasswordException ex) &#123; System.out.println("发生密码异常 ex = " + ex.getMessage()); &#125; // 当目标方法抛出其它异常时，执行当前方法 public void afterThrowing(Exception ex) &#123; System.out.println("发生异常 ex = " + ex.getMessage()); &#125;&#125; （6） 定义测试类 123456789101112public class MyTest &#123; @Test public void test01() throws UserException &#123; String resource = "com/huang/aop05/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); //serviceProxy为代理对象，而非目标对象 ISomeService service = (ISomeService) ac.getBean("serviceProxy"); service.login("huang", "111"); &#125;&#125; 通知的其它用法给目标方法织入多个切面若要给目标方法织入多个切面，则需要在配置代理对象的切面属性时，设定为 array。 123456&lt;property name="interceptorNames"&gt; &lt;array&gt; &lt;value&gt;myBeforeAdvice&lt;/value&gt; &lt;value&gt;myAfterAdvice&lt;/value&gt; &lt;/array&gt;&lt;/property&gt; 无接口的 CGLIB 代理生成若不存在接口，则 ProxyFactoryBean 会自动采用 CGLIB 方式生成动态代理(有接口使用 JDK 的 Proxy 动态代理)。 1234&lt;bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="target" ref="someService"/&gt; &lt;property name="interceptorNames" value="myAdvice"/&gt;&lt;/bean&gt; 查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。 有接口的 CGLIB 代理生成若存在接口，但又需要使用 CGLIB 生成代理对象，此时，只需要在配置文件中增加一个 proxyTargetClass 属性设置，用于指定强制使用 CGLIB 代理机制。 1&lt;property name="proxyTargetClass" value="true"/&gt; 也可指定 optimize（优化）的值为 true，强制使用 CGLIB 代理机制。 1&lt;property name="optimize" value="true"/&gt; 查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。 顾问 Advisor顾问（Advisor）是 Spring 提供的另一种切面。其可以完成更为复杂的切面织入功能。PointcutAdvisor 是顾问的一种， 可以指定具体的切入点。 顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。PointcutAdvisor 接口有两个较为常用的实现类： NameMatchMethodPointcutAdvisor 名称匹配方法切入点顾问 RegexpMethodPointcutAdvisor 正则表达式匹配方法切入点顾问 名称匹配方法切入点顾问NameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。 （1） 修改配置文件 1234567&lt;!-- 指定切入点：这里匹配的对象是简单方法名 --&gt; &lt;!-- 指定doFirst方法为切入点方法 --&gt; &lt;!-- &lt;property name="mappedName" value="doFirst"/&gt; --&gt; &lt;!-- 指定doFirst、doSecond方法为切入点方法 --&gt; &lt;!-- &lt;property name="mappedNames" value="doFirst,doSecond"/&gt; --&gt; &lt;!-- 指定自定义匹配*ir*方法为切入点方法 --&gt; &lt;property name="mappedNames" value="*ir*"/&gt; 正则表达式方法切入点顾问RegexpMethodPointcutAdvisor，即正则表达式方法顾问。容器可根据正则表达式来设置切入点。注意，与正则表达式进行匹配的对象是接口中的方法名，而非目标类（接口的实现类）的方法名。 （1） 修改配置文件 123456&lt;!-- 这里的正则表达式匹配的对象是全限定性方法名 --&gt; &lt;!-- &lt;property name="pattern" value=".*doFirst"/&gt; --&gt; &lt;!-- &lt;property name="patterns" value=".*doFirst,.*doSecond"/&gt; --&gt; &lt;!-- 包含doS的或doT的方法为切入点方法 --&gt; &lt;!-- &lt;property name="pattern" value=".*doFirst|.*doSecond"/&gt; --&gt; &lt;property name="pattern" value=".*S.*"/&gt; 正则表达式常用的运算符有三个，如下表： 运算符 名称 意义 . 点号 表示任意单个字符 + 加号 表示前一个字符出现一次或者多次 * 星号 表示前一个字符出现0次或者多次 自动代理生成器ProxyFactoryBean 代理工具类存在着如下缺点：（1）一个代理对象只能代理一个 Bean，即如果有两个 Bean 同时都要织入同一个切面，这时，不仅要配置这两个 Bean，即两个目标对象，同时还要配置两个代理对象。（2）在客户类中获取 Bean 时，使用的是代理类的 id，而非我们定义的目标对象 Bean 的 id。我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑。 Spring 提供了自动代理生成器，用于解决 ProxyFactoryBean 的问题。常用的自动代理生成器有两个： 默认 advisor 自动代理生成器 Bean 名称自动代理生成器 注意：自动代理生成器均继承自 Bean 后处理器 BeanPostProcessor。容器中所有 Bean 在初始化时均会自动执行 Bean 后处理器中的方法，故其无需 id 属性。所以自动代理生成器的 Bean 也没有 id 属性，客户类直接使用目标对象 bean 的 id。 自动代理生成器，均是继承自 BeanPostProcessor， Bean 后处理器。查看源码： 默认 Advisor 自动代理生成器DefaultAdvisorAutoProxyCreator 代理的生成方式是，将所有的目标对象与 Advisor 自动结合，生成代理对象。无需给生成器做任何的注入配置。注意，只能与 Advisor 配合使用。 12&lt;!-- 注册自动代理生成器 --&gt;&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt; 缺点：（1）不能选择目标对象（2）不能选择切面类型，切面只能是advisor（3）不能选择advisor，所以advisor均将被作为切面织入到目标方法 Bean 名称自动代理生成器BeanNameAutoProxyCreator 的代理生成方式是，根据 bean 的 id，来为符合相应名称的类生成相应代理对象，且切面既可以是顾问 Advisor 又可以是通知 Advice。 12345&lt;!-- 注册自动代理生成器 --&gt;&lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt; &lt;property name="beanNames" value="someService"/&gt; &lt;property name="interceptorNames" value="myAdvisor"/&gt;&lt;/bean&gt; 缺点：1）若存在多个目标对象，就需要使用多次ProxyFactoryBean来创建多个代理对象，这会使配置文件变得臃肿，不便于管理2）用户真正想调用的是目标对象，而真正可以调用的却是代理对象，这不符合正常的逻辑 AspectJ 对 DAO 的实现对于 AOP 这种编程思想，很多框架都进行了实现。 Spring 就是其中之一， 可以完成面向切面编程。 然而， AspectJ 也实现了 AOP 的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发(在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式)。 AspectJ 简介 AspectJ 是一个面向切面的框架，它扩展了 Java 语言。 AspectJ 定义了 AOP 语法，它有一个专门的编译器用来生成遵守 Java 字节编码规范的 Class 文件。——百度百科《AspectJ》 AspectJ 的通知类型AspectJ 中常用的通知有五种类型： （1）前置通知（2）后置通知（3）环绕通知（4）异常通知（5）最终通知 其中最终通知是指，无论程序执行是否正常，该通知都会执行。类似于 try..catch 中的 finally 代码块。 AspectJ 的切入点表达式AspectJ 除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是： 123456execution ( [modifiers-pattern] 访问权限类型 ret-type-pattern 返回值类型(不可省) [declaring-type-pattern] 全限定性类名 name-pattern(param-pattern) 方法名(参数名) (不可省) [throws-pattern] 抛出异常类型 ) 注意：切入点表达式要匹配的对象就是目标方法的方法名。所以， execution 表达式中明显就是方法的签名。表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号： 符 号 意义 * 0至多个任意字符 .. 1. 用在方法参数中，表示任意多个参数。2. 用在包名后，表示当前及其子类 + 1. 用在类名后，表示当前类及其子类。2. 用在接口后，表示当前接口及其实现类 举例： 12//指定所有包下的 serivce 子包下所有类中的 doSome()方法为切入点execution(* *..service.*.doSome()) 12//指定只有一级包下的 serivce 子包下所有类中的 doSome()方法为切入点execution(* *.service.*.doSome()) AspectJ 基于注解的 AOP 实现AspectJ 提供了以注解方式对于 AOP 的实现。 实现步骤（1） 定义业务接口与实现类 12345678910//主业务接口public interface ISomeService &#123; //主业务方法 void doFirst(); //主业务方法 String doSecond(); //主业务方法 void doThird();&#125; 123456789101112131415161718192021222324//目标类public class SomeServiceImpl implements ISomeService &#123; //目标方法 @Override public void doFirst() &#123; System.out.println("执行doFirst()方法"); &#125; //目标方法 @Override public String doSecond() &#123; System.out.println("执行doSecond()方法"); return "abcde"; &#125; //目标方法 @Override public void doThird() &#123; System.out.println("执行doThird()方法"); System.out.println("执行doThird()方法"); &#125;&#125; （2） 定义切面 POJO 类，并添加@Aspect 注解和通知注解 该类为一个 POJO 类，将作为切面出现。其中定义了若干普通方法，将作为不同的通知方法；在定义的 POJO 类上添加@Aspect 注解，指定当前 POJO 类将作为切面。 1234567891011121314@Aspect // 表示当前类为切面public class MyAspectJ &#123; @Before("execution(* *..ISomeService.doFirst(..))") public void myBefore() &#123; System.out.println("执行前置通知方法"); &#125; @Before("execution(* *..ISomeService.doFirst(..))") public void myBefore(JoinPoint jp) &#123; System.out.println("执行前置通知方法 jp = " + jp); &#125;&#125; （3） 定义 Spring 配置文件 12345678&lt;!-- 注册切面 --&gt;&lt;bean id="myAspectJ" class="com.huang.annotation.MyAspectJ"/&gt;&lt;!-- 注册目标对象 --&gt;&lt;bean id="someService" class="com.huang.annotation.SomeServiceImpl"/&gt;&lt;!-- 注册AspectJ的自动代理 --&gt;&lt;aop:aspectj-autoproxy/&gt; （4） 定义测试类 1234567891011121314 @Test public void test01() &#123; String resource = "com/huang/annotation/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); //serviceProxy为代理对象，而非目标对象 ISomeService service = (ISomeService) ac.getBean("someService"); service.doFirst(); System.out.println("----------------------"); service.doSecond(); System.out.println("----------------------"); service.doThird(); &#125;&#125; @Before 前置通知-增强方法有 JoinPoint 参数在目标方法执行之前执行。被注解为前置通知的方法，可以包含一个 JoinPoint 类型参数。该类型的对象本身就是切入点表达式。通过该参数，可获取切入点表达式、方法签名、目标对象等。 12345678910//前置通知@Before("execution(* *..ISomeService.doFirst(..))")public void myBefore() &#123; System.out.println("执行前置通知方法");&#125;@Before("execution(* *..ISomeService.doFirst(..))")public void myBefore(JoinPoint jp) &#123; System.out.println("执行前置通知方法 jp = " + jp);&#125; 运行结果 @AfterReturning 后置通知-注解有 returning 属性在目标方法执行之后执行。由于是目标方法之后执行，所以可以获取到目标方法的返回值。 该注解的 returning 属性就是用于指定接收方法返回值的变量名的。 12345678910//后置通知@AfterReturning("execution(* *..ISomeService.doSecond(..))")public void myAfterReturning() &#123; System.out.println("执行后置通知方法");&#125;@AfterReturning(value="execution(* *..ISomeService.doSecond(..))",returning="result")public void myAfterReturning(Object result) &#123; System.out.println("执行后置通知方法 result = " + result);&#125; 运行结果 注意：被注解为后置通知的方法，除了可以包含 JoinPoint 参数外，还可以包含用于接收返回值的变量。该变量最好为 Object 类型，因为目标方法的返回值可能是任何类型。 @Around 环绕通知-增强方法有 ProceedingJoinPoint 参数在目标方法执行之前之后执行。被注解为环绕增强的方法要有返回值， Object 类型。 并且方法可以包含一个 ProceedingJoinPoint 类型的参数。接口 ProceedingJoinPoint 其有一个 proceed()方法，用于执行目标方法。若目标方法有返回值，则该方法的返回值就是目标方法的返回值。最后，环绕增强方法将其返回值返回。该增强方法实际是拦截了目标方法的执行。 12345678910111213//环绕通知@Around("execution(* *..ISomeService.doSecond(..))")public Object myAround(ProceedingJoinPoint pjp) throws Throwable&#123; System.out.println("执行环绕通知方法，目标方法执行之前"); //执行目标方法 Object result = pjp.proceed(); System.out.println("执行环绕通知方法，目标方法执行之后"); if (result != null) &#123; result = ((String)result).toUpperCase(); &#125; return result;&#125; 运行结果 @AfterThrowing 异常通知-注解中有 throwing 属性在目标方法抛出异常后执行。 该注解的 throwing 属性用于指定所发生的异常类对象。当然，被注解为异常通知的方法可以包含一个参数 Throwable，参数名称为 throwing 指定的名称，表示发生的异常对象。 在目标类定义一个异常 123456//目标方法@Overridepublic void doThird() &#123; System.out.println("执行doThird()方法" + 3 / 0); System.out.println("执行doThird()方法");&#125; 12345678910111213141516//异常通知@AfterThrowing("execution(* *..ISomeService.doThird(..))")public void myAfetrThrowing() &#123; System.out.println("执行异常通知方法");&#125;//使用切入点，叫 doThirdPointcut()@AfterThrowing(value="doThirdPointcut()",throwing="ex")public void myAfterThrowing(Exception ex) &#123; System.out.println("执行异常通知方法 ex = " + ex.getMessage());&#125;// 定义了一个切入点，叫 doThirdPointcut()@Pointcut("execution(* *..ISomeService.doThird(..))")public void doThirdPointcut() &#123;&#125; 运行结果 @After 最终通知无论目标方法是否抛出异常，该增强均会被执行。 12345//最终通知@After("doThirdPointcut()")public void myAfter() &#123; System.out.println("执行最终通知方法");&#125; 运行结果 @Pointcut 定义切入点当较多的通知增强方法使用相同的 execution 切入点表达式时，编写、维护均较为麻烦。AspectJ 提供了@Pointcut 注解，用于定义 execution 切入点表达式。其用法是，将@Pointcut 注解在一个方法之上，以后所有的 executeion 的 value 属性值均可使用该方法名作为切入点。代表的就是@Pointcut 定义的切入点。这个使用@Pointcute 注解的方法一般使用 private 的标识方法，即没有实际作用的方法。 123// 定义了一个切入点，叫 doThirdPointcut()@Pointcut("execution(* *..ISomeService.doThird(..))")public void doThirdPointcut() &#123;&#125; AspectJ 基于 XML 的 AOP 实现AspectJ 除了提供了基于注解的 AOP 的实现外，还提供了以 XML 方式的实现。切面就是一个 POJO 类，而用于增强的方法就是普通的方法。通过配置文件，将切面中的功能增强织入到了目标类的目标方法中。 实现步骤（1） 定义业务接口与实现类 12345678910//主业务接口public interface ISomeService &#123; //主业务方法 void doFirst(); //主业务方法 String doSecond(); //主业务方法 void doThird();&#125; 123456789101112131415161718192021222324//目标类public class SomeServiceImpl implements ISomeService &#123; //目标方法 @Override public void doFirst() &#123; System.out.println("执行doFirst()方法"); &#125; //目标方法 @Override public String doSecond() &#123; System.out.println("执行doSecond()方法"); return "abcde"; &#125; //目标方法 @Override public void doThird() &#123; System.out.println("执行doThird()方法" + 3 / 0); System.out.println("执行doThird()方法"); &#125;&#125; （2） 定义切面 POJO 类 该类为一个 POJO 类，将作为切面出现。其中定义了若干普通方法，将作为不同的通知方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 表示当前类为切面public class MyAspectJ &#123; //前置通知 public void myBefore() &#123; System.out.println("执行前置通知方法"); &#125; // @Before("execution(* *..ISomeService.doFirst(..))") public void myBefore(JoinPoint jp) &#123; System.out.println("执行前置通知方法 jp = " + jp); &#125; //后置通知 public void myAfterReturning() &#123; System.out.println("执行后置通知方法"); &#125; public void myAfterReturning(Object result) &#123; System.out.println("执行后置通知方法 result = " + result); &#125; //环绕通知 public Object myAround(ProceedingJoinPoint pjp) throws Throwable&#123; System.out.println("执行环绕通知方法，目标方法执行之前"); //执行目标方法 Object result = pjp.proceed(); System.out.println("执行环绕通知方法，目标方法执行之后"); if (result != null) &#123; result = ((String)result).toUpperCase(); &#125; return result; &#125; //异常通知 public void myAfetrThrowing() &#123; System.out.println("执行异常通知方法"); &#125; //使用切入点，叫 doThirdPointcut() public void myAfterThrowing(Exception ex) &#123; System.out.println("执行异常通知方法 ex = " + ex.getMessage()); &#125; //最终通知 public void myAfter() &#123; System.out.println("执行最终通知方法"); &#125; &#125; （3） 注册目标对象与 POJO 切面类 12345&lt;!-- 注册切面 --&gt;&lt;bean id="myAspectJ" class="com.huang.xml.MyAspectJ"/&gt;&lt;!-- 注册目标对象 --&gt;&lt;bean id="someService" class="com.huang.xml.SomeServiceImpl"/&gt; （4） 在容器中定义 AOP 配置 12345678910&lt;!-- AOP配置 --&gt; &lt;aop:config&gt; &lt;aop:aspect ref="myAspectJ"&gt; &lt;aop:pointcut expression="execution(* *..ISomeService.doFirst(..))" id="doFirstPointcut"/&gt; &lt;aop:pointcut expression="execution(* *..ISomeService.doSecond(..))" id="doSecondPointcut"/&gt; &lt;aop:pointcut expression="execution(* *..ISomeService.doThird(..))" id="doThirdPointcut"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 通过其子标签&lt;aop:pointcut/&gt;定义切入点，该标签有两个属性， id 与 expression。分别用于指定该切入点的名称及切入点的值。 expression 的值为 execution 表达式。 子标签&lt;aop:aspect/&gt;定义具体的织入规则：根据不同的通知类型，确定不同的织入时间；将 method 指定的增强方法，按照指定织入时间，织入到切入点指定的目标方法中。 &lt;aop:aspect/&gt;的 ref 属性用于指定使用哪个切面。&lt;aop:aspect/&gt;的子标签是各种不同的通知类型。不同的通知所包含的属性是不同的，但也有共同的属性。 method：指定该通知使用的切面中的增强方法。 pointcut-ref：指定该通知要应用的切入点。 AspectJ 的 6 种通知的 XML 标签如下： &lt;aop:before/&gt;：前置通知 lt;aop:after-returning/&gt;： 后置通知 &lt;aop:around/&gt;：环绕通知 &lt;aop:after-throwing/&gt;：异常通知 &lt;aop:after/&gt;：最终通知 &lt;aop:declare-parents/&gt;：引入通知 （5） 定义测试类 123456789101112@Testpublic void test01() &#123; String resource = "com/huang/xml/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); //serviceProxy为代理对象，而非目标对象 ISomeService service = (ISomeService) ac.getBean("someService"); service.doFirst(); System.out.println("----------------------"); service.doSecond(); System.out.println("----------------------"); service.doThird();&#125; &lt;aop:before/&gt;前置通知123&lt;!-- 前置通知 --&gt; &lt;aop:before method="myBefore" pointcut-ref="doFirstPointcut"/&gt; &lt;aop:before method="myBefore(org.aspectj.lang.JoinPoint)" pointcut-ref="doFirstPointcut"/&gt; 运行结果 &lt;aop:after-returning/&gt;后置通知其 XML 的配置中，有一个属性 returning，指定用于接收目标方法的返回值所使用的变量名。其可作为增强方法的参数出现。 123 &lt;!-- 后置通知 --&gt; &lt;aop:after-returning method="myAfterReturning" pointcut-ref="doSecondPointcut"/&gt;&lt;aop:after-returning method="myAfterReturning(java.lang.Object)" pointcut-ref="doSecondPointcut" returning="result"/&gt; 运行结果 &lt;aop:around/&gt;环绕通知环绕通知的增强方法一般返回类型为 Object，是目标方法的返回值。并且可以包含一个参数 ProceedingJoinPoint，其方法 proceed()可执行目标方法。 12&lt;!-- 环绕通知 --&gt;&lt;aop:around method="myAround" pointcut-ref="doSecondPointcut"/&gt; 运行结果 &lt;aop:after-throwing/&gt;异常通知其 XML 的配置中，有一个属性 throwing，指定用于接收目标方法所抛出异常的变量名。其可作为增强方法的参数出现，该参数为 Throwable 类型。 12&lt;!-- 异常通知 --&gt;&lt;aop:after-throwing method="myAfterThrowing(java.lang.Exception)" pointcut-ref="doThirdPointcut" throwing="ex"/&gt; 运行结果 &lt;aop:after/&gt;最终通知12&lt;!-- 最终通知 --&gt;&lt;aop:after method="myAfter" pointcut-ref="doThirdPointcut"/&gt; 运行结果]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring与IoC]]></title>
    <url>%2F2019%2F08%2F06%2FSpring%E4%B8%8EIoC%2F</url>
    <content type="text"><![CDATA[Spring是一个容器，用于降低代码间的耦合度，根据不同的代码(主业务逻辑、系统级服务)采用IoC和AOP两种进行的业务逻辑。 主业务逻辑与系统级业务逻辑的特点：主业务代码间逻辑联系紧密，有具体的专业业务应用场景，复用性相对较低；系统级业务相对功能独立，没有具体的专业业务应用场景，主要是为主业务提供系统级服务，如日志、安全、事务等，复用性强。 降低耦合度的方式分为了两类： IoC 与 AOP。 IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理自动“注入”。而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成“织入”。 Spring 体系结构 Spring 由 20 多个模块组成，它们可以分为数据访问/集成（Data Access/Integration）、Web、面向切面编程（AOP, Aspects）、 应用服务器设备管理（Instrumentation）、消息发送（Messaging）、 核心容器（Core Container）和测试（Test）。 Spring 的特点1. 非侵入式所谓非侵入式是指， Spring 框架的 API 不会在业务逻辑上出现， 即业务逻辑是 POJO(Plain Old Java Object)。由于业务逻辑中没有 Spring 的 API，所以业务逻辑可以从 Spring 框架快速的移植到其他框架，即与环境无关。 2. 容器Spring 作为一个容器，可以管理对象的生命周期、对象与对象之间的依赖关系。可以通过配置文件，来定义对象，以及设置与其他对象的依赖关系。(简单来说是一个xml配置文件) 3. IoC控制反转（IoC，Inversion of Control）， 即创建被调用者的实例不是由调用者完成，而是由 Spring 容器完成，并注入调用者。当应用了 IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。即，不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。 4. AOP面向切面编程（AOP， Aspect Orient Programming），是一种编程思想，是面向对象编程 OOP 的补充。 很多框架都实现了对 AOP 编程思想的实现。 Spring 也提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如日志和事务管理）进行开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或事务支持。 Spring 与 IoC控制反转（IoC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。当前比较流行的 IoC 实现方式有两种：依赖注入和依赖查找。 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。 依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。 Spring 程序开发 定义接口与实体类 123public interface ISomeService &#123; void doSome();&#125; 1234567891011public class SomeServiceImpl implements ISomeService &#123; public SomeServiceImpl() &#123; System.out.println("执行无参构造器"); &#125; @Override public void doSome() &#123; System.out.println("执行doSome()方法"); &#125;&#125; 创建 Spring 配置文件 Spring 配置文件的文件名可以随意，但 Spring 建议的名称为 applicationContext.xml。 1&lt;bean id="myService" class="com.huang.service.SomeServiceImpl"/&gt; &lt;bean /&gt;： 用于定义一个实例对象。 一个实例对应一个 bean 元素。 id：该属性是 Bean 实例的唯一标识，程序通过 id 属性访问 Bean， Bean 与 Bean 间的依赖关系也是通过 id 属性关联的。 class：指定该 Bean 所属的类， 定义测试类 （1） ApplicationContext 接口容器ApplicationContext 用于加载 Spring 的配置文件，在程序中充当“容器”的角色。其实现类有两个：ClassPathXmlApplicationContext 和 FileSystemXmlApplicationContext 123456789@Testpublic void test02() &#123; // 创建容器对象，加载Spring配置文件 // 从类路径下查找配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); //从容器中获取对象 ISomeService service = (ISomeService) ac.getBean("myService"); service.doSome();&#125; 123456789@Testpublic void test03() &#123; // 创建容器对象，加载Spring配置文件 // 从项目的根下查找配置文件 ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml"); //从容器中获取对象 ISomeService service = (ISomeService) ac.getBean("myService"); service.doSome();&#125; 123456789@Testpublic void test04() &#123; //创建容器对象，加载Spring配置文件 //从当前文件系统的D盘根目录下查找配置文件 ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml"); //从容器中获取对象 ISomeService service = (ISomeService) ac.getBean("myService"); service.doSome();&#125; ClassPathXmlApplicationContext 和 FileSystemXmlApplicationContext 的区别 （2） BeanFactory 接口容器 BeanFactory 接口是 ApplicationContext 接口的父类。 123456@Testpublic void test05() &#123; BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml")); ISomeService service = (ISomeService) bf.getBean("myService"); service.doSome();&#125; Resouce 是一个接口，其具有两个实现类： ClassPathResource：指定类路径下的资源文件 FileSystemResource：指定项目根路径或本地磁盘路径下的资源文件。 注意：ApplicationContext与BeanFactory容器的区别： 这两上容器对于其中Bean的创建时机不同： ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建缺点：占用系统资源较多（内存、CPU等）优点：响应速度快 BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建缺点：相对来说，响应速度慢优点：占用系统资源较少 Bean 的装配Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。 默认装配方式代码通过 getBean()方式从容器获取指定的 Bean 实例，容器默认调用 Bean 类的无参构造器，创建空值的实例对象。 动态工厂 Bean有些时候，项目中需要通过工厂类来创建 Bean 实例，使用工厂模式创建 Bean 实例，会使工厂类与要创建的 Bean 类耦合到一起。 123456public class ServiceFactory &#123; public ISomeService getSomeService() &#123; return new SomeServiceImpl(); &#125;&#125; 12345&lt;!-- 注册动态工厂 --&gt;&lt;bean id="factory" class="com.huang.ba02.ServiceFactory"/&gt;&lt;!-- 注册Service:动态工厂Bean --&gt;&lt;bean id="myService" factory-bean="factory" factory-method="getSomeService"/&gt; 12345678@Testpublic void test01() &#123; // 创建容器对象，加载Spring配置文件 String resource = "com/huang/ba02/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); ISomeService service = (ISomeService) ac.getBean("myService"); service.doSome();&#125; 静态工厂 Bean静态工厂无需工厂实例，所以不再需要定义静态工厂&lt;bean/&gt;。 而对于工厂所要创建的 Bean，其不是由自己的类创建的，所以无需指定自己的类。但其是由工厂类创建的，所以需要指定所用工厂类。故 class 属性指定的是工厂类而非自己的类。 容器中 Bean 的作用域当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。 singleton： 单态模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。 默认为单态的。 prototype： 原型模式。即每次使用 getBean 方法获取的同一个&lt;bean /&amp;gtl的实例都是一个新的实例。 request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。 session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。 global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session是等同的。 注意： 对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。 对于 scope 为 singleton 的单例模式， 该 Bean 是在容器被创建时即被装配好了。 对于 scope 为 prototype 的原型模式， Bean 实例是在代码中使用该 Bean 实例时才进行装配的。 Bean 后处理器Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。 123//该方法会在目标 Bean 初始化完毕之前由容器自动调用。public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException 1234//该方法会在目标 Bean 初始化完毕之后由容器自动调用。public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean被初始化完毕。 它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。 （1） 定义接口 12345public interface ISomeService &#123; //主业务方法 String doSome(); String doOther();&#125; （2） 定义目标类 12345678910111213141516171819public class SomeServiceImpl implements ISomeService &#123; private int a; //目标方法 @Override public String doSome() &#123; System.out.println("执行doSome()方法"); return "abcde"; &#125; //目标方法 @Override public String doOther() &#123; System.out.println("执行doOther()方法"); return "fghij"; &#125; &#125; （3） 使用动态代理进行增强 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyBeanPostProcessor implements BeanPostProcessor &#123; // bean：表示当前正在进行初始化的Bean对象 // beanName：表示当前正在进行初始化的Bean对象的id @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("执行------before------()方法"); return bean; &#125; @Override public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException &#123; System.out.println("执行------after------()方法"); if ("myService".equals(beanName)) &#123; Object obj = Proxy.newProxyInstance(bean.getClass() .getClassLoader(),bean.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object invoke = method.invoke(bean, args); if ("doSome".equals(method.getName())) &#123; return ((String) invoke).toUpperCase(); &#125; return invoke; &#125; &#125;); return obj; &#125; return bean; &#125;&#125; （4） 创建 Spring 配置文件 1234&lt;!-- 注册Service --&gt; &lt;bean id="myService" class="com.huang.ba05.SomeServiceImpl"/&gt; &lt;bean class="com.huang.ba05.MyBeanPostProcessor"/&gt; （5） 定义测试类 123456789@Testpublic void test01() &#123; // 创建容器对象，加载Spring配置文件 String resource = "com/huang/ba05/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); ISomeService service = (ISomeService) ac.getBean("myService"); System.out.println(service.doSome()); System.out.println(service.doOther());&#125; （6） 运行结果 定制 Bean 的生命始末可以为 Bean 定制初始化后的生命行为，也可以为 Bean 定制销毁前的生命行为。 注意，若要看到 Bean 的 destroy-method 的执行结果，需要满足两个条件：（1） Bean 为 singleton，即单例（2）要确保容器关闭。接口 ApplicationContext 没有 close()方法，但其实现类有。所以，可以将 ApplicationContext 强转为其实现类对象，或直接创建的就是实现类对象。 Bean 的生命周期Step1：调用无参构造器，创建实例对象。Step2：调用参数的 setter，为属性注入值。Step3：若 Bean 实现了 BeanNameAware 接口，则会执行接口方法 setBeanName(String beanId)，使 Bean 类可以获取其在容器中的 id 名称。Step4：若 Bean 实现了 BeanFactoryAware 接口，则执行接口方法 setBeanFactory(BeanFactory factory)，使 Bean 类可以获取到 BeanFactory 对象。Step5：若定义并注册了 Bean 后处理器 BeanPostProcessor，则执行接口方法 postProcessBeforeInitialization()。Step6：若 Bean 实现了 InitializingBean 接口，则执行接口方法 afterPropertiesSet ()。 该方法在 Bean 的所有属性的 set 方法执行完毕后执行，是 Bean 初始化结束的标志，即 Bean 实例化结束。Step7：若设置了 init-method 方法，则执行。Step8：若定义并注册了 Bean 后处理器 BeanPostProcessor ， 则执行接口方法 postProcessAfterInitialization()。Step9：执行业务方法。Step10：若 Bean 实现了 DisposableBean 接口，则执行接口方法 destroy()。Step11：若设置了 destroy-method 方法，则执行。 &lt;bean/&gt;标签的 id 属性与 name一般情况下，命名&lt;bean/&gt;使用 id 属性，而不使用 name 属性。在没有 id 属性的情况下，name 属性与 id 属性作用是相同的。但，当&lt;bean/&gt;中含有一些特殊字符时，就需要使用 name属性了。 命名规范： id：必须以字母开头，可以包含字母、数字、下划线、连字符、句号、冒号。 name：属性值则可以包含各种字符。 基于 XML 的 DI注入分类Bean 实例在调用无参构造器创建了空值对象后，就要对 Bean 对象的属性进行初始化。初始化是由容器自动完成的， 称为注入。根据注入方式的不同， 常用的有两类： 设值注入、构造注入（接口注入几乎不用）。 设值注入设值注入是指，通过 setter 方法传入被调用者的实例(底层通过调用setter方法将值注入)。这种注入方式简单、直观，因而在 Spring 的依赖注入中大量使用。 （1） 定义实体类 1234public class School &#123; private String name;&#125; 123456789public class Student &#123; private String name; private int age; private School school; public void setName(String name) &#123; System.out.println("执行setName()"); this.name = name; &#125;&#125; （2） 创建 Spring 配置文件 1234567891011&lt;!-- 注册School --&gt;&lt;bean id="mySchool" class="com.huang.di01.School"&gt; &lt;property name="name" value="清华大学"/&gt;&lt;/bean&gt;&lt;!-- 注册Student --&gt;&lt;bean id="myStudent" class="com.huang.di01.Student"&gt; &lt;property name="name" value="张三"/&gt; &lt;property name="age" value="22"/&gt; &lt;property name="school" ref="mySchool"/&gt;&lt;/bean&gt; （3） 定义测试类 1234567@Testpublic void test01() &#123; String resource = "com/huang/di01/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); Student student = (Student) ac.getBean("myStudent"); System.out.println(student);&#125; （4） 运行结果 当指定 bean 的某属性值为另一 bean 的实例时，通过 ref 指定它们间的引用关系。 ref 的值必须为某 bean 的 id 值(域属性(引用类型)的注入需要使用 ref 属性，字符串和基本数据类型使用 value)。对于其它 Bean 对象的引用，除了&lt;bean/&gt;标签的 ref 属性外，还可以使用&lt;ref/&gt;标签。 构造注入构造注入是指，在构造调用者实例的同时，完成被调用者的实例化。即，使用构造器设置依赖关系(底层调用的是构造器)。 （1） 修改实现类 （2） 修改 Spring 配置文件 &lt;constructor-arg /&gt;标签中用于指定参数的属性有： name：指定参数名称。 index：指明该参数对应着构造器的第几个参数，从 0 开始。不过，该属性不要也行，但要注意，若参数类型相同，或之间有包含关系，则需要保证赋值顺序要与构造器中的参数顺序一致。 命名空间注入对于设值注入与构造注入，在配置文件中，除了使用&lt;property/&gt;或&lt;constructor-arg/&gt;标签外，还可使用命名空间注入的方式，让注入的值以&lt;bean/&gt;标签属性的方式出现。根据注入实现方式的不同，分为： p 命名空间注入：采用设值注入方式，故需要有相应的 setterc 命名空间注入：采用构造注入方式，故需要有相应的构造器 p 命名空间设值注入 c 命名空间构造注入 集合属性注入（1） 定义实体类 123456789public class Some &#123; private School[] schools; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String, Object&gt; myMap; private Properties myPros;&#125; （2） 修改 Spring 配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!-- 注册School --&gt;&lt;bean id="mySchool" class="com.huang.di05.School"&gt; &lt;property name="name" value="清华大学"/&gt;&lt;/bean&gt;&lt;bean id="mySchool2" class="com.huang.di05.School"&gt; &lt;property name="name" value="北京大学"/&gt;&lt;/bean&gt;&lt;!-- 注册Student --&gt;&lt;bean id="mySome" class="com.huang.di05.Some"&gt; &lt;property name="schools"&gt; &lt;array&gt; &lt;ref bean="mySchool"/&gt; &lt;ref bean="mySchool2"/&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 为数组注入值 --&gt; &lt;property name="myStrs"&gt; &lt;array&gt; &lt;value&gt;中国&lt;/value&gt; &lt;value&gt;广东&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 为 List 注入值 --&gt; &lt;property name="myList"&gt; &lt;list&gt; &lt;value&gt;广州&lt;/value&gt; &lt;value&gt;天河&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 为 Set 注入值 --&gt; &lt;property name="mySet"&gt; &lt;set&gt; &lt;value&gt;现代学院&lt;/value&gt; &lt;value&gt;信息工程系&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 为 Map 注入值 --&gt; &lt;property name="myMap"&gt; &lt;map&gt; &lt;entry key="mobile" value="1234567"/&gt; &lt;entry key="QQ" value="7654321"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 为 Properties 注入值 --&gt; &lt;property name="myPros"&gt; &lt;props&gt; &lt;prop key="education"&gt;大学&lt;/prop&gt; &lt;prop key="gender"&gt;男&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; Spring 配置文件的简单赋值 对于域属性的自动注入对于域属性的注入，也可不在配置文件中显示的注入。可以通过为&lt;bean/&gt;标签设置 autowire 属性值，为域属性进行隐式自动注入。根据自动注入判断标准的不同，可以分为两种： byName：根据名称自动注入 byType：根据类型自动注入 （1） byName 方式自动注入 当配置文件中被调用者 Bean 的 id 值与代码中调用者 Bean 类的属性名相同时，可使用 byName 方式，让容器自动将被调用者 Bean 注入给调用者 Bean。容器是通过调用者的 Bean 类的属性名与配置文件的被调用者 bean 的 id 进行比较而实现自动注入的。 （2） byType 方式自动注入 使用 byType 方式自动注入，要求：配置文件中被调用者 bean 的 class 属性指定的类，要与代码中调用者 Bean 类的某域属性类型同源。即要么相同，要么有 is-a 关系（子类，或是实现类）。 使用 SPEL 注入SPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。 用法： &lt;bean id=“abc” value=“#{…}”/&gt;。 其它用法：（1） &lt;property name=“school” value=“#{mySchool}”/&gt;：引用另一个 bean。指定 school 的值为另一个 Bean 实例 mySchool。（2） &lt;property name=“schoolName” value=“#{mySchool.name.toUpperCase()}”/&gt;：使用指定属性，并使用其方法。指定 schoolName 的值为 mySchool 的 name 属性值，并将其字母均转换为大写字母（toUpperCase()方法）。 使用内部 Bean 注入若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。 使用同类抽象 Bean 注入当若干Bean实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象Bean，以简化配置文件。 抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。 使用异类抽象 Bean 注入当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。 为应用指定多个 Spring 配置文件在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。 （1）平等关系的配置文件将配置文件分解为地位平等的多个配置文件，并将所有配置文件的路径定义为一个 String 数组，将其作为容器初始化参数出现。 其将与可变参的容器构造器匹配。 （ 2）包含关系的配置文件各配置文件中有一个总文件，总配置文件将各其它子文件通过&lt;import/&gt;引入。在 Java 代码中只需要使用总配置文件对容器进行初始化即可。 Spring 配置文件中也可使用通配符*。但，此时要求总配置文件不要和子配置文件命名格式相同，否则将出现循环递归包含。 基于注解的 DI (底层使用AOP)对于 DI 使用注解，将不再需要在 Spring 配置文件中声明 Bean 实例。 定义 Bean@Component需要在类上使用注解@Component，该注解的 value 属性用于指定该 bean 的 id 值。 （1） 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041// @Scope("prototype") // 默认也是singleton@Component("myStudent")public class Student &#123; @Value("张三") private String name; @Value("23") private int age; // @Resource(name="mySchool") // byName方式的注解式注入 @Resource // byType方式的注解式注入 private School school; // 对象属性，域属性 public void setName(String name) &#123; System.out.println("执行setName()"); this.name = name; &#125; public void setAge(int age) &#123; System.out.println("执行setAge()"); this.age = age; &#125; public void setSchool(School school) &#123; this.school = school; &#125; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + ", school=" + school + "]"; &#125; @PostConstruct public void initAfter() &#123; System.out.println("当前Bean初始化刚完毕"); &#125; @PreDestroy public void preDestroy() &#123; System.out.println("当前Bean即将被销毁"); &#125; &#125; 1234567891011121314@Component("mySchool") // 组件，表示当前类被Spring容器所管理public class School &#123; @Value("清华大学") private String name; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "School [name=" + name + "]"; &#125;&#125; （2） Spring 配置文件 12345678 &lt;!-- 扫描指定包 --&gt;&lt;context:component-scan base-package="com.huang.di01"/&gt;&lt;!-- 扫描com.huang这个包及其子包 --&gt;&lt;!-- &lt;context:component-scan base-package="com.huang"/&gt; --&gt;&lt;!-- 扫描com.huang这个包的子包 --&gt;&lt;!-- &lt;context:component-scan base-package="com.huang.*"/&gt; --&gt; 注意：要在文件头部加上约束 与@Component注解功能相同，但意义不同的注解还有三个：（1）@Repository：注解在Dao实现类上（2）@Service：注解在Service实现类上（3）@Controller：注解在SpringMVC的处理器上 之所以创建这三个功能与@Component 等效的注解，是为了以后对其进行功能上的扩展，使它们不再等效。 Bean 的作用域@Scope要在类上使用注解@Scope，其 value 属性用于指定作用域。默认为 singleton。 基本类型属性注入@Value需要在属性上使用注解@Value，该注解的 value 属性用于指定要注入的值。 按类型注入域属性@Autowired需要在域属性上使用注解@Autowired，该注解默认使用按类型自动装配 Bean 的方式。 按名称注入域属性@Autowired 与@Qualifier需要在域属性上联合使用注解@Autowired 与@Qualifier。 @Qualifier 的 value 属性用于指定要匹配的 Bean 的 id 值。 注意：使用@Value、@Autowired、@Autowired 与@Qualifier注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。 @Autowired 还有一个属性 required，默认值为 true，表示当匹配失败后，会终止程序运行。若将其值设置为 false，则匹配失败，将被忽略，未匹配的属性值为 null。 域属性注解@Resource@Resource 注解既可以按名称匹配 Bean，也可以按类型匹配 Bean。 使用该注解，要求 JDK 必须是 6 及以上版本。 Bean 的生命始末@PostConstruct 与@PreDestroy在方法上使用@PostConstruct，与原来的 init-method 等效。在方法上使用@PreDestroy，与 destroy-method 等效。 使用 JavaConfig 进行配置JavaConfig，是在 Spring 3.0 开始从一个独立的项目并入到 Spring 中的。 JavaConfig 可以看成一个用于完成 Bean 装配的 Spring 配置文件，即 Spring 容器， 只不过该容器不是 XML 文件，而是由程序员使用 Java 自己编写的 Java 类(表示当前类充当 Spring 容器，即所有的 Bean 将由这个类来创建)。 （1） byType 方式的域属性自动注入 （2） byName 方式的域属性自动注入 使用 Spring 的 JUnit4 测试 Spring使用 Spring 的 JUnit4 对 Spring 代码进行测试，将不再需要在程序的代码中直接写出创建 Spring 容器，以及从 Spring 容器中通过 getBean()获取对象。 （1） 定义 Spring 配置文件 （2）定义测试类 注解与 XML 共同使用注解的好处是，配置方便，直观。但其弊端也显而易见：以硬编码的方式写入到了 Java 代码中，其修改是需要重新编译代码的。 XML 配置方式的最大好处是，对其所做修改，无需编译代码，只需重启服务器即可将新的配置加载。 若注解与 XML 同用， XML 的优先级要高于注解。这样做的好处是，需要对某个 Bean 做修改，只需修改配置文件即可。当然，此时， Bean 类要有 setter 或构造器。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis注解式开发]]></title>
    <url>%2F2019%2F08%2F04%2FMyBatis%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[注解的基础知识MyBatis 的注解，主要是用于替换映射文件。而映射文件中无非存放着增、删、改、查的 SQL 映射标签。所以， MyBatis 注解，就是要替换映射文件中的 SQL 标签。 MyBatis 官方文档中指出，若要真正想发挥 MyBatis 功能，还是要用映射文件。即 MyBatis 官方并不建议通过注解方式来使用 MyBatis。 注解的基础语法 注解后是没有分号的。 注解首字母是大写的，因为注解与类、接口是同一级别的。一个注解，后台对应着。一个@interface 类。 在同一语法单元上，同一注解只能使用一次。 在注解与语法单元之间可以隔若干空行、注释等非代码内容。 注解的注解 打开@Deprecated 源码，看到其定义上还有三个注解： @Documented、 @Retention、 @Target。这三个注解的意义是： @Target： 用于指定该注解可以标注的语法类型。 CONSTRUCTOR（构造器）、LOCAL_VARIABLE（局部变量）、 METHOD（方法）、 FIELD（属性）、 PACKAGE（包）、 PARAMETER（参数）、 TYPE（类型）。 注意：对于 TYPE 常量，其意义有两个：一是指该注解可以用在类、接口、枚举等类上；二是指该注解可以作为其它注解的属性值，例如@Result、 @InterceptorRef。 @Documented： 用于指定该注解定义时的注释信息能否显示在 javaAPI 说明文档上。 没有添加的话，使用 javadoc 生成 API 文档时就不会该注解的信息添加到文档。 @RetentionPolicy： 这是一个 enum 类型， 共有三个值：SOURCE,CLASS 和 RUNTIME。 SOURCE： 代表这个 Annotation 类型的信息只会保留在程序源码里，源码如果经过了编译之后， Annotation 的数据就会消失， 并不会保留在编译好的.class 文件中。 ClASS： 代表这个 Annotation 类型的信息除了保留在程序源码里外， 同时也会保留在编译好的.class 文件里。但在执行时，并不会把这一些信息加载到虚拟机(JVM)中去。这是Retention 的默认值。 RUNTIME： 表示在源码、编译好的.class 文件中保留信息， 同时在执行时还会把这些信息加载到 JVM 中。 举例：@Override 中的 Retention 值为 SOURCE， 编译成功了就不要这一些检查的信息。相反@Deprecated 中 Retention 的值为 RUNTIME， 表示除了在编译时会警告我们使用了哪个被 Deprecated 的方法， 在执行的时候也可以查出该方法是否被 Deprecated。 注解的属性 数组问题该属性在源码定义时被声明为数组，但在具体使用时却只要赋予一个值，此时无需将该值再定义为一个数组后赋给该属性。直接将该值赋给该属性即可。例如，对于声明为字符串数组 String[]的 value 属性，可以将字符串 String 直接赋给该 value。 默认值问题若某属性在注解定义时声明了其默认值，则在注解使用时，可以不为其指定属性值。注解会自动使用其默认值。 value 属性问题若注解在使用时只需使用其 value 属性，其它属性要么有默认值，要么该注解只声明了一个 value 属性，此时，在注解使用时 value 属性名称可省略，而直接在注解的括号中写出该 value 属性的值。 在注解里面，对于数组，如果数组只有一个元素，{}可以省略不写；注解里面只用到一个属性，value可以省略不写 无属性问题有些注解在定义时，是没有属性的，如@Deprecated、 @Overide 都是没有属性声明的，那么在使用时只需给出注解名称即可。 MyBatis注解@Insert其 value 属性用于指定要执行的 insert 语句。 @SelectKey用于替换 XML 中的&lt;selectKey/&gt;标签，用于返回新插入数据的 id 值 1@SelectKey(statement="select @@identity", resultType=int.class, keyProperty="id", before=false) statement：获取新插入记录主键值的 SQL 语句 keyProperty：获取的该主键值返回后初始化对象的哪个属性 resultType：返回值类型 before：指定主键的生成相对于 insert 语句的执行先后顺序，该属性不能省略 @Delete其 value 属性用于指定要执行的 delete 语句。 @Update其 value 属性用于指定要执行的 update 语句。 @Select其 value 属性用于指定要执行的 select 语句。 总结 由于 MyBatis 注解替换的是映射文件，所以可以删除映射文件。 由于没有了映射文件，所以主配置文件中不能使用&lt;mapper/&gt;注册 mapper 的位置了。需要使用&lt;package/&gt;标签。 1234&lt;!-- 指定映射mapper --&gt;&lt;mappers&gt; &lt;package name="com.huang.dao"/&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis查询缓存]]></title>
    <url>%2F2019%2F08%2F03%2FMyBatis%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。 MyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。 一级查询缓存MyBatis 一级查询缓存是基于 org.apache.ibatis.cache.impl.PerpetualCache 类的 HashMap本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。 当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 myBatis 默认一级查询缓存是开启状态，且不能关闭。 一级查询缓存的存在性证明（1） 测试类 123456789// 证明一级缓存是存在的@Testpublic void test01() &#123; Student student = dao.selectStudentById(4); System.out.println(student); Student student2 = dao.selectStudentById(4); System.out.println(student2);&#125; （2） 查看控制台 总结： 缓存的底层实现是一个Map，Map的value是查询结果 Map的key，即查询依据，使用的ORM构架不同，查询依据是不同的。 MyBatis的查询依据是：Sql的id + SQL语句 Hibernate的查询依据是：查询结果对象的id 从缓存读取数据的依据是 Sql 的 id一级缓存缓存的是相同 Sql 映射 id 的查询结果，而非相同 Sql 语句的查询结果。 因为 myBatis 内部对于查询缓存，无论是一级查询缓存还是二级查询缓存， 其底层均使用一个 HashMap 实现： key 为 Sql 的 id 相关内容， value 为从数据库中查询出的结果。 （1） 映射文件 这两个 SQL 映射除了映射 id (selectStudentById、selectStudentById2)不同，其它均相同，即查询结果肯定是相同的。 1234567891011&lt;select id="selectStudentById" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;xxx&#125;&lt;/select&gt;&lt;select id="selectStudentById2" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;xxx&#125;&lt;/select&gt; （2） Dao 接口 12345public interface IStudentDao &#123; Student selectStudentById(int id); Student selectStudentById2(int id);&#125; （3） 测试类 1234567public void test02() &#123; Student student = dao.selectStudentById(1); System.out.println(student); Student student2 = dao.selectStudentById2(1); System.out.println(student2);&#125; （4） 查看控制台 增删改对一级查询缓存的影响增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。 （1） 修改测试类 123456789101112131415 // 证明增删改操作的执行，均会清空一级缓存 @Test public void test03() &#123; //第一次查询 Student student = dao.selectStudentById(2); System.out.println(student); // 增删改操作都会清空一级缓存，无论是否提交 dao.insertStudent(new Student("赵六", 26, 96.5));// sqlSession.commit(); //第二次查询 Student student2 = dao.selectStudentById(2); System.out.println(student2); &#125; （2） 查看控制台 内置二级查询缓存myBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper 查询数据存放在同一个缓存区域。 不同 namespace 下的数据互不干扰。无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。 使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以， 二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享， Hibernate 中的缓存就是为了共享，但 MyBaits 的不是），而是为了延长该查询结果的保存时间，提高系统性能。 myBatis 内置的二级缓存为 org.apache.ibatis.cache.impl.PerpetualCache。 二级缓存用法（1）实体序列化 要求查询结果所涉及到的实体类要实现 java.io.Serializable 接口。若该实体类存在父类，或其具有域属性，则父类与域属性类也要实现序列化接口。 1234567public class Student implements Serializable&#123; private Integer id; private String name; private int age; private double score;&#125; （2）mapper 映射中添加&lt;cache/&gt;标签 12345678910111213141516 &lt;!-- 二级缓存的配置 --&gt;&lt;cache eviction="FIFO" flushInterval="10800000" readOnly="true" size="512"/&gt;&lt;insert id="insertStudent" flushCache="false"&gt; insert into student(name,age,score) values(#&#123;name&#125;, #&#123;age&#125;, #&#123;score&#125;)&lt;/insert&gt;&lt;!-- useCache="false"对当前Sql的二级缓存的局部关闭 --&gt;&lt;select id="selectStudentById" useCache="false" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;xxx&#125;&lt;/select&gt;&lt;select id="selectStudentById2" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;xxx&#125;&lt;/select&gt; （3）二级缓存的配置 为&lt;cache/&gt;标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。若不指定设置，则均保持默认值。 12&lt;cache eviction="FIFO" flushInterval="10800000" readOnly="true" size="512"/&gt; 二级缓存的配置说明： eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有： FIFO： First In First Out， 先进先出 LRU： Least Recently Used，未被使用时间最长的 flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。 readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。 size：二级缓存中可以存放的最多对象个数。默认为 1024 个。 二级缓存的关闭二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。 （1） 全局关闭 所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。全局开关设置在主配置文件的全局设置&lt;settings/&gt;中，该属性为 cacheEnabled，设置为 false，则关闭；设置为 true，则开启， 默认值为 true。 即二级缓存默认是开启的。 1234&lt;!-- 关闭二级缓存 --&gt;&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; （2） 局部关闭 所谓局部关闭是指，整个应用的二级缓存是开启的，但只是针对于某&lt;select/&gt;查询，不使用二级缓存。此时可以单独只关闭该&lt;select/&gt;标签的二级缓存。 在该要关闭二级缓存的&lt;select/&gt;标签中，将其属性 useCache 设置为 false，即可关闭该查询的二级缓存。 该属性默认为 true，即每个&lt;select/&gt;查询的二级缓存默认是开启的。 1234&lt;!-- useCache="false"对当前Sql的二级缓存的局部关闭 --&gt;&lt;select id="selectStudentById" useCache="false" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;xxx&#125;&lt;/select&gt; 二级缓存的使用原则1. 只能在一个命名空间下使用二级缓存由于二级缓存中的数据是基于 namespace 的，即不同 namespace 中的数据互不干扰。在多个 namespace 中若均存在对同一个表的操作，那么这多个 namespace 中的数据可能就会出现不一致现象。 2. 在单表上使用二级缓存如果一个表与其它表有关联关系，那么就非常有可能存在多个 namespace 对同一数据的操作。而不同 namespace 中的数据互不干扰，所以有可能出现这多个 namespace 中的数据不一致现象。 3. 查询多于修改时使用二级缓存在查询操作远远多于增删改操作的情况下可以使用二级缓存。因为任何增删改操作都将刷新二级缓存，对二级缓存的频繁刷新将降低系统性能。 ehcache二级查询缓存mybatis 的特长是 SQL 操作，缓存数据管理不是其特长，为了提高缓存的性能， myBatis 允许使用第三方缓存产品。 ehCache 就是其中的一种。 项目： cache-secondLevel-ehcache。 注意：使用 ehcache 二级缓存，实体类无需实现序列化接口。 ehcache二级查询缓存配置说明&lt;diskStore/&gt;标签12&lt;!-- 指定一个文件目录，当内存空间不够，需要将二级缓存中数据写到硬盘上时，会写到这个指定目录中。其值一般为 java.io.tmpdir， 表示当前系统的默认文件临时目录。 --&gt; &lt;diskStore path="java.io.tmpdir"/&gt; &lt;defaultCache/&gt;标签12345678910&lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" maxElementsOnDisk="10000000" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;persistence strategy="localTempSwap"/&gt;&lt;/defaultCache&gt; 设定缓存的默认属性数据： maxElementsInMemory： 指定该内存缓存区可以存放缓存对象的最多个数。 eternal： 设定缓存对象是否不会过期。若设为 true，表示对象永远不会过期，此时会忽略 timeToIdleSeconds 与 timeToLiveSeconds 属性。默认值为 false。 timeToIdleSeconds： 设定允许对象处于空闲状态的最长时间，以秒为单位。当对象自从最近一次被访问后，若处于空闲状态的时间超过了 timeToIdleSeconds 设定的值，这个对象就会过期。当对象过期， EHCache 就会将它从缓存中清除。 设置值为 0，则对象可以无限期地处于空闲状态。 timeToLiveSeconds： 设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存后，若处于缓存中的时间超过了 timeToLiveSeconds 设定的值，这个对象就会过期。当对象过期， EHCache 就会将它从缓存中清除。 设置值为 0，则对象可以无限期地存在于缓存中。 注意，只有 timeToLiveSeconds≥ timeToIdleSeconds，才有意义。 overflowToDisk： 设定为 true，表示当缓存对象达到了 maxElementsInMemory 界限，会将溢出的对象写到元素指定的硬盘目录缓存中。 maxElementsOnDisk： 指定硬盘缓存区可以存放缓存对象的最多个数。 diskPersistent： 指定当程序结束时，硬盘缓存区中的缓存对象是否做持久化。 diskExpiryThreadIntervalSeconds： 指定硬盘中缓存对象的失效时间间隔。 memoryStoreEvictionPolicy： 如果内存缓存区超过限制， 选择移向硬盘缓存区中的对象时使用的策略。 支持三种策略： FIFO： First In First Out， 先进先出 LFU： Less Frequently Used， 最少使用 LRU： Least Recently Used， 最近最少使用 启用 ehcache 缓存机制在映射文件的 mapper 中的&lt;cache/&gt;中通过 type 指定缓存机制为 Ehcache 缓存。默认为 myBatis 内置的二级缓存 org.apache.ibatis.cache.impl.PerpetualCache。 123&lt;cache type="org.mybatis.caches.ehcache.EhcacheCache"&gt; &lt;property name="timeToIdleSeconds" value="60"/&gt;&lt;/cache&gt; 注意：&lt;cache&gt;属性值的优先级高于 ehcache.xml 中的属性值。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis关联关系查询]]></title>
    <url>%2F2019%2F08%2F03%2FMyBatis%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[关联查询当查询内容涉及到具有关联关系的多个表时， 就需要使用关联查询。根据表与表间的关联关系的不同，关联查询分为四种： （1）一对一关联查询（2）一对多关联查询（3）多对一关联查询（4）多对多关联查询 由于日常工作中最常见的关联关系是一对多、多对一与多对多，所以这里就不专门只讲解一对一关联查询了，其解决方案与多对一解决方案是相同的。 一对多关联查询项目： one2many 这里的一对多关联查询是指，在查询一方对象的时候，同时将其所关联的多方对象也都查询出来。 下面以国家 Country 与部长 Minister 间的一对多关系进行演示。 （1） 定义实体 在定义实体时， 若定义的是双向关联，即双方的属性中均有对方对象作为域属性出现，那么它们在定义各自的 toString()方法时需要注意，只让某一方可以输出另一方即可，不要让双方的 toString()方法均可输出对方。这样会形成递归调用，程序出错。 1234567public class Country &#123; private Integer cid; private String cname; //关联属性 private Set&lt;Minister&gt; ministers;&#125; 12345public class Minister &#123; private Integer mid; private String mname;&#125; （2） 定义数据库表 （3） 定义 Dao 层接口 1234public interface ICountryDao &#123; Country selectCountryById(int cid);&#125; （4） 定义工具类 12345678910111213141516public class MyBatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; public static SqlSession getSqlSession() &#123; try &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); if (sqlSessionFactory == null) &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; return sqlSessionFactory.openSession(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; （5） 定义映射文件 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.huang.dao.ICountryDao"&gt; &lt;resultMap type="Country" id="countryMapper"&gt; &lt;id column="cid" property="cid"/&gt; &lt;result column="cname" property="cname"/&gt; &lt;!-- 关联属性的映射关系 --&gt; &lt;collection property="ministers" ofType="Minister"&gt; &lt;id column="mid" property="mid"/&gt; &lt;result column="mname" property="mname"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 多表连接查询 --&gt; &lt;select id="selectCountryById" resultMap="countryMapper"&gt; select cid,cname,mid,mname from country,minister where countryId=cid and cid=#&#123;xxx&#125; &lt;/select&gt; &lt;/mapper&gt; （6） 定义主配置文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 注册DB连接四要素属性文件 --&gt; &lt;properties resource="jdbc.properties" /&gt; &lt;!-- 定义类型别名 --&gt; &lt;typeAliases&gt; &lt;!-- 将指定包中所有类的简单类名当作其别名 --&gt; &lt;package name="com.huang.beans" /&gt; &lt;/typeAliases&gt; &lt;!-- 配置运行环境 --&gt; &lt;environments default="testEM"&gt; &lt;environment id="testEM"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.user&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 注册映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="com/huang/dao/mapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; （7） 定义测试类 12345678910111213141516171819202122232425public class MyTest &#123; private ICountryDao dao; private SqlSession sqlSession; @Before public void before() &#123; sqlSession = MyBatisUtils.getSqlSession(); dao = sqlSession.getMapper(ICountryDao.class); &#125; @After public void after() &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; @Test public void test01() &#123; Country country = dao.selectCountryById(2); System.out.println(country); &#125; &#125; （8） 运行结果 在映射文件中使用&lt;collection/&gt;标签体现出两个实体对象间的关联关系。 其两个属性的意义为： property： 指定关联属性， 即 Country 类中的集合属性 ofType：集合属性的泛型类型 多表单独查询方式多表连接查询方式是将多张表进行连接，连为一张表后进行查询。其查询的本质是一张表。 关联属性&lt;collection/&gt;的数据来自于另一个查询&lt;selectMinisterByCountry/&gt;。而该查询&lt;selectMinisterByCountry/&gt;的动态参数 countryId=#{ooo}的值来自于查询&lt;selectCountryById/&gt;的查询结果字段 cid。 多对一关联查询项目： many2one(基于one2many) 这里的多对一关联查询是指，在查询多方对象的时候，同时将其所关联的一方对象也查询出来。 由于在查询多方对象时也是一个一个查询，所以多对一关联查询，其实就是一对一关联查询。即一对一关联查询的实现方式与多对一的实现方式是相同的。 下面以部长 Minister 与国家 Country 间的多对一关系进行演示。 1. 多表连接查询方式（1） 修改实体 12345public class Country &#123; private Integer cid; private String cname;&#125; 1234567public class Minister &#123; private Integer mid; private String mname;// 关联属性 private Country country;&#125; （2） 修改数据库 （3） 修改 Dao 层接口 123public interface IMinisterDao &#123; Minister selectMinisterById(int mid);&#125; （4） 修改映射文件 1234567891011121314&lt;resultMap type="Minister" id="ministerMapper"&gt; &lt;id column="mid" property="mid"/&gt; &lt;result column="mname" property="mname"/&gt; &lt;association property="country" javaType="Country"&gt; &lt;id column="cid" property="cid"/&gt; &lt;result column="cname" property="cname"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id="selectMinisterById" resultMap="ministerMapper"&gt; select mid,mname,cid,cname from minister, country where countryId=cid and mid=#&#123;xxx&#125;&lt;/select&gt; （5） 修改测试类 12345678910111213141516171819202122232425public class MyTest &#123; private IMinisterDao dao; private SqlSession sqlSession; @Before public void before() &#123; sqlSession = MyBatisUtils.getSqlSession(); dao = sqlSession.getMapper(IMinisterDao.class); &#125; @After public void after() &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; @Test public void test01() &#123; Minister minister = dao.selectMinisterById(2); System.out.println(minister); &#125; &#125; （6） 运行结果 2. 多表单独查询方式（1） 修改映射文件 （2） 运行结果 自关联查询所谓自关联是指，自己即充当一方，又充当多方，是 1:n 或 n:1 的变型。例如，对于新闻栏目 NewsColumn，可以充当一方，即父栏目，也可以充当多方，即子栏目。而反映到 DB 表中，只有一张表，这张表中具有一个外键，用于表示该栏目的父栏目。一级栏目没有父栏目，所以可以将其外键值设为 0，而子栏目则具有外键值。 为了便于理解，将自关联分为两种情况来讲解。一种是当作 1:n 讲解，即当前类作为一方，其包含多方的集合域属性。一种是当作 n:1 讲解，即当前类作为多方，其包含一方的域属性。下面以新闻栏目为例: 1. 以一对多方式处理以一对多方式处理，即一方可以看到多方。 该处理方式的应用场景比较多，例如在页面上点击父栏目，显示出其子栏目。再如，将鼠标定位在窗口中的某菜单项上会显示其所有子菜单项等。 A. 查询指定栏目的所有子孙栏目 根据指定的 id，仅查询出其所有子栏目。当然，包括其所有辈份的孙子栏目。 即，给出的查询 id 实际为父栏目 id。 （1） 自关联的 DB 表 （2） 定义实体类 1234567// 新闻栏目：当前的新闻栏目被看作是一方，即父栏目public class NewsLabel &#123; private Integer id; private String name; // 栏目名称 private Set&lt;NewsLabel&gt; children;&#125; （3） 定义 Dao 接口 123public interface INewsLabelDao &#123; List&lt;NewsLabel&gt; selectChildrenByParent(int pid);&#125; （4） 定义 mapper 映射 12345678910111213141516171819202122&lt;mapper namespace="com.huang.dao.INewsLabelDao"&gt; &lt;!-- &lt;select id="" resultMap="newslabelMapper"&gt; select id,name from newslabel where pid=#&#123;ooo&#125; &lt;/select&gt; --&gt; &lt;resultMap type="NewsLabel" id="newslabelMapper"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;collection property="children" ofType="NewsLabel" select="selectChildrenByParent" column="id"/&gt; &lt;/resultMap&gt; &lt;select id="selectChildrenByParent" resultMap="newslabelMapper"&gt; select id,name from newslabel where pid=#&#123;xxx&#125; &lt;/select&gt; &lt;/mapper&gt; （5） 定义测试类 123456789101112131415161718192021222324252627public class MyTest &#123; private INewsLabelDao dao; private SqlSession sqlSession; @Before public void before() &#123; sqlSession = MyBatisUtils.getSqlSession(); dao = sqlSession.getMapper(INewsLabelDao.class); &#125; @After public void after() &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; @Test public void test01() &#123; List&lt;NewsLabel&gt; children = dao.selectChildrenByParent(3); for (NewsLabel newsLabel : children) &#123; System.out.println(newsLabel); &#125; &#125; &#125; （6） 运行结果 B. 查询指定栏目及其所有子孙栏目 这里的查询结果，即要包含指定 id 的当前栏目，还包含其所有辈份的孙子栏目。 即给出的 id 实际为当前要查询的栏目的 id。 （1） 修改 Dao 接口 123public interface INewsLabelDao &#123; NewsLabel selectNewsLabelById(int id);&#125; （2） 修改 mapper 映射 12345678910111213141516171819202122&lt;select id="selectNewslabelByParent" resultMap="newslabelMapper"&gt; select id,name from newslabel where pid=#&#123;ooo&#125; &lt;/select&gt; &lt;resultMap type="NewsLabel" id="newslabelMapper"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;collection property="children" ofType="NewsLabel" select="selectNewslabelByParent" column="id"/&gt; &lt;/resultMap&gt; &lt;select id="selectNewsLabelById" resultMap="newslabelMapper"&gt; select id,name from newslabel where id=#&#123;xxx&#125; &lt;/select&gt; &lt;/mapper&gt; （3） 修改测试类 123456@Testpublic void test01() &#123; NewsLabel newsLabel = dao.selectNewsLabelById(3); System.out.println(newsLabel); &#125; （4）运行结果 注意 A 和 B 查询的区别 2. 以多对一方式处理以多对一方式处理，即多方可以看到一方。 该处理方式的应用场景，例如在网页上显示当前页面的站内位置。 （1） 定义实体类 1234567// 新闻栏目：当前的新闻栏目被看作是一方，即父栏目public class NewsLabel &#123; private Integer id; private String name; // 栏目名称 private NewsLabel parent; //父栏目&#125; （2） 定义 Dao 接口 123public interface INewsLabelDao &#123; NewsLabel selectNewsLabelById(int id);&#125; （3） 定义 mapper 映射 1234567891011121314&lt;resultMap type="NewsLabel" id="newslabelMapper"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;collection property="parent" javaType="NewsLabel" select="selectNewsLabelById" column="pid"/&gt;&lt;/resultMap&gt;&lt;select id="selectNewsLabelById" resultMap="newslabelMapper"&gt; select id,name,pid from newslabel where id=#&#123;xxx&#125;&lt;/select&gt; （4） 定义测试类 123456@Testpublic void test01() &#123; NewsLabel newsLabel = dao.selectNewsLabelById(9); System.out.println(newsLabel); &#125; （5） 运行结果 多对多关联查询什么是多对多关联关系？一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。 项目： many2many （1） 定义实体 123456public class Student &#123; private Integer sid; private String sname; private Set&lt;Course&gt; courses;&#125; 123456public class Course &#123; private Integer cid; private String cname; private Set&lt;Student&gt; students;&#125; （2） 定义数据库表 （3） 定义 Dao 层接口 123public interface IStudentDao &#123; Student selectStudentById(int sid);&#125; （4） 定义工具类 12345678910111213141516public class MyBatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; public static SqlSession getSqlSession() &#123; try &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); if (sqlSessionFactory == null) &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; return sqlSessionFactory.openSession(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; （5） 定义 mapper 映射 123456789101112131415161718&lt;resultMap type="Student" id="studentMapper"&gt; &lt;id column="sid" property="sid"/&gt; &lt;result column="sname" property="sname"/&gt; &lt;collection property="courses" ofType="Course"&gt; &lt;id column="cid" property="cid"/&gt; &lt;result column="cname" property="cname"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;select id="selectStudentById" resultMap="studentMapper"&gt; select sid,sname,cid,cname from student,middle,course where sid=studentId and cid=courseId and sid=#&#123;xxx&#125;&lt;/select&gt; （5） 定义测试类 123456@Testpublic void test01() &#123; Student student = dao.selectStudentById(1); System.out.println(student); &#125; （6） 运行结果 延迟加载MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。 延迟加载可以有效的减少数据库压力。 注意：MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。 关联对象加载时机MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：直接加载、侵入式延迟加载与深度延迟加载。 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。 侵入式延迟： 执行对主加载对象的查时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。 注意:延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。 MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。下面以一对多关联关系查询为例： 直接加载在主配置文件的&lt;properties/&gt;与&lt;typeAliases/&gt;标签之间，添 &lt;settings/&gt;标签，用于完成全局参数设置。（可参考 MyBatis 官方文档） 12345&lt;!-- 设置整个应用所使用的常量 --&gt;&lt;settings&gt; &lt;!-- 延迟加载的总开关 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;/settings&gt; 标签的书写位置，是由约束文件进行规定好的，不能随便写 深度延迟加载修改主配置文件的&lt;settings/&gt;，将延迟加载开关 lazyLoadingEnabled 开启（置为 true），将侵入式延迟加载开关 aggressiveLazyLoading 关闭（置为 false）。 1234567&lt;!-- 设置整个应用所使用的常量 --&gt;&lt;settings&gt; &lt;!-- 延迟加载的总开关 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 侵入式延迟加载开关 --&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt; 侵入式延迟加载修改主配置文件的&lt;settings/&gt;，将延迟加载开关 lazyLoadingEnabled 开启（置为 true），将侵入式延迟加载开关 aggressiveLazyLoading 也开启（置为 true，默认为 true）。 1234567&lt;!-- 设置整个应用所使用的常量 --&gt;&lt;settings&gt; &lt;!-- 延迟加载的总开关 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 侵入式延迟加载开关 --&gt; &lt;setting name="aggressiveLazyLoading" value="true"/&gt;&lt;/settings&gt; 注意：侵入式延迟加载需要在延迟加载开关 lazyLoadingEnabled开启时才会起作用。若 lazyLoadingEnabled 为 false，则 aggressiveLazyLoading 无论取何值，均不起作用。 延迟加载策略总结 加载策略 lazyLoadingEnabled取值 aggressiveLazyLoading取值 直接加载 false false 深度延迟加载 true false 侵入式延迟加载 true true]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis单表的CURD操作]]></title>
    <url>%2F2019%2F08%2F02%2FMyBatis%E5%8D%95%E8%A1%A8%E7%9A%84CURD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[CURD 操作，即指对数据库中实体对象的增 Create、改 Update、查 Read、删 Delete 操作。 自定义 Dao 接口实现类搭建测试环境项目： curd （1）定义实体类 12345public class Student &#123; private Integer id; private String name; private int age; private double score; （2）定义 Dao 接口 12345678910111213141516public interface IStudentDao &#123; void insertStudent(Student student); void insertStudentCacheId(Student student); void deleteStudentById(int id); void updateStudent(Student student); List&lt;Student&gt; selectAllStudents(); Map&lt;String, Student&gt; selectStudentMap(); Student selectStudentById(int id); Student selectStudentById(Map&lt;String, Object&gt; map); List&lt;Student&gt; selectStudentsByName(String name);&#125; （3）定义 Dao 实现类 123456789101112131415161718192021public class StudentDaoImpl implements IStudentDao &#123; private SqlSession sqlSession; @Override public void insertStudent(Student student) &#123; try &#123; //使用工具类获取SqlSession对象 sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.insert("insertStudent",student); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) sqlSession.close(); &#125; &#125; （4）创建工具类 1234567891011121314151617public class MyBatisUtil &#123; private static SqlSessionFactory sqlSessionFactory; public static SqlSession getSqlSession() &#123; try &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); if (sqlSessionFactory == null) &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; return sqlSessionFactory.openSession(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; （5）定义测试类 123456789public class MyTest &#123; private StudentDaoImpl dao; @Before public void setUp() &#123; dao= new StudentDaoImpl(); &#125;&#125; （6）数据库设计如下 单纯插入数据（1）修改映射文件 123456&lt;insert id="insertStudent"parameterType="com.huang.beans.Student"&gt; insert into student(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;, #&#123;score&#125;)&lt;/insert&gt; id：该 SQL 语句的唯一标识， Java 代码中要使用该标识 #{ }：对指定参数类型属性值的引用。其底层是通过反射机制，调用 Student 类相关属性的 get 方法来获取值的。因为底层使用的是反射，所以这里使用的是类的属性名，而非表的字段名。 （2）修改 Dao 实现类 使用 SqlSession 对象的 insert()方法。该方法默认返回 DB 中受影响条数。其方法原型为：insert(String id, Object obj)。 1234567891011121314151617@Override public void insertStudent(Student student) &#123; try &#123; //使用工具类获取SqlSession对象 sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.insert("insertStudent",student); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; 注意：执行完对 DB 的修改操作，必须要做 SqlSession 的提交。否则，修改将无法同步到 DB 中。因为使用无参的 openSession()方法已经将事务的自动提交功能给关闭了。 （3）修改测试类 12345678@Test public void test01() &#123; for (int i = 1; i &lt; 10; i++) &#123; Student student = new Student("n_" + i, 15 + i,85.5 + i); dao.insertStudent(student); &#125; &#125; （4）运行结果 插入后用新 id 初始化被插入对象（1）修改映射文件映射文件的标签中，有一个子标签用于获取新插入记录的主键值。 123456789&lt;insert id="insertStudentCacheId"parameterType="com.huang.beans.Student"&gt; insert into student(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;, #&#123;score&#125;) &lt;selectKey resultType="int" keyProperty="id" order="AFTER"&gt; select @@identity &lt;/selectKey&gt;&lt;/insert&gt; resultType：指出获取的主键的类型。 keyProperty：指出主键在 Java 类中对应的属性名。此处会将获取的主键值直接封装到被插入的 Student 对象中，即 dao 中 insert()方法的第二个参数对象中。 order：指出 id 的生成相对于 insert 语句的执行是在前还是在后。 MySql 数据库表中的 id，均是先执行 insert 语句，而后生成 id， 所以需要设置为 AFTER； Oracle 数据库表中的 id，则是在 insert 执行之前先生成，所以需要设置为 BEFORE。 当前的 MyBatis 版本，不指定 order 属性，则会根据所用 DBMS，自动选择其值。 （2）修改 Dao 实现类 12345678910111213141516@Override public void insertStudentCacheId(Student student) &#123; try &#123; //使用工具类获取SqlSession对象 sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.insert("insertStudentCacheId",student); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; （3）修改测试类 12345678@Test public void test02()&#123; Student student = new Student("张三", 28, 93.5); System.out.println("插入前student = " + student); dao.insertStudentCatchId(student); System.out.println("插入后student = " + student); &#125; （4）运行结果 删除数据（1）修改映射文件 123&lt;delete id="deleteStudentById"&gt; delete from student where id=#&#123;xxx&#125;&lt;/delete&gt; 注意：这里的动态参数 id 所赋值为#{xxx}。这个#{xxx}表示这就是个占位符，代表 delete()方法的第二个参数。 #{ }中可以放任意值，无需要与 delete()方法的第二个参数值相同。 （2）修改 Dao 实现类 123456789101112131415161718@Override public void deleteStudentById(int id) &#123; try &#123; //使用工具类获取SqlSession对象 sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.delete("deleteStudentById",id); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; （3）修改测试类 1234@Test public void test03() &#123; dao.deleteStudentById(5); &#125; 修改数据（1）修改映射文件 12345&lt;update id="updateStudent"&gt; update student set name=#&#123;name&#125;, age=#&#123;age&#125;, score=#&#123;score&#125; where id=#&#123;id&#125;&lt;/update&gt; 注意：这里的#{ }中，必须要填写 update()方法所传第二个参数 student 对象的属性名称，不能随意填写。 （2）修改 Dao 实现类 123456789101112131415161718@Override public void updateStudent(Student student) &#123; try &#123; //使用工具类获取SqlSession对象 sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.delete("updateStudent",student); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; （3）修改测试类 1234567@Testpublic void test04() &#123; Student student = new Student("张小三", 18, 99.5); student.setId(1); dao.updateStudent(student);&#125; 查询所有对象-返回 List（1）修改映射文件 123&lt;select id="selectAllStudents" resultType="Student"&gt; select id,name,age,score from student&lt;/select&gt; 注意：resultType 属性并非指查询结果集最后的类型，而是每查出 DB 中的一条记录，将该记录封装成为的对象的类型。 （2）注册类的别名 123 &lt;!-- 将指定包中所有类的简单类名当作其别名 ,type：全限定性类名,alias：别名--&gt; &lt;package name="com.huang.beans"/&gt;&lt;/typeAliases&gt; （3）修改 Dao 实现类 完成 Dao 实现类的 selectAllStudent()方法。 使用 SqlSession 的 selectList()方法完成查询操作。 该方法会将查询出的每条记录封装为指定类型对象后，再将最后的结果集封装为 List 返回。 方法原型为： List selectList (String statement)。 statement：映射文件中配置的 SQL 语句的 id。 1234567891011121314@Override public List&lt;Student&gt; selectAllStudents() &#123; List&lt;Student&gt; students = null; try &#123; sqlSession = MyBatisUtils.getSqlSession(); students = sqlSession.selectList("selectAllStudents"); //sqlSession.commit(); &#125; finally &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return students; &#125; 说明：在写查询时，由于不是对 DB 中数据进行修改，所以无需进行 SqlSession 的提交。但最终 SqlSession 对象还是需要关闭的。 （4）修改测试类 12345678//查询所有：返回List@Testpublic void test05() &#123; List&lt;Student&gt; students = dao.selectAllStudents(); for (Student student : students) &#123; System.out.println(student); &#125;&#125; （5）运行结果 查询所有对象-返回 Map（1）修改 Dao 实现类 完成 Dao 实现类的 selectStudentMap()方法。 使用 SqlSession 的 selectMap()方法完成查询操作。 该查询方法会将查询出的每条记录先封装为指定对象，然后再将该对象作为 value，将该对象的指定属性所对应的字段名作为 key 封装为一个 Map 对象。 方法原型为： Map&lt;Object,Object&gt; selectMap (String statement, String mapKey)。 statement：映射文件中配置的 SQL 语句的 id。 mapKey：查询出的 Map 所要使用的 key。这个 key 为数据表的字段名。查询出的结果是一个 Map，每行记录将会对应一个 Map.entry 对象，该对象的 key 为指定字段的值， value为记录数据所封装的对象。 12345678910111213@Override public Map&lt;String, Object&gt; selectAllStudentsMap() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); try &#123; sqlSession = MyBatisUtils.getSqlSession(); map = sqlSession.selectMap("selectAllStudents", "name"); &#125; finally &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return map; &#125; （2）修改测试类 12345@Testpublic void test06() &#123; Map&lt;String, Object&gt; map = dao.selectAllStudentsMap(); System.out.println(map.get("张三"));&#125; （3）运行结果 说明：若指定的作为 key 的属性值在 DB 中并不唯一，则后面的记录值会覆盖掉前面的值。即指定 key 的 value 值，一定是 DB 中该同名属性的最后一条记录值。 查询单个对象（1）修改映射文件 1234&lt;!-- 符号jjj表示占位符 --&gt;&lt;select id="selectStudentById" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;jjj&#125;&lt;/select&gt; （2）修改 Dao 实现类 使用 SqlSession 的 selectOne()方法。其会将查询的结果记录封装为一个指定类型的对象。方法原型为： Object selectOne (String statement, Object parameter) statement：映射文件中配置的 SQL 语句的 id parameter：查询条件中动态参数的值 12345678910111213@Overridepublic Student selectStudentById(int id) &#123; Student student = null; try &#123; sqlSession = MyBatisUtils.getSqlSession(); student = sqlSession.selectOne("selectStudentById", id); &#125; finally &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return student;&#125; （3）修改测试类 12345@Testpublic void test07() &#123; Student student = dao.selectStudentById(22); System.out.println(student);&#125; 模糊查询（1）修改映射文件 123&lt;select id="selectStudentsByName" resultType="Student"&gt; select id,name,age,score from student where name like '%' #&#123;xxx&#125; '%'&lt;/select&gt; 注意：在进行模糊查询时， 需要进行字符串的拼接。 SQL 中的字符串的拼接使用的是函数 concat(arg1,arg2,…)。注意不能使用 Java 中的字符串连接符+。 （2）修改 Dao 实现类 12345678910111213@Overridepublic List&lt;Student&gt; selectStudentsByName(String name) &#123; List&lt;Student&gt; students = null; try &#123; sqlSession = MyBatisUtils.getSqlSession(); students = sqlSession.selectList("selectStudentsByName", name); &#125; finally &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return students;&#125; （3）修改测试类 1234567@Testpublic void test08() &#123; List&lt;Student&gt; students = dao.selectStudentsByName("张"); for (Student student : students) &#123; System.out.println(student); &#125;&#125; （4）运行结果 $与#的区别 理论区别$与#的区别是很大的。 #为占位符，而$为字符串拼接符。字符串拼接是将参数值以硬编码的方式直接拼接到了 SQL 语句中。字符串拼接就会引发两个问题： SQL 注入问题与没有使用预编译所导致的执行效率低下问题。 执行区别 应用场景 一般情况下，动态参数的值是由用户输入的，则不能使用拼接符$，因为有可能会出现 SQL 注入；若动态参数的值是由系统计算生成的，则可以使用拼接符$。 但这样虽然不存在 SQL 注入的风险，但仍存在执行效率问题。 根据 Map 进行查询mapper 中 SQL 语句的动态参数也可以是 Map 的 key。 （1）修改映射文件 123&lt;select id="selectStudentByMap" resultType="Student"&gt; select * from student where id=#&#123;studentId&#125;&lt;/select&gt; （2）修改 Dao 实现类 123456789101112131415@Overridepublic Student selectStudentByMap(Map&lt;String, Object&gt; map) &#123; Student student = null; try &#123; sqlSession = MyBatisUtils.getSqlSession(); student = sqlSession.selectOne("selectStudentByMap"); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return student;&#125; （3）修改测试类 123456789101112@Testpublic void test09() &#123; Student student = new Student(); student.setId(6); Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("studentId", 10); map.put("student", student); student = dao.selectStudentByMap(map); System.out.println(student);&#125; 属性名与查询字段名不相同resultType 可以将查询结果直接映射为实体 Bean 对象的条件是， SQL 查询的字段名与实体 Bean 的属性名一致。 因为在将查询结果转换为指定类型对象时，系统自动将查询结果字段名称作为对象的属性名， 通过反射机制完成对象的创建。当 SQL 查询结果的字段名和实体 Bean 的属性名不一致时， 将无法创建出需要类型的对象。 搭建测试环境 基于 curd 项目作修改 （1）修改 student 表 （2）修改 Dao 接口 123public interface IStudentDao &#123; Student selectStudentById(int id);&#125; （3）定义 Dao 实现类 1234567891011121314151617181920public class StudentDaoImpl implements IStudentDao &#123; private SqlSession sqlSession; @Override public Student selectStudentById(int id) &#123; Student student = null; try &#123; sqlSession = MyBatisUtils.getSqlSession(); student = sqlSession.selectOne("selectStudentById", id); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return student; &#125;&#125; （4）修改测试类 123456789101112131415public class MyTest &#123; private IStudentDao dao; @Before public void before() &#123; dao = new StudentDaoImpl(); &#125; @Test public void test01() &#123; Student student = dao.selectStudentById(1); System.out.println(student); &#125;&#125; 查询字段使用别名虽然属性名称与表中字段名称不一致，但可以为查询结果的字段名称赋予别名，让别名与实体 Bean 的属性名相同。这样框架也可以根据查询结果利用反射机制将对象创建。 在映射文件 mapper 中添加如下映射。 123&lt;select id="selectStudentById" resultType="Student"&gt; select tid id,tname name,tage age,score from student where tid=#&#123;xxx&#125;&lt;/select&gt; 运行结果如下： 使用结果映射 resultMap可以使用结果映射 resultMap（这里的 Map 是映射 mapper 的意思） 来建立映射关系，完成由字段到属性的映射，达到将查询结果封装为对象的目的。 resultMap 是对 resultType的增强。 修改映射文件 mapper.xml。 12345678910 &lt;resultMap type="Student" id="studentMapper"&gt; &lt;id column="tid" property="id"/&gt; &lt;result column="tname" property="name"/&gt; &lt;result column="tage" property="age"/&gt; &lt;/resultMap&gt;&lt;select id="selectStudentById" resultMap="studentMapper"&gt; select tid,tname,tage,score from student where tid=#&#123;xxx&#125;&lt;/select&gt; 运行结果如下： Mapper 动态代理在前面例子中自定义 Dao 接口实现类时发现一个问题： Dao 的实现类其实并没有干什么实质性的工作，它仅仅就是通过 SqlSession 的相关 API 定位到映射文件 mapper 中相应 id 的 SQL 语句，真正对 DB 进行操作的工作其实是由框架通过 mapper 中的 SQL 完成的。 所以， MyBatis 框架就抛开了 Dao 的实现类，直接定位到映射文件 mapper 中的相应 SQL语句，对 DB 进行操作。这种对 Dao 的实现方式称为 Mapper 的动态代理方式。Mapper 动态代理方式无需程序员实现 Dao 接口。接口是由 MyBatis 结合映射文件自动生成的动态代理实现的。 项目： dynamicMapper（基于 curd 项目修改） 映射文件的 namespace 属性值一般情况下，一个 Dao 接口的实现类方法使用的是同一个 SQL 映射文件中的 SQL 映射 id。 所以， MyBatis 框架要求，将映射文件中标签的 namespace 属性设为 Dao 接口的全类名，则系统会根据方法所属 Dao 接口，自动到相应 namespace 的映射文件中查找相关的 SQL 映射。 简单来说，通过接口名即可定位到映射文件 mapper。 1&lt;mapper namespace="com.huang.dao.IStudentDao"&gt; 修改日志输出控制文件mapper 的 namespace 修改了，则需要将日志输出控制文件中 logger 的输出对象进行修改。 12##define a loggerlog4j.logger.com.huang.dao.IStudentDao=trace,console Dao 接口方法名MyBatis 框架要求， 接口中的方法名，与映射文件中相应的 SQL 标签的 id 值相同。 系统会自动根据方法名到相应的映射文件中查找同名的 SQL 映射 id。简单来说，通过方法名就可定位到映射文件 mapper 中相应的 SQL 语句。 1234567891011public interface IStudentDao &#123; void insertStudent(Student student); void deleteStudentById(int id); void updateStudent(Student student); List&lt;Student&gt; selectAllStudents(); Student selectStudentById(int id); List&lt;Student&gt; selectStudentsByName(String name);&#125; 删除 Dao 实现类由于通过调用 Dao 接口的方法，不仅可以从 SQL 映射文件中找到所要执行 SQL 语句，还可通过方法参数及返回值，将 SQL 语句的动态参数传入，将查询结果返回。所以， Dao 的实现工作，完全可以由 MyBatis 系统自动根据映射文件完成。 修改测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyTest &#123; private IStudentDao dao; private SqlSession session; @Before public void setUp() &#123; session = MyBatisUtils.getSqlSession(); dao = session.getMapper(IStudentDao.class); &#125; @After public void tearDown() &#123; if (session != null) &#123; session.close(); &#125; &#125; @Test public void test01() &#123; Student student = new Student("张三", 23, 93.5); System.out.println("插入前：student = " + student); dao.insertStudent(student); System.out.println("插入后：student = " + student); //添加SqlSession的提交方法 session.commit(); &#125; /*@Test public void test02() &#123; Student student = new Student("张三", 23, 93.5); System.out.println("插入前：student = " + student); dao.insertStudentCacheId(student); System.out.println("插入后：student = " + student); &#125;*/ @Test public void test03() &#123; dao.deleteStudentById(22); //添加SqlSession的提交方法 session.commit(); &#125; @Test public void test04() &#123; Student student = new Student("张大三", 23, 93.5); student.setId(8); dao.updateStudent(student); //添加SqlSession的提交方法 session.commit(); &#125; 多查询条件无法整体接收问题的解决在实际工作中，表单中所给出的查询条件有时是无法将其封装为一个对象的，也就是说，查询方法只能携带多个参数，而不能携带将这多个参数进行封装的一个对象。对于这个问题，有两种解决方案。 1. 将这多个参数封装为一个 Map（1）修改 Dao 接口 123public interface IStudentDao &#123; List&lt;Student&gt; selectStudentsByCondition(Map&lt;String, Object&gt; map);&#125; （2）修改映射文件 1234567&lt;select id="selectStudentsByCondition" resultType="Student"&gt; select id,name,age,score from student where name like '%' #&#123;nameCon&#125; '%' and age &gt; #&#123;ageCon&#125; and score &gt; #&#123;scoreCon&#125; &lt;/select&gt; （3）修改测试类 1234567891011121314151617//根据吗map查询@Testpublic void test01() &#123; Student stu = new Student("王小五", 20, 96.5); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("nameCon", "王"); map.put("ageCon", 23); map.put("stu", stu); List&lt;Student&gt; students = dao.selectStudentsByCondition(map); for (Student student : students) &#123; System.out.println(student); &#125;&#125; 2. 多个参数逐个接收对于 mapper 中的 SQL 语句，可以通过参数索引#{index}的方式逐个接收每个参数。 （1）修改 Dao 接口 123public interface IStudentDao &#123; List&lt;Student&gt; selectStudentsByCondition(String name, int age);&#125; （2）修改映射文件 123456&lt;select id="selectStudentsByCondition" resultType="Student"&gt; select id,name,age,score from student where name like '%' #&#123;0&#125; '%' and age &gt; #&#123;1&#125; &lt;/select&gt; （3）修改测试类 12345678@Testpublic void test01() &#123; List&lt;Student&gt; students = dao.selectStudentsByCondition("张", 23); for (Student student : students) &#123; System.out.println(student); &#125;&#125; 问题：#{}中可以放什么内容？1）参数对象的属性2）随意内容，此时的#{}是个占位符3）参数为map时的key4）参数为map时，若key所对应的value为对象，则可将该对象的属性放入5）参数的索引号 动态SQL动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。 动态 SQL，即通过 MyBatis 提供的各种标签对条件作出判断以实现动态拼接 SQL 语句。这里的条件判断使用的表达式为 OGNL 表达式。 常用的动态 SQL 标签有&lt;if/&gt;、 &lt;where/&gt;、&lt;choose/&gt;、&lt;foreach/&gt;等。 MyBatis 的动态 SQL 语句，与 JSTL 中的语句非常相似。 项目： dynamicSql 搭建测试环境（1） 定义数据库表 {$ asset_img curd12.jpg $} （2） 定义实体 1234567public class Student &#123; private Integer id; private String name; private int age; private double score;&#125; （3） 创建工具类 12345678910111213141516public class MyBatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; public static SqlSession getSqlSession() &#123; try &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); if (sqlSessionFactory == null) &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; return sqlSessionFactory.openSession(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; （4）定义测试类 定义@Before 与@After 方法 12345678910111213141516171819public class MyTest &#123; private IStudentDao dao; private SqlSession sqlSession; @Before public void setUp() &#123; sqlSession = MyBatisUtils.getSqlSession(); dao = sqlSession.getMapper(IStudentDao.class); &#125; @After public void tearDown() &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 注意：在 mapper 的动态 SQL 中若出现大于号（&gt;）、小于号（&lt;）、大于等于号（&gt;=），小于等于号（&lt;=）等符号，最好将其转换为实体符号。否则， XML 可能会出现解析出错问题。特别是对于小于号（&lt;），在 XML 中是绝对不能出现的。否则，一定出错。 &lt;if/&gt;标签对于该标签的执行，当 test 的值为 true 时，会将其包含的 SQL 片断拼接到其所在的 SQL语句中。这引发的问题是，查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。 （1）定义 Dao 接口 1234public interface IStudentDao &#123; List&lt;Student&gt; selectStudentsByIf(Student student); &#125; （2）定义映射文件 为了解决两个条件均未做设定的情况，在 where 后添加了一个“1=1”的条件。这样就不至于两个条件均未设定而出现只剩下一个 where，而没有任何可拼接的条件的不完整 SQL语句。 123456789101112 &lt;!-- if标签 --&gt;&lt;select id="selectStudentsByIf" resultType="Student"&gt; select id,name,age,score from student where 1 = 1 &lt;if test="name != null and name != ''"&gt; and name like '%' #&#123;name&#125; '%' &lt;/if&gt; &lt;if test="age &gt; 0"&gt; and age &gt; #&#123;age&#125; &lt;/if&gt;&lt;/select&gt; （3）修改测试类 1234567891011 @Test public void test01() &#123; Student stu = new Student("张", 18, 0);// Student stu = new Student("", 23, 0);// Student stu = new Student("", 0, 0); List&lt;Student&gt; students = dao.selectStudentsByIf(stu); for (Student student : students) &#123; System.out.println(student); &#125; &#125; （4）运行结果 &lt;where/&gt;标签&lt;if/&gt;标签的中存在一个比较麻烦的地方：需要在 where 后手工添加 1=1 的子句。因为，若 where 后的所有&lt;if/&gt;条件均为 false，而 where 后若又没有 1=1 子句，则 SQL 中就会只剩下一个空的 where， SQL 出错。所以，在 where 后，需要添加永为真子句 1=1，以防止这种情况的发生。但当数据量很大时，会严重影响查询效率。 （1）修改 Dao 接口 1List&lt;Student&gt; selectStudentsByWhere(Student student); （2）定义映射文件 12345678910111213&lt;!-- where标签 --&gt;&lt;select id="selectStudentsByWhere" resultType="Student"&gt; select id,name,age,score from student &lt;where&gt; &lt;if test="name != null and name != ''"&gt; and name like '%' #&#123;name&#125; '%' &lt;/if&gt; &lt;if test="age &gt; 0"&gt; and age &gt; #&#123;age&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; （3）修改测试类 1234567891011 @Test public void test02() &#123; Student stu = new Student("张", 18, 0);// Student stu = new Student("", 23, 0);// Student stu = new Student("", 0, 0); List&lt;Student&gt; students = dao.selectStudentsByWhere(stu); for (Student student : students) &#123; System.out.println(student); &#125; &#125; （4）运行结果 &lt;choose/&gt;标签该标签中只可以包含&lt;when/&gt;&lt;otherwise/&gt;，可以包含多个与一个&lt;otherwise/&gt;。它们联合使用，完成 Java 中的开关语句 switch..case 功能。 （1）修改 Dao 接口 1List&lt;Student&gt; selectStudentsByChoose(Student student); （2）定义映射文件 123456789101112131415161718&lt;!-- choose标签 --&gt;&lt;select id="selectStudentsByChoose" resultType="Student"&gt; select id,name,age,score from student &lt;where&gt; &lt;choose&gt; &lt;when test="name != null and name !=''"&gt; and name like '%' #&#123;name&#125; '%' &lt;/when&gt; &lt;when test="age &gt; 0"&gt; and age &gt; #&#123;age&#125; &lt;/when&gt; &lt;otherwise&gt; 1 = 2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; （3）修改测试类 1234567891011 @Test public void test03() &#123;// Student stu = new Student("张", 18, 0); Student stu = new Student("", 23, 0);// Student stu = new Student("", 0, 0); List&lt;Student&gt; students = dao.selectStudentsByChoose(stu); for (Student student : students) &#123; System.out.println(student); &#125; &#125; &lt;foreach/&gt;标签&lt;foreach/&gt;标签用于实现对于数组与集合的遍历。对其使用，需要注意： collection 表示要遍历的集合类型，这里是数组，即 array。 open、 close、 separator 为对遍历内容的 SQL 拼接。 （1）修改 Dao 接口 123List&lt;Student&gt; selectStudentsByForeach(int[] ids);List&lt;Student&gt; selectStudentsByForeach2(List&lt;Integer&gt; ids);List&lt;Student&gt; selectStudentsByForeach3(List&lt;Student&gt; ids); （2）定义映射文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- foreach标签 ，遍历数组--&gt;&lt;select id="selectStudentsByForeach" resultType="Student"&gt; &lt;!-- select id,name,age,score from student where id in (1,3,5) --&gt; select id,name,age,score from student &lt;if test="array.length &gt; 0"&gt; where id in &lt;foreach collection="array" item="myid" open="(" close=")" separator=","&gt; #&#123;myid&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/select&gt;&lt;!-- foreach标签 ，遍历泛型为基本类型的 List--&gt;&lt;select id="selectStudentsByForeach2" resultType="Student"&gt; &lt;!-- select id,name,age,score from student where id in (1,3,5) --&gt; select id,name,age,score from student &lt;if test="list.size &gt; 0"&gt; where id in &lt;foreach collection="list" item="myid" open="(" close=")" separator=","&gt; #&#123;myid&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/select&gt;&lt;!-- foreach标签遍历泛型为自定义类型的 List --&gt;&lt;select id="selectStudentsByForeach3" resultType="Student"&gt; &lt;!-- select id,name,age,score from student where id in (1,3,5) --&gt; select id,name,age,score from student &lt;if test="list.size &gt; 0"&gt; where id in &lt;foreach collection="list" item="stu" open="(" close=")" separator=","&gt; #&#123;stu.id&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/select&gt; （3）修改测试类 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void test04() &#123; int[] ids = &#123;1, 3, 4&#125;; List&lt;Student&gt; students = dao.selectStudentsByForeach(ids); for (Student student : students) &#123; System.out.println(student); &#125;&#125;@Testpublic void test05() &#123; List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); ids.add(1); ids.add(3); List&lt;Student&gt; students = dao.selectStudentsByForeach2(ids); for (Student student : students) &#123; System.out.println(student); &#125;&#125;@Testpublic void test06() &#123; Student stu1 = new Student(); stu1.setId(1); Student stu2 = new Student(); stu2.setId(3); List&lt;Student&gt; stus = new ArrayList&lt;&gt;(); stus.add(stu1); stus.add(stu2); List&lt;Student&gt; students = dao.selectStudentsByForeach3(stus); for (Student student : students) &#123; System.out.println(student); &#125;&#125; &lt;sql/&gt;标签&lt;sql/&gt; 标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 &lt;include/&gt; 子标签。 该 &lt;sql/&gt; 标签可以定义 SQL 语句中的任何部分，所以 &lt;include/&gt; 子标签可以放在动态 SQL 的任何位置。 （1）修改 Dao 接口 1List&lt;Student&gt; selectStudentsBySqlFragment(List&lt;Student&gt; ids); （2）定义映射文件 12345678910111213141516&lt;!-- sql标签 --&gt;&lt;select id="selectStudentsBySqlFragment" resultType="Student"&gt; &lt;!-- select id,name,age,score from student where id in (1,3,5) --&gt; select &lt;include refid="selectColumns"/&gt; from student &lt;if test="list.size &gt; 0"&gt; where id in &lt;foreach collection="list" item="stu" open="(" close=")" separator=","&gt; #&#123;stu.id&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/select&gt;&lt;sql id="selectColumns"&gt; id,name,age,score &lt;/sql&gt; （3）修改测试类 12345678910111213141516@Testpublic void test07() &#123; Student stu1 = new Student(); stu1.setId(1); Student stu2 = new Student(); stu2.setId(3); List&lt;Student&gt; stus = new ArrayList&lt;&gt;(); stus.add(stu1); stus.add(stu2); List&lt;Student&gt; students = dao.selectStudentsBySqlFragment(stus); for (Student student : students) &#123; System.out.println(student); &#125;&#125; （4）运行结果]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis入门]]></title>
    <url>%2F2019%2F07%2F31%2FMyBatis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[框架 框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；另一种定义认为，框架是可被应用开发者定制的应用骨架。可以说，一个框架是一个可复用的设计构件，它规定了应用的体系结构，阐明了整个设计、协作构件之间的依赖关系、责任分配和控制流程，表现为一组抽象类以及其实例之间协作的方法，它为构件复用提供上下文(Context)关系。——百度百科 对于程序员来说，框架是一套资源，这套资源中会包含 Jar 包、文档，还有些会包含源码、代码示例等。这套资源从相关的官网上可以下载。一般是以压缩文件的形式出现。 Mybatis 概述 MyBatis 本是 apache 的一个开源项目 iBatis， 2010 年这个项目由 apache 迁移到了 google，并更名为 MyBatis。 2013 年迁移到 Github。——百度百科《MyBatis》 Mybatis 简介MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注SQL 语句本身，而不用再花费精力去处理诸如注册驱动、创建 Connection、 配置 Statement等繁杂过程。 Mybatis通过xml或注解的方式将要执行的各种statement （statement、preparedStatement等）配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的SQL 语句，最后由 MyBatis 框架执行 SQL 并将结果映射成 Java 对象并返回。 Mybatis 与 HibernateHibernate 框架是提供了全面的数据库封装机制的“全自动” ORM，即实现了 POJO 和数据库表之间的映射，以及 SQL 的自动生成和执行。 相对于此， MyBatis 只能算作是“半自动” ORM。其着力点，是在 POJO 类 与 SQL 语句之间的映射关系。也就是说， MyBatis 并不会为程序员自动生成 SQL 语句。具体的 SQL 需要程序员自己编写，然后通过 SQL 语句映射文件，将 SQL 所需的参数，以及返回的结果字段映射到指定 POJO。因此， MyBatis 成为了“全自动” ORM 的一种有益补充。 与 Hibernate 相比， MyBatis 具有以下几个特点： 在 XML 文件中配置 SQL 语句，实现了 SQL 语句与代码的分离，给程序的维护带来了很大便利。 因为需要程序员自己去编写 SQL 语句，程序员可以结合数据库自身的特点灵活控制 SQL 语句，因此能够实现比 Hibernate 等全自动 ORM 框架更高的查询效率，能够完成复杂查询。 简单，易于学习，易于使用，上手快。 Mybatis 体系结构 Mybatis 工作原理 第一个 Mybatis 程序需求： 实现将 Student 信息写入到 DB 中 基本程序项目： primary 1. 导入 Jar 包除了需要导入 MyBatis 的核心 Jar 包及依赖 Jar 包外，还需要导入 MySql 的驱动 Jar 包，JUnit 测试的 Jar 包。 2.定义实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.huang.beans;public class Student &#123; private Integer id; private String name; private int age; private double score; public Student(String name, int age, double score) &#123; super(); this.name = name; this.age = age; this.score = score; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getScore() &#123; return score; &#125; public void setScore(double score) &#123; this.score = score; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + ", age=" + age + ", score=" + score + "]"; &#125; &#125; 3. 在 DB 中生成表结构，即创建空表 注意：由于后面要创建的 MyBatis 映射文件映射的是 SQL 语句，而非像 Hibernate 一样，是类到表，属性到字段的映射。所以， MyBatis 要求， 在创建数据库表时，字段名要与属性名一致，如果不一致，需要通过 resultMap 解决。 4. 定义 Dao 接口12345678package com.huang.dao;import com.huang.beans.Student;public interface IStudentDao &#123; void insertStu(Student student);&#125; 5. 定义映射文件映射文件，简称为 mapper，主要完成 Dao 层中 SQL 语句的映射。映射文件名随意，一般放在 dao 包中。 这里映射文件名称定为 mapper.xml。 映射文件的约束文件常用有两种：.dtd、.xsd，约束文件 mybatis-3-mapper.dtd 文件，在 MyBatis 的核心 Jar 包的 org.apache.ibatis.builder.xml 包中存放。当然，主配置文件的约束 dtd 文件也在该位置存放。 映射文件内容为： 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="test"&gt; &lt;insert id="insertStudent" parameterType="com.huang.beans.Student"&gt; insert into student(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;, #&#123;score&#125;) &lt;/insert&gt;&lt;/mapper&gt; 注意：#{ }中写入的是 Student 类的属性名。 6. 定义主配置文件在主配置文件中添加约束，即配置文件头，配置文件名也可以随意命名，这里命名为 mybatis.xml。 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置运行环境 --&gt; &lt;environments default="onlineEM"&gt; &lt;environment id="onlineEM"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="testEM"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 注册映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="com/huang/dao/mapper.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 7. 定义 Dao 实现类123456789101112131415161718192021222324252627282930313233343536373839404142package com.huang.dao;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.huang.beans.Student;public class StudentDaoImpl implements IStudentDao &#123; private SqlSession sqlSession; @Override public void insertStu(Student student) &#123; try &#123; //1.读取主配置文件 InputStream inputStream = Resources.getResourceAsStream("mybatis.xml"); //2.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //创建SqlSession对象 sqlSession = sqlSessionFactory.openSession(); //操作 sqlSession.insert("insertStudent",student); //SqlSession提交 sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125;&#125; 8. 定义测试类12345678910111213141516171819202122package com.huang.test;import org.junit.Before;import org.junit.Test;import com.huang.beans.Student;import com.huang.dao.StudentDaoImpl;public class MyTest &#123; private StudentDaoImpl dao; @Before public void before() &#123; dao= new StudentDaoImpl(); &#125; @Test public void test01() &#123; Student student = new Student("赵六", 26, 97.5); dao.insertStu(student); &#125;&#125; 9. 添加日志控制文件MyBatis 使用 Log4j 进行日志处理，而 Login4j2 对其支持并不好，所以在 MyBatis 中需要将 log4j.properties 放入到项目的 src 目录下。 若将日志级别设置为 debug，则可以显示出所执行的 SQL 语句、参数值、对 DB 的影响条数等信息。若将级别设置为 trace，则还可显示出查询出的每条记录的每个字段名及值。 注意:若日志对象使用根日志对象 rootLogger，则会输出太多的信息。在 MyBatis 中，可以指定要输出日志的工作空间 namespace 的名字。此时，只会输出该 namespace 下执行的 SQL 的日志内容。 12##define a loggerlog4j.logger.test=debug,console 10. 运行结果 使用工具类由于每一次执行 SqlSession 的方法，均需首先获取到该对象。而 SqlSession 对象的获取又相对比较繁琐，所以，可以将获取 SqlSession 对象定义为一个工具类方法。 SqlSession 对象是通过 SqlSessionFactory 对象创建的。由于 SqlSessionFactory 类为重量级对象，且为线程安全的，所以可以将 SqlSessionFactory 对象定义为单例的。 1. 创建工具类1234567891011121314151617181920212223242526272829package com.huang.dao;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;public class MyBatisUtil &#123; private static SqlSessionFactory factory; public static SqlSession getSqlSession() &#123; try &#123; if (factory == null) &#123; //读取主配置文件 InputStream inputStream = Resources.getResourceAsStream("mybatis.xml"); //创建SqlSession工厂 factory = new SqlSessionFactoryBuilder().build(inputStream); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return factory.openSession(); &#125;&#125; 2. 修改 Dao 接口的实现类12345678910111213141516171819202122232425262728package com.huang.dao;import org.apache.ibatis.session.SqlSession;import com.huang.beans.Student;public class StudentDaoImpl implements IStudentDao &#123; private SqlSession sqlSession; @Override public void insertStu(Student student) &#123; try &#123; sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.insert("insertStudent",student); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) sqlSession.close(); &#125; &#125;&#125; 从属性文件中读取 DB 连接四要素为了方便对数据库连接的管理， DB 连接四要素数据一般都是存放在一个专门的属性文件中的。 MyBatis 主配置文件需要从这个属性文件中读取这些数据。 1. 定义属性文件在 src 下定义属性文件 jdbc.properties。 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.user=rootjdbc.password=123456 2. 修改主配置文件对主配置文件，第一，需要注册属性文件。第二，需要从属性文件中通过 key，将其 value 读取出来。 12&lt;!-- 注册属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; 主配置文件详解主配置文件名可以随意命名，其主要完成以下几个功能：（1）注册存放 DB 连接四要素的属性文件（2）注册实体类的全限定性类名的别名（3）配置 MyBatis 运行环境，即数据源与事务管理器（4）注册映射文件 注册 DB 连接四要素属性文件12&lt;!-- 注册DB连接四要素属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; 指定实体类全限定性类名的别名对于实体类的全限定性类名的别名指定方式，一般使用方式。这样做的好处是会将该包中所有实体类的简单类名指定为别名，写法简单方便。 12345&lt;!-- 定义类型别名 --&gt; &lt;typeAliases&gt; &lt;!-- 将指定包中所有类的简单类名当作其别名 --&gt; &lt;package name="com.huang.beans"/&gt; &lt;/typeAliases&gt; 不过，还有另外的指定方式：通过指定。 123&lt;typeAliases&gt; &lt;typeAlias type="com.huang.beans.Student" alias="Student"/&gt; &lt;/typeAliases&gt; type：全限定性类名 alias：别名 该方式的好处是，可以指定别名为简单类名以外的其它名称。当然，弊端是，必须逐个指定，比较繁琐。 另外，Mybatis 还提供了内置的类型别名： 基本类型： 别名 类型 别名 类型 int int integer int _short short _long long _double double _float float byte byte boolean boolean 常用包类型别名： 别名 类型 别名 类型 string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date object Object collection Collection list List arraylist ArrayList map Map hashmap HashMap iterator Iterator 配置 MyBatis 的运行环境配置 MyBatis 的运行环境，主要是配置数据源与事务管理器。 1. &lt;environments/&gt;标签12345678910&lt;!-- 指定默认运行环境 --&gt; &lt;environments default="onlineEM"&gt; &lt;!-- 项目上线环境 --&gt; &lt;environment id="onlineEM"&gt; &lt;/environment&gt; &lt;!-- 项目测试环境 --&gt; &lt;environment id="testEM"&gt; &lt;/environment&gt; &lt;/environments&gt; 在&lt;environments/&gt;中可包含多个运行环境&lt;environment/&gt;，但其 default 属性指定了当前 MyBatis 运行时所选择使用的环境。&lt;environment/&gt;的 id 属性为当前定义的运行环境的名称，可以任意命名。该名称会作为&lt;environments/&gt;的 default 属性的值出现。 2. &lt;transactionManager/&gt;标签12 &lt;!-- 使用jdbc事务管理 --&gt;&lt;transactionManager type="JDBC"/&gt; 该标签用于指定 MyBatis 所使用的事务管理器。 MyBatis 支持两种事务管理器类型： JDBC 与 MANAGED。 JDBC：使用 JDBC 的事务管理机制。即，通过 Connection 的 commit()方法提交，通过 rollback() 方法回滚。但默认情况下， MyBatis 将自动提交功能关闭了，改为了手动提交。即程序中需要显式的对事务进行提交或回滚。从日志的输出信息中可以看到。 MANAGED：由容器来管理事务的整个生命周期（如 Spring 容器）。 &lt;dataSource/&gt;标签该标签用于配置 MyBatis 使用的数据源类型与数据库连接基本属性。常见有类型有： UNPOOLED、 POOLED、 JDNI 等。 UNPOOLED ：不使用连接池。即每次请求，都会为其创建一个 DB 连接，使用完毕后，会马上将此连接关闭。 POOLED：使用数据库连接池来维护连接。 JNDI：数据源可以定义到应用的外部，通过 JNDI 容器获取数据库连接。 1234567&lt;!-- 数据库连接池 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt;&lt;/dataSource&gt; 若要从属性文件中读取 DB 连接四要素信息，则使用如下方式： 12345678&lt;!-- 数据库连接池 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.user&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt; 指定映射文件指定映射文件的方式有多种。但所有的方式，都是指定在&lt;mappers/&gt;标签中的。 &lt;mapper resource=””/&gt;指定映射文件若映射文件只有一个，则可直接使用如下形式： 1234&lt;!-- 注册映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="com/huang/dao/mapper.xml"/&gt; &lt;/mappers&gt; 若映射文件有多个，则可使用如下形式： 12345&lt;!-- 注册映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="com/huang/dao/mapper.xml"/&gt; &lt;mapper resource="com/huang/dao/mapper2.xml"/&gt; &lt;/mappers&gt; API 详解Dao 中需要通过 SqlSession 对象来操作 DB。而 SqlSession 对象的建，需要其工厂对象 SqlSessionFactory。 SqlSessionFactory 对象，需要通过其构建器对象 SqlSessionFactoryBuilder 的 build()方法，在加载了主配置文件的输入流对象后创建。 Resources 类Resources 类，顾名思义就是资源，用于读取资源文件。其有很多方法通过加载并解析资源文件，返回不同类型的 IO 流对象。 SqlSessionFactoryBuilder 类SqlSessionFactory 的创建，需要使用 SqlSessionFactoryBuilder 对象的 build()方法。由于 SqlSessionFactoryBuilder 对象在创建完工厂对象后，就完成了其历史使命，即可被销毁。所以，一般会将该 SqlSessionFactoryBuilder 对象创建为一个方法内的局部对象，方法结束，对象销毁。 SqlSessionFactory 接口SqlSessionFactory 接口对象是一个重量级对象（系统开销大的对象），是线程安全的， 所以一个应用只需要一个该对象即可。 创建 SqlSession 需要使用 SqlSessionFactory 接口的的 openSession()方法。 openSession(true)：创建一个有自动提交功能的 SqlSession openSession(false)：创建一个非自动提交功能的 SqlSession，需手动提交 openSession()：同 openSession(false) SqlSession 接口SqlSession 接口对象用于执行持久化操作。一个 SqlSession 对应着一次数据库会话，一次会话以 SqlSession 对象的创建开始，以 SqlSession 对象的关闭结束。 SqlSession 接口对象是线程不安全的，所以每次数据库会话结束前，需要马上调用其 close()方法，将其关闭。再次需要会话，再次创建。 而在关闭时会判断当前的 SqlSession 是否被提交：若没有被提交，则会执行回滚后关闭；若已被提交，则直接将 SqlSession 关闭。所以， SqlSession 无需手工回滚。]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库基础入门与实战]]></title>
    <url>%2F2019%2F07%2F28%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[常见数据库 关系型数据库：MySQL、Oracle、SQL Server、JDBC、DB2等。 非关系型数据库：Redis、MongoDB、NoSQL等。 关系型数据库主要是用来描述实体与实体之间的关系，实实在在存在的事物。例如：男生和女生、学生和班级、员工和部门。 非关系型数据库非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。(本章主要讲关系型数据库) MySQL数据库服务器MySQL数据库：数据库管理软件。 服务器：就是一台电脑，这台安装相关的服务器软件，这些软件监听不同的端口号，根据用户访问的端口号，提供不同的服务。 数据库：通常一个应用对应一个数据库。 MySQL的SQL语句 SQL：Structure Query Languages结构化查询语言 数据定义语言(DDL)：定义数据库，数据表的结构：create(创建)、drop(删除)、alter(修改) 数据操纵语言(DML)：主要是用来操作数据：insert(插入)、update(修改)、delete(删除) 数据控制语言(DCL)：定义访问权限，取消访问权限，安全设置 grant 数据查询语言(DQL)：select(查询) from子句 where子句 数据库的CRUD的操作前置知识： 登录数据库：mysql –uroot –proot 退出数据库：exit、quit、\q、Ctrl+c 退出当前命令行：\c 复制命令行的内容：标记-&gt;选择内容-&gt;回车，不用Ctrl+C 导出数据库文件： 进入MySQL的安装目录的bin目录，如：D:\Program Files (x86)\MySQL\MySQLServer5.0\bin 用cmd打开 输入命令:mysqldump –h localhost –u root –p 数据库名字&gt;导出路径 1mysqldump –h localhost –u root –p worker&gt;e:worker.sql 启动MySQL服务：net start mysql 关闭MySQL服务：net stop mysql 创建数据库:create database 数据库名字; 1create database test; 创建数据库的时候，指定字符集 create database 数据库的名字 character set 字符集; 1create database test character set utf8; create database 数据库的名字 character set 字符集 collate 校对规则; 1create database test character utf8 collate utf8_bin; 查看数据库：show create database 数据库名字; 查看所有数据库 1show databases; 注意：三个文件不可删information_schema 相关信息约束performance_schema 相关表现约束mysql 修改数据库的操作修改数据库的字符集 alter database 数据库的名字 character set 字符集 1alter database test character set gbk; 删除数据库drop database 数据库名字; 切换数据库(选中数据库)use 数据库名字; ###查看当前正在使用的数据库 1select database (); 表的CRUD操作### 创建表 12345create database 数据库名字 create table 表名( 列名 列的类型(长度) 约束, 列名2 列的类型(长度) 约束 ); 列的类型 列的约束主键约束：primary key唯一约束：unique非空约束：not null 123456create table student(sid int primary key,sname varchar(10),sex int,age int); 查看表查看所有的表 1show tables; 查看表的创建过程 show create table 表名; 1show create table student; 查看表的结构 1desc student; 修改表添加(add)，修改列(modify)，修改列名(change)，删除列(drop)，修改表名(rename)，修改表的字符集 添加列(add) alter table 表名 add 列名 列的类型 列的约束 1alter table student add score int not null; 修改列(modify) 1alter table student modify sex varchar(2); 修改列名(change) 1alter table student change sex gender varchar(2); 删除列(drop) 1alter table student drop score; 修改表名(rename) 1rename table student to students; 修改表的字符集 1alter table student character set gbk; 删除表1drop table students; 移动列的顺序alter table 表名 modify 字段名 字段类型 after 字段alter table student modify sex int(11) after sname;(移动到sname后面)alter table student modify sex int(11) first;(移动到最前面) SQL完成对表中数据的CRUD的操作插入数据insert into 表名(列名1,列名2,列名3) values(值1,值2,值3); 1insert into student(sid,sname,sex,age) values(1,'zhangsan',1,22); 简单写法(插入部分列列名不可省略) 1insert into student values(2, 'zhangsan',1,22); 批量插入 1234insert into student values(3, 'zhangsan',1,22),(4, 'zhangsan',1,22),(5, 'zhangsan',1,22); 查看表中数据1select * from student; 解决表中插入数据中文乱码的问题1、 设置数据库的表字符编码为jbk；2、 停止MySQL服务(net stop mysql)；3、 找到MySQL的安装路径，找到my.ini文件，把default-character-set=utf8修改为default-character-set=gbk；4、 启动MySQL服务(net start mysql)，重新登录数据库。 删除记录delete from 表名 [where 条件] 1delete from student where sid=5; 把表中数据全部删除 1delete from student; 问题：delete删除数据和truncate删除数据有什么差别？delete:DML一条一条删除表中的数据truncate:DDL先删除表再重建表关于哪条执行效率高，具体要看表中的数据如果数据比较少，delete比较高效如果数据比较多，truncate比较高效 更新表记录update 表名 set 列名=列的值，列名2=列名2的值 [where 条件]如果参数是字符串、日期 要加上单引号 1update student set sname= '张三' where sid=5; 1update student set sname= '李四' ,sex='1'; 查询记录select [distinct] [ * ] [列名,列名2] from 表名 [where 条件] 说明：distinct：去除重复的数据select：选择显示哪些列的内容 简单查询查询所有 select * from 表名 查询姓名和性别 1select sname,sex from student; 别名查询，as的关键字，as关键字可以省略 表别名select s.sname,s.sex from student as s;(主要用在多表查询) 列别名select sname as 姓名,age as 年龄 from student; 去掉重复的值 1select age from student; 1select distinct age from student; 说明：select： 运算查询：仅在查询结果上做了运算 1select * ,age*2 from student; 1select * ,age*2 as 两倍年龄 from student; 条件查询[where关键字] 查询年龄大于20的学生 1select * from student where age &gt; 20; where 后的条件写法 说明：关系运算符：&gt; &gt;= &lt; &lt;= != &lt;&gt;&lt;&gt; 不等于 标准SQL语法!= 不等于 非标准SQL语法 查询学生年龄不等于20的所有学生 1select * from student where age &lt;&gt; 20; 1select * from student where age != 20; 查询年龄在20到30之间 1select * from student where age &gt; 20 and age &lt; 30; 使用 between… and… 查询 1select * from student where age between 20 and 30; 逻辑运算：and , or , not 查询年龄小于15 或者年龄大于20 1select * from student where age &lt; 15 or age &gt; 20; 复杂查询 模糊查询 —like： _ :代表的是一个字符% :代表的是多个字符 查询姓名中带有 张 的所有学生 ‘%张%’ 1select * from student where sname like '%张%'; 查询第二名字是三的所有学生 ‘_张%’ 1select * from student where sname like '_张%'; —in 在某个范围获得值 查询年龄在20,21,22里面的所有学生 1select * from student where age in (20,21,22); 排序查询 order by 关键字asc :ascend 升序(默认的排序方式)desc:descend 降序 查询所有学生的年龄，按照年龄进行排序 1select * from student order by age; 查询所有学生的年龄，按照年龄进行降序排序 1select * from student order by age desc; 查询学生姓名有 张 的学生，按年龄排序 查询学生姓名有 张 的所有学生 1select * from student where sname like '%张%'; 进行排序得出结果 1select * from student where sname like '%张%' order by age asc; 聚合函数sum(): 求和avg(): 求平均值count(): 统计数据max(): 最大值min(): 最小值 获得所有商品价格的总和 select sum(价格名称) from 表名; 1select sum(price) from product; 获得所商品的平均价格 1select avg(price) from product; 获得所有商品的个数 1select count(*) from product; 注意：where 条件后面不能接聚合函数 查出商品价格大于平均的所有商品 查出所有商品 1select from product; 大于平均价格 1select avg(price) from product; 如平均价格为100 1select * from product where price &gt; 100; 或者(子查询) 1select * from product where price &gt; (select avg(price) from product); 分组group by 根据cno字段分组，分组后统计商品的个数 1select cno,count(*) from product group by cno; 根据cno分组，分组统计每组商品的平均价格，并且商品平均价格 &gt; 60 123select cno,avg(price)from product group by cnohaving avg(price) &gt; 60; 说明：having 关键字 可以接聚合函数 出现在分组之后where 关键字 它是不可以接聚合函数 出现在在分组之前 编写顺序 S..F..W..G..H..O 1select..from..where..group by..having..order by 执行顺序 F..W..G..H..S..O 1from..where..group by..having..select..order by SQL多表操作SQL 会创建多表及多表的关系 需求:分类表和商品表之间是不是有关系? 如果有关系,在数据库中如何表示这种关系 12345create table category(cid int primary key auto_increment,cname varchar(10), cdesc varchar(31)); 12345insert into category values(null,'手机数码','电子产品,黑马生产');insert into category values(null,'鞋靴箱包','江南皮鞋厂倾情打造');insert into category values(null,'香烟酒水','黄鹤楼,茅台,二锅头');insert into category values(null,'酸奶饼干','娃哈哈,蒙牛酸酸乳');insert into category values(null,'馋嘴零食','瓜子花生,八宝粥,辣条'); 1select * from category; 1select cname,cdesc from category; 所有商品1.商品ID2.商品名称3.商品的价格4.生产日期5.商品分类ID 商品和商品分类 : 所属关系 1234567create table product(pid int primary key auto_increment,pname varchar(10),price double,pdate timestamp,cno int); 12345678insert into product values(null,'小米mix4',998,null,1);insert into product values(null,'锤子',2888,null,1);insert into product values(null,'阿迪王',99,null,2);insert into product values(null,'老村长',88,null,3);insert into product values(null,'劲酒',35,null,3);insert into product values(null,'小熊饼干',1,null,4);insert into product values(null,'卫龙辣条',1,null,5);insert into product values(null,'旺旺大饼',1,null,5); 多表之间的关系如何来维护外键约束: foreign key 给product中的这个cno 添加一个外键约束 1alter table product add foreign key(cno) references category(cid); 建数据库原则通常情况下,一个项目/应用建一个数据库 多表之间的建表原则 一对多 : 商品和分类建表原则: 在多的一方添加一个外键,指向一的一方的主键 多对多: 老师和学生, 学生和课程建表原则: 建立一张中间表,将多对多的关系,拆分成一对多的关系,中间表至少要有两个外键,分别指向原来的那两张表 一对一: 班级和班长, 公民和身份证, 国家和国旗 建表原则:将一对一的情况,当作是一对多情况处理,在任意一张表添加一个外键,并且这个外键要唯一,指向另外一张表直接将两张表合并成一张表将两张表的主键建立起连接,让两张表里面主键相等实际用途: 用的不是很多.(拆表操作)相亲网站:个人信息 : 姓名,性别,年龄,身高,体重,三围,兴趣爱好,(年收入,特长,学历, 职业, 择偶目标,要求)拆表操作 : 将个人的常用信息和不常用信息,减少表的臃肿, 网上商城表实例的分析:用户购物流程(用户表、订单表、商品表、商品分类表) 用户表 (用户的ID,用户名,密码,手机) 123456create table user( uid int primary key auto_increment, username varchar(31), password varchar(31), phone varchar(11) ); 1insert into user values(1,'zhangsan','123','13811118888'); 订单表 (订单编号,总价,订单时间 ,地址,外键用户的ID) 12345678create table orders( oid int primary key auto_increment, sum int not null, otime timestamp, address varchar(100), uno int, foreign key(uno) references user(uid) ); 12insert into orders values(1,200,null,'黑马前台旁边小黑屋',1);insert into orders values(2,250,null,'黑马后台旁边1702',1); 商品表 (商品ID, 商品名称,商品价格,外键cno) 1234567create table product( pid int primary key auto_increment, pname varchar(10), price double, cno int, foreign key(cno) references category(cid) ); 12345678insert into product values(null,'小米mix4',998,1);insert into product values(null,'锤子',2888,1);insert into product values(null,'阿迪王',99,2);insert into product values(null,'老村长',88,3);insert into product values(null,'劲酒',35,3);insert into product values(null,'小熊饼干',1,4);insert into product values(null,'卫龙辣条',1,5);insert into product values(null,'旺旺大饼',1,5); 订单项: 中间表(订单ID,商品ID,商品数量,订单项总价) 12345678create table orderitem( ono int, pno int, foreign key(ono) references orders(oid), foreign key(pno) references product(pid), ocount int, subsum double); 给1号订单添加商品 200块钱的商品 12insert into orderitem values(1,7,100,100);insert into orderitem values(1,8,101,100); 给2号订单添加商品 250块钱的商品 () 12insert into orderitem values(2,5,1,35);insert into orderitem values(2,3,3,99); 商品分类表(分类ID,分类名称,分类描述) 12345create table category( cid int primary key auto_increment, cname varchar(15), cdesc varchar(100) ); 12345insert into category values(null,'手机数码','电子产品,黑马生产');insert into category values(null,'鞋靴箱包','江南皮鞋厂倾情打造');insert into category values(null,'香烟酒水','黄鹤楼,茅台,二锅头');insert into category values(null,'酸奶饼干','娃哈哈,蒙牛酸酸乳');insert into category values(null,'馋嘴零食','瓜子花生,八宝粥,辣条'); 多表之间的关系如何维护外键约束 : foreign key 添加一个外键: 1alter table product add foreign key(cno) references category(cid); 删除的时候, 先删除外键关联的所有数据,再才能删除分类的数据 建表原则一对多:建表原则: 在多的一方增加一个外键,指向一的一方 多对多:建表原则: 将多对多转成一对多的关系,创建一张中间表 一对一: 不常用, 拆表操作建表原则: 将两张表合并成一张表将两张表的主键建立起关系将一对一的关系当作一对多的关系去处理 主键约束:默认就是不能为空, 唯一外键都是指向另外一张表的主键主键一张表只能有一个 唯一约束列面的内容, 必须是唯一, 不能出现重复情况, 为空唯一约束不可以作为其它表的外键可以有多个唯一约束 一对多 : 建表原则: 在多的一方添加一个外键,指向一的一方 多对多: 建表原则: 拆成一对多 创建一张中间表, 至少要有两个外键, 指向原来的表 一对一: 建表原则: 合并一张表, 将主键建立关系 , 将它当作一对多的情况来处理 交叉连接查询(笛卡尔积)1SELECT * FROM product; 1SELECT * FROM category; 笛卡尔积 ,查出来是两张表的乘积 ,查出来的结果没有意义 1SELECT * FROM product,category; 过滤出有意义的数据1SELECT * FROM product,category WHERE cno=cid; 1SELECT * FROM product AS p,category AS c WHERE p.cno=c.cid; 1SELECT * FROM product p,category c WHERE p.cno=c.cid; 数据准备 1INSERT INTO product VALUES(NULL,'耐克帝',10,NULL); 内连接查询隐式内链接 1SELECT * FROM product p,category c WHERE p.cno=c.cid; 显示内链接 1SELECT * FROM product p INNER JOIN category c ON p.cno=c.cid; 区别: 隐式内链接: 在查询出结果的基础上去做的WHERE条件过滤 显示内链接: 带着条件去查询结果, 执行效率要高 左外连接 左外连接,会将左表中的所有数据都查询出来, 如果右表中没有对应的数据,用NULL代替 1SELECT * FROM product p LEFT OUTER JOIN category c ON p.cno=c.cid; 准备工作 1INSERT INTO category VALUES(100,'电脑办公','电脑叉叉差'); 右外连接: 会将右表所有数据都查询出来, 如果左表没有对应数据的话, 用NULL代替 1SELECT * FROM product p RIGHT OUTER JOIN category c ON p.cno=c.cid; 分页查询 每页数据数据3起始索引从0第1页: 0第2页: 3起始索引: index 代表显示第几页 页数从1开始每页显示3条数据 1startIndex = (index-1)*3 第一个参数是索引第二个参数显示的个数 12select * from product limit 0,3;select * from product limit 3,3; 子查询查询出(商品名称,商品分类名称)信息查询分类名称为手机数码的所有商品 查询分类名为手机数码的ID 1select * from category where cname ='手机数码'; 得出ID为1的结果 1SELECT * FROM product WHERE cno = (SELECT cid FROM category WHERE cname='手机数码'); 查询出(商品名称,商品分类名称)信息 左连接 1SELECT p.pname,c.cname FROM product p LEFT OUTER JOIN category c ON p.cno = c.cid; 子查询 1SELECT pname ,(SELECT cname FROM category c WHERE p.cno=c.cid ) AS 商品分类名称 FROM product p; 总结下面这张表是本章的主要内容]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM入门基础知识]]></title>
    <url>%2F2019%2F07%2F28%2FSSM%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[系统架构所谓系统架构是指，整合应用系统程序大的结构。经常提到的系统结构有两种：三层架构与 MVC。这两种结构既有区别，又有联系。但这两种结构的使用，均是为了降低系统模块间的耦合度。 三层架构三层架构是指：视图层 View、服务层 Service 与持久层 Dao。 它们分别完成不同的功能。 View 层：用于接收用户提交请求的代码在这里编写。 Service 层：系统的业务逻辑主要在这里完成。 Dao 层：直接操作数据库的代码，对数据库进行增删改查。 关系Service 层是建立在 Dao 层之上的，建立了 Dao 层后才可以建立 Service 层，而 Service 层又是在 Controller 层之下的，因而 Service 层应该既调用 Dao 层的接口，又要提供接口给 Controller 层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个 Service 接口，每个接口分别封装各自的业务处理方法。 作用为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准（接口）是相同的，服务提供者（实现类）可以更换。这就实现了层间解耦合。 耦合性耦合性也叫耦合度，是程序结构中各个模块之间相互关联的度量，它取决于各个模块之间接口的复杂程度调用模块的方式以及哪些信息通过接口。关联性越高，耦合度越高，后期维护成本就越大，因此在开发过程中要尽量避免代码耦合度。 下面用一张图来表示三层架构的关系 MVCMVC，即 Model 模型、 View 视图，及 Controller 控制器。 View： 视图，为用户提供使用界面，与用户直接进行交互。 Model： 模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载 Bean，一类称为业务处理 Bean。所谓数据承载 Bean 是指实体类，专门用户承载业务数据的，如 Student、 User 等。而业务处理 Bean 则是指 Service 或 Dao 对象，专门用于处理用户提交请求的。 Controller： 控制器，用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应。 MVC 架构程序的工作流程： 用户通过 View 页面向服务端提出请求，可以是表单请求、超链接请求、 Ajax 请求等。 服务端 Controller 控制器接收到请求后对请求进行解析，找到相应的 Model 对用户请求进行处理。 Model 处理后，将处理结果再交给 Controller。 Controller 在接到处理结果后，根据处理结果找到要作为向客户端发回的响应 View 页面。页面经渲染（数据填充）后，再发送给客户端。 MVC与三层架构的关系MVC与三层架构很相似，但它们不一样。 相同点： 分层、解耦 相同的设计理念，把视图设计与数据持久化进行分离，从而降低耦合性，易于扩展，提高团队开发效率。 不同点： 三层是基于业务逻辑来分的，而mMVC是基于页面来分的。 MVC模式是一种复合设计模式，一种解决方案。 三层是种软件架构，通过接口实现编程。 三层模式是体系结构模式，MVC是设计模式。 三层模式又可归于部署模式，MVC可归于表示模式。 如图表示它们二者的关系 SSM与三层架构的关系SSM，即 SpringMVC、 Spring 与 MyBatis 三个框架。它们在三层架构中所处的位置是不同的，即它们在三层架构中的功能各不相同，各司其职。 SpringMVC：作为 View 层的实现者，完成用户的请求接收功能。SpringMVC 的 Controller 作为整个应用的控制器，完成用户请求的转发及对用户的响应。 MyBatis：作为 Dao 层的实现者，完成对数据库的增、删、改、查功能。 Spring：以整个应用大管家的身份出现。整个应用中所有 Bean 的生命周期行为，均由Spring 来管理。即整个应用中所有对象的创建、初始化、销毁，及对象间关联关系的维护，均由 Spring 进行管理。 环境设置解决乱码问题，可以在端口后面加上 URIEncoding=”UTF-8”，把8080改为80访问时可以不用输入端口号 代理模式 理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。——百度百科《代理模式》 换句话说， 使用代理对象，是为了在不修改目标对象的基础上， 增强主业务逻辑。客户类真正的想要访问的对象是目标对象，但客户类真正可以访问的对象是代理对象。客户类对目标对象的访问是通过访问代理对象来实现的。当然，代理类与目标类要实现同一个接口。 对于代理模式，需要注意以下几点： 代理类和目标类要实现同一个接口，即业务接口。 客户类对目标类的调用均是通过代理类完成的。 代理类的执行既执行了对目标类的增强业务逻辑，又调用了目标类的主业务逻辑。 根据代理关系建立的时间不同，可以将代理分为两类：静态代理与动态代理。 静态代理静态代理是指，代理类在程序运行前就已经定义好，其与目标类的关系在程序运行前就已经确立。(需要定义代理类) 代理实现与解析静态代理实现转账： （1）定义业务接口 IAccountService，其中含有抽象方法 transfer()。 123456package com.huang.service;public interface IAccountService &#123; //主业务逻辑:转账 void transfer();&#125; （2）定义目标类 AccountServiceImpl，该类实现了业务接口。在对接口方法的实现上，只实现主业务逻辑转账即可。这个方法称为目标方法。 1234567891011package com.huang.service;public class AccountServiceImpl implements IAccountService &#123; //目标方法 @Override public void transfer() &#123; System.out.println("调用Dao层，完成转账业务。"); &#125;&#125; （3）定义代理类 AccountServiceImplProxy。这个类要实现 IAccount 接口。并且该代理类要将接口对象作为一个成员变量，还要定义一个带参的构造器，这个参数为接口对象。目的是，将目标对象引入代理类，以便代理类调用目标类的目标法。 123456789101112131415161718192021222324252627282930package com.huang.proxy;import com.huang.service.IAccountService;import com.huang.service.AccountServiceImpl;//代理类public class AccountServiceImplProxy implements IAccountService &#123; //声明业务接口对象 private IAccountService target; public AccountServiceImplProxy() &#123; &#125; //业务接口对象作为构造器参数，用于接受目标对象 public AccountServiceImplProxy(IAccountService target) &#123; this.target = target; &#125; /** * 代理方法，实现对目标方法的功能增强 */ @Override public void transfer() &#123; //此处为对目标类的增强 System.out.println("对转账进行身份认证！"); target.transfer(); &#125;&#125; （4）定义客户类 Client。在客户类中首先要创建目标对象，再创建代理对象，并使用标对象对其进行初始化。然后由代理对象来调用执行业务方法。 12345678910111213141516171819package com.huang.test;import com.huang.proxy.AccountServiceImplProxy;import com.huang.service.AccountServiceImpl;import com.huang.service.IAccountService;public class MyTest &#123; public static void main(String[] args) &#123; //创建目标对象 IAccountService target = new AccountServiceImpl(); //创建代理对象，并使用目标对象来初始化它 IAccountService service = new AccountServiceImplProxy(target); //此时执行的内容，就是对目标对象增加过的内容 service.transfer(); &#125;&#125; 运行结果如下 JDK 动态代理动态代理是指， 程序在整个运行过程中根本就不存在目标类的代理类，目标对象的代理对象只是由代理生成工具（如代理工厂类）在程序运行时由 JVM 根据反射等机制动态生成的。代理对象与目标对象的代理关系在程序运行时才确立。 对比静态代理，静态代理是指在程序运行前就已经定义好了目标类的代理类。代理类与目标类的代理关系在程序运行之前就确立了。 动态代理的实现方式常用的有两种：使用 JDK 的 Proxy，与通过 CGLIB 生成代理。 动态代理的实现方式常用的有两种：使用 JDK 的 Proxy，与通过 CGLIB 生成代理。 12345public static newProxyInstance ( ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler handler)loader：目标类的类加载器，通过目标对象的反射可获取interfaces：目标类实现的接口数组，通过目标对象的反射可获取handler：业务增强逻辑，需要再定义。 InvocationHandler 是个接口，其具体介绍如下：实现了 InvocationHandler 接口的类用于加强目标类的主业务逻辑。这个接口中有一个方法 invoke()，具体加强的代码逻辑就是定义在该方法中的。程序调用主业务逻辑时，会自动调用 invoke()方法。 invoke()方法的介绍如下： 1234public Object invoke ( Object proxy, Method method, Object[] args)proxy：代表生成的代理对象method：代表目标方法args：代表目标方法的参数 由于该方法是由代理对象自动调用的，所以这三个参数的值不用程序员给出。 第二个参数为 Method 类对象，该类有一个方法也叫 invoke()，可以调用目标类的目标方法。这两个 invoke()方法，虽然同名，但无关。 123public Object invoke ( Object obj, Object... args)obj：表示目标对象args：表示目标方法参数，就是其上一层 invoke 方法的第三个参数 该方法的作用是：调用执行 obj 对象所属类的方法，这个方法由其调用者 Method 对象确定。在代码中，一般的写法为 1method.invoke(target, args); 其中， method 为上一层 invoke 方法的第二个参数。这样，即可调用了目标类的目标方法。 代理实现与解析动态代理实现转账： （1）定义业务接口 IAccounSevice，其中含有抽象方法 transfer()。 （2）定义目标类 AccountServiceImpl，该类实现了业务接口。在对接口方法的实现上，只实现主业务逻辑。这个方法称为目标方法。 以上两步与静态代理类第一二步中代码相同。 （3）定义主业务增强逻辑类 MyExtension，该类需实现接口 InvocationHandler。在该类中定义一个 Object 类型的成员变量，还要定义一个带参的构造器，这个参数为 Object 对象。目的是，将目标对象引入该类，以便通过反射调用目标方法。 1234567891011121314151617181920212223242526272829package com.huang.proxy;import com.huang.service.IAccountService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;//代理类public class MyExtension implements InvocationHandler &#123; //声明业务接口对象 private IAccountService target; public MyExtension() &#123; &#125; //业务接口对象作为构造器参数，用于接受目标对象 public MyExtension(IAccountService target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //增加主业务逻辑代码 System.out.println("对转账用户进行身份认证"); //无论业务方法有无参数，有无返回值，下面的写法均可兼顾 return method.invoke(target, args); &#125;&#125; （4）定义客户类 Client。客户类中主要语句有三句：A、定义目标对象。在生成代理对象时会需要目标对象对其初始化。B、定义代理对象。需要注意的是，代理类 Proxy 会通过反射机制，自动实现 IAccount接口。代理对象需要使用目标对象对其进行初始化。C、代理对象调用主业务方法。 123456789101112131415161718192021222324package com.huang.test;import java.lang.reflect.Proxy;import com.huang.proxy.MyExtension;import com.huang.service.AccountServiceImpl;import com.huang.service.IAccountService;public class MyTest &#123; public static void main(String[] args) &#123; //创建目标对象 IAccountService target = new AccountServiceImpl(); //创建代理对象，并使用目标对象来初始化它 IAccountService service = (IAccountService) Proxy.newProxyInstance( target.getClass().getClassLoader(), //获取目标对象类加载器 target.getClass().getInterfaces(), //获取目标类实现的所有接口 new MyExtension(target)); //增强业务逻辑 //此时执行的内容，就是对目标对象增加过的内容 service.transfer(); &#125;&#125; CGLIB 动态代理概念使用 JDK 的 Proxy 实现代理，要求目标类与代理类实现相同的接口。若目标类不存在接口， 则无法使用该方式实现。 但对于无接口的类，要为其创建动态代理，就要使用 CGLIB 来实现。 CGLIB 代理的生成原理是生成目标类的子类，而子类是增强过的，这个子类对象就是代理对象。 所以， 使用CGLIB 生成动态代理，要求目标类必须能够被继承，即不能是 final 的类。 CGLIB(Code Generation Library)是一个开源项目，是一个强大的、高性能的、高质量的代码生成类库。它可以在运行期扩展和增强 Java 类。 Hibernate 用它来实现持久对象的字节码的动态生成， Spring 用它来实现 AOP 编程。——百度百科《CGLIB》 CGLIB 包的底层是通过使用一个小而快的字节码处理框架 ASM(Java 字节码操控框架)，来转换字节码并生成新的类。 CGLIB 是通过对字节码进行增强来生成代理的。 代理实现与解析Setp1：导入 CGLIB 的 Jar 包： cglib-full.jar。 Step2：定义目标类。 12345678910111213141516package com.huang.service;//目标类public class SomeService &#123; //目标方法 public String doFirst() &#123; System.out.println("执行了doFirst()方法"); return "abcde"; &#125; //目标方法 public void doSecond() &#123; System.out.println("执行了doSecond()方法"); &#125;&#125; Step3：创建代理类的工厂。该类要实现 MethodInterceptor 接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.huang.factory;import java.lang.reflect.Method;import com.huang.service.SomeService;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;//代理类public class MyCglibFactory implements MethodInterceptor &#123; private SomeService target; public MyCglibFactory() &#123; target = new SomeService(); &#125; public SomeService myCglibCreator() &#123; // 创建增强器对象 Enhancer enhancer = new Enhancer(); // 指定目标类，即父类 enhancer.setSuperclass(SomeService.class); // 设置回调接口对象 enhancer.setCallback(this); return (SomeService) enhancer.create(); &#125; // 回调方法 @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; // 调用目标方法 Object result = method.invoke(target, args); if (result != null) &#123; result = ((String) result).toUpperCase(); &#125; return result; &#125;&#125; Step4：创建测试类。 1234567891011121314151617package com.huang.test;import java.lang.reflect.Proxy;import com.huang.service.SomeService;import com.huang.factory.MyCglibFactory;public class MyTest &#123; public static void main(String[] args) &#123; SomeService service = new MyCglibFactory().myCglibCreator(); String result = service.doFirst(); System.out.println("result = " + result); service.doSecond(); &#125;&#125; 运行结果如下 方法回调设计模式在 Java 中，就是类 A 调用类 B 中的某个方法 b，然后类 B 又在某个时候反过来调用类 A中的某个方法 a，对于 A 来说，这个 a 方法便叫做回调方法。Java 的接口提供了一种很好的方式来实现方法回调。这个方式就是定义一个简单的接口，在接口之中定义一个我们希望回调的方法。 这个接口称为回调接口。 在前面的例子中，我们定义的 AccountServiceCglibProxyFactory 类就相当于前面所说的 A类，而 Enhancer 类则是 B 类。 A 类中调用了 Enhancer 类 setCallback(this)方法，并将回调对象 this 作为实参传递给了 Enhancer 类。 Enhancer 类在后续执行过程中，会调用 A 类中的 intercept()方法，这个 intercept()方法就是回调方法。 适配器模式适配器模式的定义是， Convert the interface of a class into another interface clients expect，将某个类的接口转换为接口客户所需的类型。 换句话说， 适配器模式解决的问题是， 使得原本由于接口不兼容而不能一起工作、不能统一管理的那些类可以在一起工作、可以进行统一管理。 举个例子： 需求：厨师的工作是 cook()，程序员的工作是 program()，司机的工作是 drive()，教师的工作是 teach()，不同的工种，其具体工作内容不同。现在程序要将这些（例如有 30 个不同工种）不同工种的工作内容全部输出。 解决方案一：逐个访问每个工种对象的相应工作方法。无法循环遍历，无法统一管理。解决方案二：使用适配器设计模式，将这些不兼容的具体工作转换为一个统一的工作，实现循环遍历。 基本元素定义这里举个适配器模式的例子：这里有厨师接口 ICooker、程序员接口 IProgrammer，分别用于定义他们各自工种的具体工作。然后又定义了全聚德的厨师 QjdCooker、京东的程序员 JdProgrammer。这些不同的工种所做的工作都各自是不同的，无法进行统一管理，协同工作。 所以，此时就需要定义一个员工适配器接口 IWorkerAdapter，用于将这些不同的工种进行统一管理。 不使用适配器模式若不使用适配器模式，则调用者需要定义出所有的工种对象，然后逐个工种对象的工作方法进行调用。有 30 个工种，就应调用 30 个工作方法。很麻烦。 修改代码如下： （1）定义 IWorkerAdapter 1234567package com.huang.adapters;public interface IWorkerAdapter &#123; //为了兼顾所有工种员工，这里的参数必须为Object类型 String work(Object worker);&#125; （2）定义 WorkerAdapter 1234567891011121314151617181920212223package com.huang.adapters.impl;import com.huang.adapters.IWorkerAdapter;import com.huang.worker.ICooker;import com.huang.worker.IProgrammer;//适配器类public class WorkerAdapter implements IWorkerAdapter &#123; @Override public String work(Object worker) &#123; String workContent = ""; //若传来的对象是厨师，则其调用其cook()方法 if (worker instanceof ICooker) &#123; workContent = ((ICooker)worker).cook(); &#125;else if (worker instanceof IProgrammer) &#123; workContent = ((IProgrammer)worker).program(); &#125; return workContent; &#125;&#125; （3）定义测试类 12345678910111213141516171819202122232425package com.huang.test;import com.huang.adapters.IWorkerAdapter;import com.huang.adapters.impl.WorkerAdapter;import com.huang.worker.ICooker;import com.huang.worker.IProgrammer;import com.huang.worker.impl.GjProgrammer;import com.huang.worker.impl.QjdCooker;public class MyTest &#123; public static void main(String[] args) &#123; ICooker qjdCooker = new QjdCooker(); IProgrammer gjProgrammer = new GjProgrammer(); Object[] workers = &#123;qjdCooker,gjProgrammer&#125;; // 创建适配器对象 IWorkerAdapter adapter = new WorkerAdapter(); // 循环遍历每个工种对象，让每个工种对象在适配器中逐个进行匹配 for (Object worker : workers) &#123; String workContent = adapter.work(worker); System.out.println(workContent); &#125; &#125;&#125; 为每个工种都定义一个适配器为每一个工种定义一个适配器，其程序结构如下： 代码如下： （1）修改 IWorkerAdapter 12345678910package com.huang.adapters;public interface IWorkerAdapter &#123; //为了兼顾所有工种员工，这里的参数必须为Object类型 String work(Object worker); //判断当前适配器是否支持指定的工种对象 boolean supports(Object worker);&#125; （2）定义 CookerAdapter 12345678910111213141516171819package com.huang.adapters.impl;import com.huang.adapters.IWorkerAdapter;import com.huang.worker.ICooker;import com.huang.worker.IProgrammer;public class CookerAdapter implements IWorkerAdapter &#123; @Override public String work(Object worker) &#123; return ((ICooker)worker).cook(); &#125; @Override public boolean supports(Object worker) &#123; return (worker instanceof ICooker); &#125;&#125; （3）定义 ProgrammerAdapter 123456789101112131415161718package com.huang.adapters.impl;import com.huang.adapters.IWorkerAdapter;import com.huang.worker.IProgrammer;public class ProgrammerAdappter implements IWorkerAdapter &#123; @Override public String work(Object worker) &#123; return ((IProgrammer)worker).program(); &#125; @Override public boolean supports(Object worker) &#123; return ((worker instanceof IProgrammer)); &#125;&#125; （4）定义测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.huang.test;import java.util.ArrayList;import java.util.List;import com.huang.adapters.IWorkerAdapter;import com.huang.adapters.impl.CookerAdapter;import com.huang.adapters.impl.ProgrammerAdappter;import com.huang.worker.ICooker;import com.huang.worker.IProgrammer;import com.huang.worker.impl.GjProgrammer;import com.huang.worker.impl.QjdCooker;public class MyTest &#123; public static void main(String[] args) &#123; ICooker qjdCooker = new QjdCooker(); IProgrammer gjProgrammer = new GjProgrammer(); Object[] workers = &#123;qjdCooker,gjProgrammer&#125;; // 循环遍历每个工种对象，让每个工种对象在适配器中逐个进行匹配 for (Object worker : workers) &#123; IWorkerAdapter adapter = getAdapter(worker); System.out.println(adapter.work(worker)); &#125; &#125; //根据worker获取相应的适配器 private static IWorkerAdapter getAdapter(Object worker) &#123; List&lt;IWorkerAdapter&gt; adapters = getAllAdapters(); for (IWorkerAdapter adapter : adapters) &#123; if (adapter.supports(worker)) &#123; return adapter; &#125; &#125; return null; &#125; // 获取所有的适配器 private static List&lt;IWorkerAdapter&gt; getAllAdapters() &#123; List&lt;IWorkerAdapter&gt; adapters = new ArrayList&lt;&gt;(); adapters.add(new CookerAdapter()); adapters.add(new ProgrammerAdappter()); return adapters; &#125;&#125; 缺省适配器模式缺省适配器模式是由适配器模式简化而来， 省略了适配器模式中目标接口， 也就是源接口和目标接口相同， 源接口为接口， 目标接口为类。 典型的缺省适配器模式是 JavaEE 规范中的 Servlet 接口与 GenericServlet 抽象类。Servlet 接口中包含五个抽象方法，而其中的 service()方法才是用于实现业务逻辑的、必须要实现的方法，另外四个方法一般都是空实现，或简单实现。 GenericServlet 抽象类实现了 Servlet 接口的 service()方法以外的另外四个方法，所以自定义的 Servlet 只需要继承 GenericServlet 抽象类，实现 service()方法即可。无需再实现 Servlet 接口了。 模板方法设计模式在现实生活中，完成某件事情是需要 n 多个固定步骤的。如“在淘宝网进行购物”这件事情的完成一般需要三个步骤：登录网站、挑选商品(抽象方法)、 付款。但对于登录网站与付款这两步，每个人几乎都是相同的操作。但不同的地方是，每个人所挑选的商品是不同的。 在软件开发过程中同样存在这样的情况。某类的某个方法的实现，需要几个固定步骤。在这些固定步骤中，对于该类的不同对象，有些步骤的实现是固定不的，有些步骤的实现是大相径庭的，有些步骤的实现是可变可不变的。对于这种情况，就适合使用模板方法设计模式编程。 模板方法设计模式的定义是：定义一个操作中某种算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类在不改变一个算法结构的前提下，对某些步骤实现个性化定义。 模板方法程序构成在模板方法设计模式中，存在一个父类。其中包含两类方法：模板方法与步骤方法。 模板方法：即实现某种算法的方法步骤。而这些步骤都是调用的步骤方法完的。 步骤方法：即完成模板方法的每个阶段性方法。每个步骤方法完成某一特定的、完成总算法的一部分功能。 步骤方法有三种类型：抽象方法、最终方法与钩子方法。 抽象方法：是要求子类必须实现的方法，是完成模板方法的算法步骤中必须由子类完成的个性化定义。 最终方法：是子类不能重写的方法，是若要完成模板方法的算法步骤，对于所有子类执行都一样的步骤。 钩子方法：是父类给出了默认实现，但子类也可以重写的方法。 程序举例模拟“淘宝购物”，创建 templateMethod 工程，代码如下： （1）定义父类 123456789101112131415161718192021222324252627package com.huang.service;public abstract class Shopping &#123; //模板方法 public void buyGoods() &#123; userLogin(); //用户登录 buy(); //挑选商品 pay(); //付款 &#125; //子类不能重写的方法 public final void userLogin() &#123; System.out.println("用户登录"); &#125; //子类必须实现 public abstract void buy(); //钩子方法，子类可以重写 public void pay() &#123; System.out.println("使用银联支付"); &#125;&#125; （2）定义子类 12345678910package com.huang.service;public class ShoesShopping extends Shopping &#123; @Override public void buy() &#123; System.out.println("购买鸿星尔克运动鞋"); &#125;&#125; 123456789101112131415package com.huang.service;public class ClothesShopping extends Shopping &#123; @Override public void buy() &#123; System.out.println("购买七匹狼男装"); &#125; @Override public void pay() &#123; System.out.println("使用支付宝付款"); &#125;&#125; （3）定义测试类 123456789101112131415161718package com.huang.test;import com.huang.service.ClothesShopping;import com.huang.service.ShoesShopping;import com.huang.service.Shopping;public class MyTest &#123; public static void main(String[] args) &#123; Shopping shoesShopping = new ShoesShopping(); shoesShopping.buyGoods(); System.out.println("-----------------------"); Shopping clothesShopping = new ClothesShopping(); clothesShopping.buyGoods(); &#125;&#125; 运行结果如下： Junit测试Jar包的下载关于Junit的Jar包下载，百度有很多的详细下载教程，这里不再赘述。 测试类的创建对于测试类的创建有这样一些习惯： 在项目中新建一个 source folder，并命名为 test，将来所有测试类均定义在这个目录中。 对于测试类所在包，一般是被测类所在包的包名后加再加一个 test 子包。 对于测试类类名，一般是被测类类名后加上 Test。 测试类的创建常用的有两种方式： 1. 使用向导创建测试类直接创建 JUnit Test Case。此时，会自动导入其需要的 Jar 包。 创建过程中，勾选上 setUp()与 tearDown()方法，这两个方法的作用是： setUp()：测试方法执行之前执行，主要用于测试前的初始化，如连接数据库等。 tearDown()：测试方法执行之后执行，主要用于资源释放，如关闭数据库连接等。 创建好后，直接在 setUp()与 tearDown()中编写初始化语句与资源释放语句即可。 对于测试方法的命名， 一般是以小写 test 开头，该测试方法用于测试哪个方法，就将该方法名放于 test 之后。当然，首字母要大写。 如，要测试 modify()方法，则它的测试方法名一般为： testModify()。 2. 使用注解创建测试类Step1：导入包需的 JUnit Jar 包Step2：直接创建一个普通的 Java 类Step3：在其中可以定义初始化方法与资源释放方法。方法签名要求： public void，无参。方法名随意。当然，方法名最好按照规范命名。Step4：在方法前添加注解 添加@Before 则为初始化方法；添加@After 则为资源释放方法；添加@Test 则为测试方法。 测试方法的运行在测试方法的方法签名上右击，选择 Run As/JUnit Test 运行结果看到绿条，则说明运行成功；看到红条，说明运行出了问题。 Log4j 与Log4j2 一个完整的软件，日志是必不可少的。程序从开发、测试、维护、运行等环节，都需要向控制台或文件等位置输出大量信息 。这些信息的输出，在 很多时候是使 用 System.out.println() 无法完成的。 日志信息根据用途与记录内容的不同，分为调试日志、运行日志、异常日志等。 用于日志记录的技术很多，如 jdk 的 logger 技术， apache 的 log4j、 log4j2 技术等。 Log4j 的全称为 Log for java，即，专门用于 java 语言的日志记录工具。其目前有两个版本： Log4j 与 Log4j2。 Log4j基础日志级别为了方便对于日志信息的输出显示，对日志内容进行了分级管理。 日志级别由高到低 ，共分 6 个级别： fatal(致命的)、 error、 warn、 info、 debug、 trace(堆栈)。 日志输出控制文件Log4j 的日志输出控制文件，主要由三个部分构成： 日志信息的输出位置：控制日志信息将要输出的位置，是控制台还是文件等。 日志信息的输出格式：控制日志信息的显示格式，即以怎样的字符串形式显示。 日志信息的输出级别： 控制日志信息的显示内容，即显示哪些级别的日志信息。 Log4j技术在 Java 代码中进行日志输出，需要用到 Logger 类的静态方法 getLogger()。 123456789101112131415161718package com.huang.test;import org.apache.log4j.Logger;public class MyTest &#123; public static void main(String[] args) &#123; //创建日志记录对象Logger Logger logger = Logger.getLogger(MyTest.class); logger.fatal("fatal msg"); logger.error("error msg"); logger.warn("warn msg"); logger.info("info msg"); logger.debug("debug msg"); logger.trace("trace msg"); &#125;&#125; 运行结果如下： 将来这些日志输出语句，会根据 log4j.properties 文件中日志级别的设置进行输出，会输出到指定位置。 其输出结果是：输出指定级别及其更高级别的信息。如指定 info 级别，则会输出 fatal、 error、warn、 info 级别的信息。 日志输出控制文件分析日志属性文件 log4j.properties 是专门用于控制日志输出的。其主要进行三方面控制： 输出位置：控制日志将要输出的位置，是控制台还是文件等。 输出布局：控制日志信息的显示形式。 输出级别：控制要输出的日志级别。 日志属性文件由两个对象组成：日志附加器与根日志。 根日志，即为 Java 代码中的日志记录器，其主要由两个属性构成：日志输出级别与日志附加器。 日志附加器，则由日志输出位置定义，由其它很多属性进行修饰，如输出布局、文件位置、文件大小等。 定义日志附加器所谓日志附加器，就是为日志记录器附加上很多其它设置信息。附加器的本质是一个接口，其定义语法为： log4j.appender.appenderName = 输出位置， appenderName 为自定义名称。 常用的附加器实现类如下： org.apache.log4j.ConsoleAppender： 日志输出到控制台 org.apache.log4j.FileAppender： 日志输出到文件 org.apache.log4j.RollingFileAppender： 当日志文件大小到达指定尺寸的时候将产生一个新的日志文件 org.apache.log4j.DailyRollingFileAppender： 每天产生一个日志文件 修饰日志附加器所谓修饰日志附加器，就是为定义好的附加器添加一些属性，以控制到指定位置的输出。不同的附加器，其修饰属性不同。 Log4j常用布局类型 org.apache.log4j.HTMLLayout： 网页布局， 以 HTML 表格形式布局 org.apache.log4j.SimpleLayout： 简单布局， 包含日志信息的级别和信息字符串 org.apache.log4j.PatternLayout： 匹配器布局， 可以灵活地指定布局模式。其主要是通过设置 PatternLayout 的 ConversionPattern 属性值来控制具 体输出格式的 。 配置根 Logger配置 rootLogger，以便于代码加载来控制日志的输出。其语法为： 1log4j.rootLogger = [ level ] , appenderName, … 其中， level 是日志记录的优先级，分为 OFF、 FATAL、 ERROR、 WARN、 INFO、 DEBUG、ALL。 Log4j 建议只使用四个级别，优先级从高到低分别是 ERROR、 WARN、 INFO、 DEBUG。OFF 为关闭日志功能。 说明：低级别的可以显示高级别的，但高级别的不能显示低级别的。所以，级别越高，将来显示的信息就越少。 Log4j2 技术Log4j2，是对 Log4j 的升级，其在配置与使用上发生了较大变化。 log4j2 配置文件是 XML 文件，不再支持 properties 文件。默认的文件名为 log4j2.xml。其存放的位置为 classpath 中。 代码中实现日志记录在要输出日志的类中创建日志对象 Logger，并通过 Logger 的方法在代码中加入日志输出语句。该日志对象是通过静态类 LogManager 的 getLogger()方法获取的。 1234567891011121314151617package com.huang.test;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;public class MyTest &#123; public static void main(String[] args) &#123; //创建日志对象Logger Logger logger = LogManager.getLogger(MyTest.class); logger.debug("this debug msg"); logger.info("this info msg"); logger.warn("this warn msg"); logger.error("this error msg"); &#125;&#125; 运行结果如下： 注意: Logger 与 LogManager 均为 org.apache.logging.log4j 包中的类，非 org.apache.log4j 包中的。 日志输出控制文件分析Log4j2 配置文件是 XML 文件，不再支持 properties 文件。默认的文件名为 log4j2.xml。其存放的位置为 classpath 中。 若没有设置 log4j2.xml，则系统会使用默认的日志配置：只会输出到控制台 error 级别的信息。 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration status="OFF"&gt; &lt;appenders&gt; &lt;Console name="myConsole" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%c %L] %m%n" /&gt; &lt;/Console&gt; &lt;File name="myLogFile" fileName="log/test.log" append="true"&gt; &lt;PatternLayout pattern="[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%c %L] %m%n" /&gt; &lt;/File&gt; &lt;RollingFile name="myRollingFile" fileName="logs/app.log" filePattern="logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz"&gt; &lt;PatternLayout pattern="[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%c %L] %m%n" /&gt; &lt;SizeBasedTriggeringPolicy size="1KB" /&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;!-- &lt;logger name="全限定类名或接口名" level="info"&gt; &lt;appender-ref ref="myConsole" /&gt; &lt;/logger&gt; --&gt; &lt;root level="trace"&gt; &lt;appender-ref ref="myConsole" /&gt; &lt;!-- &lt;appender-ref ref="myLogFile" /&gt; &lt;appender-ref ref="myRollingFile" /&gt; --&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 配置文件说明： （1）&lt;configuration/&gt;标签标签的 status 属性用于设置 Log4j2 自身运行的日志显示级别，一般为 OFF，不显示。 当然，也可以设置为 ERROR、 DEBUG 等其它级别。 （2）&lt;Console/&gt;标签标签的 target 属性用于设置输出的目标形式，其值一般为：SYSTEM_OUT 或 SYSTEM_ERR （3）&lt;File/&gt;标签标签的 fileName 属性用于设置文件的文件保存路径及文件名。如本例的意思是，日志文件名为 test.log，将其存放在当前项目的根目录下的 log 子目录中。 append 属性用于设置是否以追加方式将日志写入指定文件。 （4）&lt;RollingFile/&gt;标签fileName 指定存放目录及第一个日志文件名。 filePattern 指定新创建的日志文件的文件名。本例还会对文件进行压缩。 （5）&lt;loggers/&gt;标签用于配置根 Logger 对象，以指定所使用的日志记录器，及显示的级别。 其子标签用于指定所使用的日志记录器。该子标签的属性 level 用于指定显示级别。而日志记录器是通过的子标签来引用中定义好的记录器的。 需要注意的是，只要在中定义了、 等，且在其中指定了日志存放的目录，那么这些目录就会自动创建。无论在的中是否声明使用它们。 &lt;\adfjdkf&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务技术——Tomcat]]></title>
    <url>%2F2019%2F07%2F27%2FWeb%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Tomcat%2F</url>
    <content type="text"><![CDATA[服务器 其实服务器就是一台电脑。 配置比一般的电脑要好。 Web服务器软件 客户端在浏览器的地址栏上输入地址 ，然后web服务器软件，接收请求，然后响应消息。处理客户端的请求， 返回资源 | 信息。 Web应用：需要服务器支撑 服务器 所属公司 Tomcat-----------Apache WebLogic---------BEA WebSphere--------IBM IIS--------------微软Tomcat安装 直接解压 ，然后找到bin目录下的startup.bat文件启动。 启动之后，如果能够正常看到黑窗口，表明已经成功安装。 为了确保万无一失， 最好在浏览器的地址栏上输入 ： http://localhost:8080 , 如果有看到如下内容就表明成功了。 如果双击了startup.bat, 看到一闪而过的情形，一般都是 JDK的环境变量没有配置。 Tomcat目录介绍bin：包含了一些jar , bat文件 。 startup.bat conf：tomcat的配置，如 server.xml web.xml lib：tomcat运行所需的jar文件 logs：运行的日志文件 temp：临时文件 webapps：发布到tomcat服务器上的项目，就存放在这个目录。 work：jsp翻译成class文件存放地如何把一个项目发布到Tomcat中 需求： 如何能让其他的电脑访问我这台电脑上的资源？ 在电脑新建stu.xml文件，内容如下 1234&lt;person&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt;&lt;/person&gt; 直接拷贝stu.xml文件到webapps/ROOT目录下， 在浏览器里面访问默认访问方式：http://localhost:8080/stu.xml 可以使用IP地址访问：http://192.168.43.139:8080/stu.xml 注意： 如果Tomcat在运行需要重新启动，否则会报404错误。 需要把xml文件改为UTF-8编码，否则会报错。解决方法是使用记事本打开xml文件，选择文件——&gt;另存为，“编码”格式选则UTF-8，点击保存。 在webaps下面新建一个文件夹xml , 然后拷贝文件放置到这个文件夹中http://localhost:8080/xml/stu.xml 也可以使用IP地址访问：http://192.168.43.139:8080/xml/stu.xml 说明： http://localhost:8080 ： 其实对应的是到webapps/roothttp://localhost:8080/xml/ : 对应是 webapps/xml 配置虚拟路径(一) 查看使用文档说明 使用localhost：8080 打开tomcat首页， 在左侧找到tomcat的文档入口， 点击进去后， 在左侧接着找到 Context入口，点击进入。 也可以输入地址访问：http://localhost:8080/docs/config/context.html 在conf/server.xml 找到host元素节点 12&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; 加入以下内容 1&lt;Context docBase="D:\xml02" path="/a"&gt;&lt;/Context&gt; 在D盘新建xml02文件夹，在文件夹下新建person.xml文件，内容如下 12345&lt;person&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;body&gt;这里是虚拟路径&lt;/body&gt;&lt;/person&gt; 说明: 1). docBase： 项目的路径地址，如： D:\xml02\person.xml。 2). path : 对应的虚拟路径 一定要以/打头。 在浏览器地址栏上输入：http://localhost:8080/a/person.xml 配置虚拟路径(二) 在tomcat/conf/catalina/localhost/ 文件夹下新建一个xml文件，名字可以自己定义。如person.xml。 在person.xml文件里面写入以下内容 12&lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;Context docBase="D:\xml02"&gt;&lt;/Context&gt; 在浏览器上面访问：http://localhost:8080/person/person.xml 注意： XML文件的名字也就是项目部署成功后的web根路径，如定义这person.xml,那么后面的访问路径就是http://ip:port/person。 给Eclipse配置Tomcat 在server里面 右键新建一个服务器， 选择到Apache分类， 找到对应的Tomcat版本， 接着一步一步配置即可。 配置完毕后， 在server 里面， 右键刚才的服务器，然后Open ， 找到上面的Server Location , 选择中间的 Use Tomcat installation… 创建Web工程， 在WebContent下定义html文件， 右键工程， run as server 程序架构 C/S(Client/Server) QQ、微信、LOL 优点： 有一部分代码写在客户端， 用户体验比较好。 缺点： 服务器更新，客户端也要随着更新。 占用资源大。 B/S(Browser/Server) 网页游戏 ， WebQQ … 优点： 客户端只要有浏览器就可以了。 占用资源小， 不用更新。 缺点： 用户体验不佳。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接技术——JDBC(Java DataBase Connectivity)]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94JDBC%2F</url>
    <content type="text"><![CDATA[为什么会出现JDBC SUN公司提供的一种数据库访问规则、规范, 由于数据库种类较多，并且Java语言使用比较广泛，SUN公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的Java程序只要使用SUN公司提供的JDBC驱动即可。 使用JDBC的基本步骤 注册驱动： 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 建立连接：参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。 12//DriverManager.getConnection("jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb"); conn = DriverManager.getConnection("jdbc:mysql://localhost/student", "root", "root"); 创建statement：跟数据库打交道，一定需要这个对象。 1st = conn.createStatement(); 执行sql ，得到ResultSet：执行查询，得到结果集。 12String sql = "select * from t_stu";rs = st.executeQuery(sql); 遍历结果集：遍历查询每一条记录 。 123456while(rs.next())&#123; int id = rs.getInt("id"); String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println("id="+id + "===name="+name+"==age="+age); &#125; 释放资源： 1234567if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException sqlEx) &#123; &#125; // ignore rs = null; &#125;... JDBC 工具类构建 资源释放工作的整合 驱动防二次注册 1). river 这个类里面有静态代码块，一上来就执行了，所以等同于我们注册了两次驱动。 其实没这个必要的。 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 2). 静态代码块 ——&gt;类加载了，就执行。 1java.sql.DriverManager.registerDriver(new Driver()); 3).最后形成以下代码即可。 1Class.forName("com.mysql.jdbc.Driver"); 使用properties配置文件 1). 在src底下声明一个文件 xxx.properties ，里面的内容如下： 1234driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost/studentname=rootpassword=root 2). 在工具类里面，使用静态代码块，读取属性 123456789101112131415161718192021static&#123; try &#123; //创建一个属性配置对象 Properties properties = new Properties(); InputStream is = new FileInputStream("jdbc.properties"); //对应文件位于工程根目录 //使用类加载器，去读取src底下的资源文件。 后面在servlet //对应文件位于src目录底下 //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties"); //导入输入流。 properties.load(is); //读取属性 driverClass = properties.getProperty("driverClass"); url = properties.getProperty("url"); name = properties.getProperty("name"); password = properties.getProperty("password"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; ​ 数据库(SQL)的CRUD insert INSERT INTO t_stu (NAME , age) VALUES (&apos;wangqiang&apos;,28) //INSERT INTO t_stu VALUES (NULL,&apos;wangqiang2&apos;,28) 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "insert into t_stu values(null , 'aobama' , 59)";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql); if(result &gt;0 )&#123; System.out.println("添加成功");&#125;else&#123; System.out.println("添加失败");&#125; delete DELETE FROM t_stu WHERE id = 6 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "delete from t_stu where name='aobama'";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql); if(result &gt;0 )&#123; System.out.println("删除成功");&#125;else&#123; System.out.println("删除失败");&#125; query SELECT * FROM t_stu 12345678910111213141516// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();// 3. 执行sql语句，返回ResultSetString sql = "select * from t_stu";rs = st.executeQuery(sql);// 4. 遍历结果集while (rs.next()) &#123; String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println(name + " " + age); &#125; update UPDATE t_stu SET age = 38 WHERE id = 1; 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "update t_stu set age = 26 where name ='qyq'";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql);if(result &gt;0 )&#123; System.out.println("更新成功");&#125;else&#123; System.out.println("更新失败");&#125; 使用单元测试，测试代码 定义一个类， TestXXX , 里面定义方法 testXXX. 添加Junit的支持。右键工程 — add Library — Junit — Junit4 在方法的上面加上注解 ， 其实就是一个标记。 1234@Testpublic void testQuery() &#123; ...&#125; 光标选中方法名字，然后右键执行单元测试。 或者是打开outline视图， 然后选择方法右键执行。 Dao模式 Data Access Object 数据访问对象 新建一个dao的接口， 里面声明数据库访问规则 12345678910/** * 定义操作数据库的方法 */public interface UserDao &#123; /** * 查询所有 */ void findAll();&#125; 新建一个dao的实现类，具体实现早前定义的规则 123456789101112131415161718192021222324252627282930 public class UserDaoImpl implements UserDao&#123; @Override public void findAll() &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1. 获取连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); String sql = "select * from t_user"; rs = st.executeQuery(sql); while(rs.next())&#123; String userName = rs.getString("username"); String password = rs.getString("password"); System.out.println(userName+"="+password); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, st, rs); &#125; &#125;&#125; 直接使用实现 12345@Testpublic void testFindAll()&#123; UserDao dao = new UserDaoImpl(); dao.findAll();&#125; Statement安全问题 Statement执行 ，其实是拼接sql语句的。即先拼接sql语句，然后在一起执行。 123456789String sql = "select * from t_user where username='"+ username +"' and password='"+ password +"'";UserDao dao = new UserDaoImpl();dao.login("admin", "100234khsdf88' or '1=1"); SELECT * FROM t_user WHERE username='admin' AND PASSWORD='100234khsdf88' or '1=1' //前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 rs = st.executeQuery(sql); PrepareStatement 该对象就是替换前面的statement对象。 相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。 123456String sql = "insert into t_user values(null , ? , ?)";ps = conn.prepareStatement(sql); //给占位符赋值 从左到右数过来，1 代表第一个问号， 永远都是从1开始。ps.setString(1, userName); ps.setString(2, password); ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务技术——Servlet]]></title>
    <url>%2F2019%2F07%2F25%2FWeb%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Servlet%2F</url>
    <content type="text"><![CDATA[Servlet是什么? 其实就是一个Java程序，运行在我们的Web服务器上，用于接收和响应客户端的HTTP请求。 更多的是配合动态资源来做。 当然静态资源也需要使用到Servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet Servlet执行过程第一步：类的定义1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.huang.servlet;import java.io.IOException;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;/** * *@author 黄远志 *@date 2019年7月4日下午7:08:19 *@GitHub https://github.com/huangyuanzhi1997 */public class HelloServlet implements Servlet &#123; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println("HelloServlet"); &#125; @Override public void destroy() &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void init(ServletConfig config) throws ServletException &#123; &#125;&#125; 第二步：Servlet的配置1234567891011&lt;!-- 向tomcat报告， 我这个应用里面有这个servlet，名字叫做HelloServlet , 具体的路径是com.huang.servlet.HelloServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.huang.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 注册servlet的映射。 servletName : 找到上面注册的具体servlet，url-pattern: 在地址栏上的path一定要以/打头 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 找到Tomcat应用 找到项目 找web.xml，然后在里面找到url-pattern，有没有哪一个patten的内容是/a 找到servlet-mapping中的那个servlet-name【HelloServlet】 找到上面定义的servlet元素中的servlet-naem【HelloServlet】 找到下面定义的servlet-class，然后开始创建该类的实例 继而执行该servlet中的service方法 Servlet的通用写法Servlet (接口) | | GenericServlet | | HttpServlet （用于处理http的请求）定义一个类，继承HttpServlet 复写doGet 和 doPost12345678910111213141516171819202122232425262728293031323334353637package com.huang.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * *@author 黄远志 *@date 2019年7月4日下午7:51:01 *@GitHub https://github.com/huangyuanzhi1997 */public class HelloServlet02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("HelloServlet02..."); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); System.out.println("get..."); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); System.out.println("post..."); &#125;&#125; Servlet的生命周期 生命周期 从创建到销毁的一段时间。 生命周期方法 从创建到销毁，所调用的那些方法。 init方法 在创建该Servlet的实例时，就执行该方法。 一个Servlet只会初始化一次， init方法只会执行一次。 默认情况下是 ： 初次访问该Servlet，才会创建实例。 service方法 只要客户端来了一个请求，那么就执行这个方法了。 该方法可以被执行很多次。 一次请求，对应一次service方法的调用。 destroy方法 servlet销毁的时候，就会执行该方法。 1). 该项目从Tomcat的里面移除。 2). 正常关闭Tomcat就会执行 shutdown.bat。 doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。 让Servlet创建实例的时机提前 默认情况下，只有在初次访问Servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么有没有方法可以让这个初始化的时机提前一点。 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 12345&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt; 为什么需要有这个ServletConfig Servlet的配置，通过这个对象，可以获取Servlet在配置的时候一些信息 先说 ， 再写怎么用， 最后说有什么用。 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。它的代码放置在了自己的servlet类里面。 刚好这个Servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个Servlet的公司，在注册Servlet的时候，必须要在web.xml里面，声明init-params 在开发当中比较少用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
