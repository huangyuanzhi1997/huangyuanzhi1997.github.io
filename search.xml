<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Oracle 入门教程]]></title>
    <url>%2F2019%2F10%2F16%2FOracle%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Oracle 数据库系统是美国 Oracle 公司(甲骨文)提供的以分布式数据库为核心的一组软件产品，是目前最流行的客户/服务器 (Client/Server) 或 B/S 体系结构的数据库之一，比如 SilverStream 就是基于数据库的一种中间件。 Oracle 数据库是目前世界上使用最为广泛的数据库管理系统，作为一个通用的数据库系统，它具有完整的数据管理功能；作为一个关系型数据库，它是一个完备关系的产品；作为分布式数据库它实现了分布式处理功能，但它的所有知识，只要在一种机型上学习了 Oracle 知识，便能在各种类型的机器上使用它。 Oracle 的基本使用连接命令sqlplus /nolog进入 sqlplus 环境。其中 /nolog 是不登陆到数据库服务器的意思，如果没有 /nolog 参数， sqlplus 会提示你输入用户名和密码。 1234567C:\Users\Administrator&gt;sqlplusSQL*Plus: Release 11.1.0.7.0 - Production on 星期三 10月 16 10:30:42 2019Copyright (c) 1982, 2008, Oracle. All rights reserved.请输入用户名: conn[etc]用法: conn 用户名 / 密码 @网络服务名 [as sysdba/sysoper] 当用特权用户身份连接时，必须带上 as sysdba 或是 as sysoper 以系统管理员 (sysdba) 身份连接数据库 12SQL&gt; conn / as sysdba已连接。 创建用户 123SQL&gt; create user huang identified by 123456;用户已创建。 用户授权 123SQL&gt; grant create session,connect,resource to huang;授权成功。 连接到数据库 12SQL&gt; conn huang/123456已连接。 show user显示当前用户名 12SQL&gt; show userUSER 为 "HUANG" passw[ord]用于修改用户的密码，如果要想修改其它用户的密码，需要用 sys/system 登录。 123456SQL&gt; passw更改 HUANG 的口令旧口令:新口令:重新键入新口令:口令已更改 disc[onnect]用于断开与当前数据库的连接 (不退出 sqlplus ) 1234SQL&gt; disc从 Oracle Database 11g Enterprise Edition Release 11.1.0.7.0 - ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options 断开SQL&gt; exit用于断开与当前数据库的连接 (同时退出 sqlplus ) 12345SQL&gt; exit从 Oracle Database 11g Enterprise Edition Release 11.1.0.7.0 - ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options 断开C:\Users\Administrator&gt; 文件操作命令start 和 @运行 SQL 脚本 123SQL&gt; @ d:\c.sql表已创建。 或是 123SQL&gt; start d:\c.sql表已创建。 edit该命令可以编辑指定的 SQL 脚本 1SQL&gt; edit d:\c.sql 这样会把 d:\c.sql 这个文件打开 spool该命令可以将 sqlplus 屏幕上的(查询)内容输出到指定文件中去 1SQL&gt; spool d:\d.sql 1SQL&gt; select ASSETNUM 序号,DESCRIPTION 描述 from ASSET; 1SQL&gt; spool off 交互式命令&amp;可以替代变量，而该变量在执行时，需要用户输入， Oracle 会提示用户输入值 12SQL&gt; select * from ACCOUNTDEFAULTS where ORGID='&amp;ORGID';输入 orgid 的值: 显示和设置环境变量可以用来控制输出的各种格式，如果希望永久的保存相关设置，可以修改 glogin.sql 脚本 linesize设置显示行的宽度，默认是 80 个字符 12345SQL&gt; show linesizelinesize 80SQL&gt; set linesize 90SQL&gt; show linesizelinesize 90 pagelize设置每页显示的行数目，默认是 14 ，用法和 linesize 一样 12345SQL&gt; show pagesizepagesize 14SQL&gt; set pagesize 20SQL&gt; show pagesizepagesize 20 Oracle 用户管理创建用户在 Oracle 中要创建一个新的用户使用 create user 语句， 一般是具有 dba (数据库管理员)的权限才能使用。 1create user 用户名 identified by 密码 ; 12345SQL&gt; create user zhangsan identified by 123456;create user zhangsan identified by 123456 *第 1 行出现错误:ORA-01031: 权限不足 我们连接到 sysdba 创建用户 12345SQL&gt; conn / as sysdba已连接。SQL&gt; create user zhangsan identified by 123456;用户已创建。 给用户修改密码如果给自己修改密码可以直接使用 1password 用户名 123456SQL&gt; password huang更改 huang 的口令旧口令:新口令:重新键入新口令:口令已更改 如果给别人修改密码则需要具有 dba 的权限，或是拥有 alter user 的系统权限 1alter user 用户名 identified by 新密码 123SQL&gt; alter user zhangsan identified by 12345678;用户已更改。 删除用户一般以 dba 的身份去删除某个用户， 如果用其它用户去删除用户则需要具有 drop user 的权限。 1drop user 用户名 [cascade] 123SQL&gt; drop user zhangsan;用户已删除。 如果要删除的用户，已经创建了表，那么就需要在删除的时候带一个参数 cascade ; 权限和角色权限创建的新用户是没有任何权限的， 甚至连登陆的数据库的权限都没有， 需要为其指定相应的权限；要使用有能力授权的用户，如 sys 、 system 。 权限包含系统权限和对象权限 系统权限：用户对数据库的相关权限 对象权限：用户对其他用户的数据对象操作的权限 角色角色是指由系统权限集合。通常给某个用户授予权限时如果没有角色存在的话，那么需要一条一条的操作，角色的存在就是使得授权变得很方便。通常一个角色由多个系统权限组成。常用的角色有三个 connect (7种权限)、 dba 、 resource (在任何表空间建表)。 connect 角色：是授予最终用户的典型权利，最基本的 alter session 修改会话 create cluster 建立聚簇 create database link 建立数据库链接 create sequence 建立序列 create session 建立会话 create synonym 建立同义词 create view 建立视图 resource 角色： 是授予开发人员的 create cluster 建立聚簇 create procedure 建立过程 create sequence 建立序列 create table 建表 cteate trigger 建立触发器 create type 建立类型 dba 角色：拥有系统所有系统级权限 使用 grant 命令给用户分配权限： grant 【权限名】 to 【用户名】 分配角色 1grant 【角色名】 to 【用户名】 收回权限 1revoke 【权限名】 from 【用户名】 用户管理的综合案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112SQL&gt; create user zhangsan identified by 123456; /*创建用户*/用户已创建。SQL&gt; conn zhangsan/123456; /*新建用户没有 session (登陆)权限*/ERROR:ORA-01045: 用户 ZHANGSAN 没有 CREATE SESSION 权限; 登录被拒绝警告: 您不再连接到 ORACLE。SQL&gt; show userUSER 为 ""SQL&gt; conn / as sysdba;已连接。SQL&gt; grant create session to zhangsan; /*使 zhangsan 能够被连接*/授权成功。SQL&gt; conn zhangsan/123456;已连接。SQL&gt; show user;USER 为 "ZHANGSAN"SQL&gt; conn / as sysdba;已连接。SQL&gt; grant resource to zhangsan; /*让zhangsan 能够在任何表空间下建表*/授权成功。SQL&gt; create table users(name varchar(10),age number(3)); /*在 sys 角色下创建一个简单的表 users */表已创建。SQL&gt; insert into users values('张三',22); /*插入数据*/已创建 1 行。SQL&gt; insert into users values('李四',24);已创建 1 行。SQL&gt; select * from users; /*查询*/NAME AGE-------------------- ----------张三 22李四 24SQL&gt; conn zhangsan/123456;已连接。SQL&gt; select * from sys.users; /*新建的用户没有查询 sys 表的权限*/select * from sys.users *第 1 行出现错误:ORA-00942: 表或视图不存在SQL&gt; conn / as sysdba;已连接。SQL&gt; grant select on users to zhangsan; /*登录到 sys 给 zhangsan 授权让 zhangsan 可以查看 sys 下的 users 表*/授权成功。SQL&gt; conn zhangsan/123456;已连接。SQL&gt; select * from sys.users; /* 登录到 zhangsan 下查看 users 表*/NAME AGE-------------------- ----------张三 22王五 24SQL&gt; update sys.users set name='张小三' where name='张三'; /*这时如果想要更新 sys.users 中的数据，会提示 "ORA-01031: 权限不足 " 。因为 sys 只给了 zhangsan 查看的权利，如果仍然想更新，要到 sys 下进行授权*/update sys.users set name='张小三' where name='张三' *第 1 行出现错误:ORA-01031: 权限不足SQL&gt; conn / as sysdba已连接。SQL&gt; grant update on users to zhangsan; /*登录到 sys 给 zhangsan 授权让 zhangsan 可以更新 sys 下的 users 表*/授权成功。SQL&gt; conn zhangsan/123456;已连接。SQL&gt; update sys.users set name='张小三' where name='张三';已更新 1 行。SQL&gt; select * from sys.users;NAME AGE-------------------- ----------张小三 22王五 24SQL&gt; revoke resource from zhangsan; /*登陆到 sys 下回收 resource 权限*/撤销成功。SQL&gt; revoke select on users from zhangsan; /*登陆到 sys 下回收 select 权限*/撤销成功。SQL&gt; conn zhangsan/123456;已连接。SQL&gt; select * from sys.users; /* 这时 sys 就不能再查询 sys.users 的数据了*/select * from sys.users *第 1 行出现错误:ORA-00942: 表或视图不存在 使用 profile 管理用户口令profile 是口令限制，资源限制的命令集合。当建立数据库时， Oracle 会自动建立名称为 default 的 profile。当建立用户没有制定 profile 选项，那 Oracle 就会将 default 分配给用户。 帐号锁定指定登录时最多可以输入密码的次数，也可以指定用户锁定的时间，以天为单位。一般用 dba 的身份去执行命令。 指定用户 huang 最多只能尝试三次登录，锁定时间为 2 天。 123456789SQL&gt; conn / as sysdba;已连接。SQL&gt; create profile lock_account limit failed_login_attempts 3 password_lock_time 2;配置文件已创建SQL&gt; alter user huang profile lock_account;用户已更改。 按 CTRL + C 退出来验证账号锁定 12345678910111213141516171819202122232425C:\Users\Administrator&gt;sqlplusSQL*Plus: Release 11.1.0.7.0 - Production on 星期三 10月 30 11:13:48 2019Copyright (c) 1982, 2008, Oracle. All rights reserved.请输入用户名: huang输入口令:ERROR:ORA-01017: 用户名/口令无效; 登录被拒绝请输入用户名: huang输入口令:ERROR:ORA-01017: 用户名/口令无效; 登录被拒绝请输入用户名: huang输入口令:ERROR:ORA-28000: 帐户已被锁定SP2-0157: 在 3 次尝试之后无法连接到 ORACLE, 退出 SQL*Plus 账户解锁1234567SQL&gt; alter user huang account unlock;用户已更改。SQL&gt; conn huang;输入口令:已连接。 终止口令为了让用户定期修改密码，可以使用终止口令的指令完成，同样这个命令也要 dba 身份来操作。 给 huang 创建一个 profile 文件，要求该用户每隔 10 天要修改登录密码，宽限期 2 天 1234567SQL&gt; create profile huang limit password_life_time 10 password_grace_time 2;配置文件已创建SQL&gt; alter user huang profile huang;用户已更改。 解锁方式同上 口令历史如果希望用户在修改密码时，不能使用以前用过的密码，可以使用口令历史，这样 Oracle 就会将口令修改的信息存放在数据字典中，这样当用户修改密码时， Oracle 就会对新密码与就得进行对比，如果一样提示用户重新输入。 1234567891011121314151617SQL&gt; create profile password_history limit password_life_time 10 password_grace_time 2 password_reuse_time 10;配置文件已创建SQL&gt; alter user huang profile password_history;用户已更改。SQL&gt; alter user huang identified by 12345678;用户已更改。SQL&gt; alter user huang identified by 12345678;alter user huang identified by 12345678*第 1 行出现错误:ORA-28007: 无法重新使用口令 password_reuse_time 10 表示 10 天后口令可重复使用。 删除 profile123SQL&gt; drop profile password_history cascade;配置文件已删除。 cascade 表示如果已经将 profile分 配给某个用户时，仍要删除 profile，就要加上 cascade。 Oracle 表的管理表名和列的命名规则 必须以字母开头 长度不能超过 30 个字符 不能使用 Oracle 的保留字 只能使用如下字符 A-Z ， a-z ， 0-9 ， $ , # 等 Oracle 支持的数据类型字符型char 定长，最长2000字符 例如： char(10) 存储内容为“小黄”时，前4个字符放‘小黄’，后六位由空格补齐 优点是：效率高，查询速率快。如身份证的字段可以设置成 char(18) varchar2 变长最大 4000 字符( Oracle 推荐使用) varchar2(10) 存储内容为“小黄”时， Oracle 分配 4 个字符 clob(character large object) 字符型大对象，最大 4G 数字类型number 范围 -10 的 38 次方到 10 的 38 次方，可以是整数，也可以是小数 number(5，2) 表示一个小数有5位有效数字， 2 位是小数 例如：定义一个范围在 -999.99-999.99 的数字可以用 number(5，2)，定义一个范围在 -99999-99999 可以用 number(5) 日期类型date 包含年月日和时分秒 timestamp Oracle 对 date 类型的扩展，可以精确到毫秒。 图片类型blob 二进制数据，可以存放图片，音频，视频最大 4G ，这个类型允许我们将大文件存储进数据库，但是一般在数据库里，存放的应该是这些文件的路径，如果对安全性有要求，可以将文件放入数据库(一般来讲，在真实项目中是不会把图片和声音真的往数据库里存放的)。 建表语句建表 学生表 1234567891011121314151617create table student( /*表名*/ id number(4), /*学号*/ name varchar2(20), /*姓名*/ sex char(2), /*性别*/ birthday date, /*出生日期*/ sal number(6,2) /*奖学金*/ );SQL&gt; desc student; /*查看表结构*/ 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- ID NUMBER(4) NAME VARCHAR2(20 CHAR) SEX CHAR(2 CHAR) BIRTHDAY DATE SAL NUMBER(6,2) 班级表 1234567891011create table class( c_id number(2), c_name varchar2(40) );SQL&gt; desc class; 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- C_ID NUMBER(2) C_NAME VARCHAR2(40 CHAR) 修改表12345678910111213141516171819202122232425262728293031323334353637383940SQL&gt; alter table student add (c_id number(2)); /*添加字段*/表已更改。SQL&gt; alter table student modify (name varchar2(50)); /*修改字段的长度*/表已更改。SQL&gt; alter table student modify (name char(20)); /*修改字段的类型(表中不能有数据)*/表已更改。SQL&gt; alter table student rename column name to s_name; /*修改字段的名字(表中不能有数据)*/表已更改。SQL&gt; alter table student drop column sex; /*删除一个字段(慎重使用)*/表已更改。SQL&gt; rename student to stu; /*修改表的名字*/表已重命名。SQL&gt; desc stu; 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- ID NUMBER(4) S_NAME CHAR(20 CHAR) BIRTHDAY DATE SAL NUMBER(6,2) C_ID NUMBER(2)SQL&gt; drop table stu; /*删除表*/表已删除。SQL&gt; desc stu;ERROR:ORA-04043: 对象 stu 不存在 操作表使用 student 表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231SQL&gt; insert into student values(1,'张三','男','01-1月-19',8888.88); /*添加数据，所有字段必须都插入， Oracle 中默认的日期格式‘DD-MON-YY’ (日-月-年)*/已创建 1 行。SQL&gt; select * from student; ID NAME SEX BIRTHDAY---------- ---------------------------------------- ---- -------------- SAL---------- 1 张三 男 01-1月 -19 8888.88SQL&gt; set linesize 300; /*设置行的宽度，这样就好看多了*/SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- -------------- ---------- 1 张三 男 01-1月 -19 8888.88SQL&gt; alter session set nls_date_format='YYYY-MM-DD'; /*修改日期的默认格式。注意，这种修改方法，只对当前会话有效。而不是当前的 sql*plus 窗口。即如果你这样修改之后，又使用 connect 命令以其他用户连接到数据库或者是连接到其他的数据库，则这个日期格式就失效了，又恢复到缺省的日期格式。要想永久改变日期输入格式是需要改注册表的，还有一个方法是使用函数。*/会话已更改。SQL&gt; insert into student values(2,'李四','男','2019-01-02',8888.88);已创建 1 行。SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张三 男 2019-01-01 8888.88 2 李四 男 2019-01-02 8888.88SQL&gt; insert into student(id,name) values(3,'王五'); /*插入部分字段,前提是未插入的字段允许为 null */已创建 1 行。SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张三 男 2019-01-01 8888.88 2 李四 男 2019-01-02 8888.88 3 王五SQL&gt; insert into student(id,name,sex) values(4,null,null); /*插入空值*/已创建 1 行。SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张三 男 2019-01-01 8888.88 2 李四 男 2019-01-02 8888.88 3 王五 4SQL&gt; select * from student where name=null; /*查询 name 为空的一条记录，错误的做法*/未选定行SQL&gt; select * from student where name is null; /*查询 name 为空的一条记录，正确的做法*/ ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 4SQL&gt; select * from student where name is not null; /*查询 name 不为空的一条记录*/ ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张三 男 2019-01-01 8888.88 2 李四 男 2019-01-02 8888.88 3 王五SQL&gt; update student set sex='女' where id='1'; /*修改一个字段*/已更新 1 行。SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张三 女 2019-01-01 8888.88 2 李四 男 2019-01-02 8888.88 3 王五 4SQL&gt; update student set sex='女',name='李小四' where id='2'; /*修改多个字段*/已更新 1 行。SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张三 女 2019-01-01 8888.88 2 李小四 女 2019-01-02 8888.88 3 王五 4SQL&gt; update student set name='赵六' where name is null; /*修改含有 null 值的字段*/已更新 1 行。SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张三 女 2019-01-01 8888.88 2 李小四 女 2019-01-02 8888.88 3 王五 4 赵六SQL&gt; insert into student values(1,'张三','女','2019-01-01',8888.88); /*增加一条重复的记录*/已创建 1 行。SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张三 女 2019-01-01 8888.88 2 李小四 女 2019-01-02 8888.88 3 王五 4 赵六 1 张三 女 2019-01-01 8888.88SQL&gt; select distinct id,name from student; /*取消重复行，查询时在 select 后面加上 distinct 即可将重复数据略去*/ ID NAME---------- ---------------------------------------- 3 王五 2 李小四 1 张三 4 赵六SQL&gt; delete from student where id='4'; /*删除数据，删除一条记录*/已删除 1 行。SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张三 女 2019-01-01 8888.88 2 李小四 女 2019-01-02 8888.88 3 王五 1 张三 女 2019-01-01 8888.88SQL&gt; delete from student; /*删除所有记录，表结构还在，会记录日志，这种删除是可以恢复的，速度会稍慢*/已删除4行。SQL&gt; select * from student;未选定行SQL&gt; truncate table student; /*删除所有记录，表结构还在，不记录日记，所有这种删除无法找回数据，但是速度很快*/表被截断。SQL&gt; desc student; 名称 是否为空? 类型 ----------------------------------------- -------- ---------------------------- ID NUMBER(4) NAME VARCHAR2(20 CHAR) SEX CHAR(2 CHAR) BIRTHDAY DATE SAL NUMBER(6,2)SQL&gt; drop table student; /*删除表的结构和数据*/表已删除。SQL&gt; desc student;ERROR:ORA-04043: 对象 student 不存在SQL&gt; create table student( /*表名*/ /*恢复数据，用 delete from student 时数据可恢，使用 student 表*/ 2 id number(4), /*学号*/ 3 name varchar2(20), /*姓名*/ 4 sex char(2), /*性别*/ 5 birthday date, /*出生日期*/ 6 sal number(6,2) /*奖学金*/ 7 );表已创建。SQL&gt; insert into student values(1,'张小三','女','2019-01-01',8888.88); /*插入数据*/已创建 1 行。SQL&gt; insert into student values(2,'李小四','女','2019-01-01',8888.88);已创建 1 行。SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张小三 女 2019-01-01 8888.88 2 李小四 女 2019-01-01 8888.88SQL&gt; savepoint sp; /*首先要设置一个保存点*/保存点已创建。SQL&gt; delete from student; /*删除数据*/已删除2行。SQL&gt; select * from student; /*查询验证数据是否被删掉*/未选定行SQL&gt; rollback to sp; /*回滚数据*/回退已完成。SQL&gt; select * from student; /*查询验证数据回滚是否成功，可以设置多个保存点，但是如果不做处理，新的保存点会默认覆盖前一个保存点*/ ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- ---------- ---------- 1 张小三 女 2019-01-01 8888.88 2 李小四 女 2019-01-01 8888.88 Oracle 的基本查询PL/SQL 软件中两个命令12345678910111213141516SQL&gt; clear /*清屏命令*/SQL&gt; set timing on; /*打开显示操作时间*/SQL&gt; select * from student; ID NAME SEX BIRTHDAY SAL---------- ---------------------------------------- ---- -------------- ---------- 1 张小三 女 01-1月 -19 8888.88 2 李小四 女 01-1月 -19 8888.88已用时间: 00: 00: 00.00 /*这里显示操作时间*/SQL&gt; set timing off; /*关闭操作时间*/SQL&gt; select count(*) from student; /*查询所有记录数*/ COUNT(*)---------- 2 注意Oracle 的字段不区分大小写，实体区分大小写。 表基本查询scott 用户存在的几张表 ( emp ， dept )，本次实例采用 emp 和 dept 表。 使用算术表达式显示每个雇员的月收入 1234567891011121314151617181920212223SQL&gt; select ename "姓名",sal 月工资 from emp;姓名 月工资-------------------- ----------SMITH 800ALLEN 1600WARD 1250JONES 2975MARTIN 1250BLAKE 2850CLARK 2450SCOTT 3000KING 5000TURNER 1500ADAMS 1100姓名 月工资-------------------- ----------JAMES 950FORD 3000MILLER 1300已选择14行。 显示每个雇员的年收入 123456789101112131415161718192021SQL&gt; select ename "姓名",sal * 12 as "年收入" from emp;姓名 年收入-------------------- ----------SMITH 9600ALLEN 19200WARD 15000JONES 35700MARTIN 15000BLAKE 34200CLARK 29400SCOTT 36000KING 60000TURNER 18000ADAMS 13200姓名 年收入-------------------- ----------JAMES 11400FORD 36000MILLER 15600 这里的中文最好用引号引上,尽量不要用中文。 如果计算表达式中有一个 null 值，那么计算结果就为 null ，如何处理 null 值？ 1234567891011121314151617181920212223SQL&gt; select sal * 13 + nvl(comm,0) * 13 "年薪",ename,comm from emp; 年薪 ENAME COMM---------- -------------------- ---------- 10400 SMITH 24700 ALLEN 300 22750 WARD 500 38675 JONES 34450 MARTIN 1400 37050 BLAKE 31850 CLARK 39000 SCOTT 65000 KING 19500 TURNER 0 14300 ADAMS 年薪 ENAME COMM---------- -------------------- ---------- 12350 JAMES 39000 FORD 16900 MILLER已选择14行。 nvl(comm,0) 的意思是：如果 comm 为 null ，那么按 0 计算，不是 0 按本身计算。 用 “||” 来连接字符串 1234567891011121314151617181920212223SQL&gt; select ename || ' is a ' || job from emp; /*这句话表示:姓名为 XX 是做 XX 工作的*/ENAME||'ISA'||JOB------------------------------------------------------------------------------------------------------SMITH is a CLERKALLEN is a SALESMANWARD is a SALESMANJONES is a MANAGERMARTIN is a SALESMANBLAKE is a MANAGERCLARK is a MANAGERSCOTT is a ANALYSTKING is a PRESIDENTTURNER is a SALESMANADAMS is a CLERKENAME||'ISA'||JOB------------------------------------------------------------------------------------------------------JAMES is a CLERKFORD is a ANALYSTMILLER is a CLERK已选择14行。 使用 where 字句显示工资高于 3000 的员工 12345SQL&gt; select ename,sal from emp where sal &gt; 3000;ENAME SAL-------------------- ----------KING 5000 查找 1982-1-1 后入职的员工 1234567SQL&gt; select ename from emp where hiredate &gt; '1982-1-1';ENAME--------------------SCOTTADAMSMILLER 查找工资在 2000-2500 之间的员工，并且显示员工的工资 12345SQL&gt; select ename,sal from emp where sal &gt;=2000 and sal &lt;=2500;ENAME SAL-------------------- ----------CLARK 2450 使用 like 操作符%：表示 0 到多个字符_：表示任意单个字符 显示首字母为 S 的员工 123456SQL&gt; select ename from emp where ename like 'S%';ENAME--------------------SMITHSCOTT 显示第三个字母为大写 O 的所有员工的姓名和工资 12345SQL&gt; select ename,sal from emp where ename like '__O%'; /*注意: 两个 _ 符号*/ENAME SAL-------------------- ----------SCOTT 3000 在 where 条件中使用 in显示 empno 为 7844 , 7839 , 123 , 456 的雇员情况 123456SQL&gt; select * from emp where empno in(7844,7839,123,456); EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7839 KING PRESIDENT 1981-11-17 5000 10 7844 TURNER SALESMAN 7698 1981-09-08 1500 0 30 这种查询效率很高 使用 is null 操作符显示没有上级的雇员情况 12345SQL&gt; select * from emp where mgr is null; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7839 KING PRESIDENT 1981-11-17 5000 10 使用逻辑操作符号查询工资高于 500 或者是岗位为 MANAGER 的雇员，同时还要满足他们的姓名首字母为大写的 J 123456SQL&gt; select * from emp where (sal &gt;500 or job='MANAGER') and ename like 'J%'; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7566 JONES MANAGER 7839 1981-04-02 2975 20 7900 JAMES CLERK 7698 1981-12-03 950 30 这里的括号不可以忘记,否则条件就变了,因为 and 的优先级高于 or 。 使用 order by 子句按照工资从高到低的顺序显示雇员和工资 1234567891011121314151617181920212223SQL&gt; select ename,sal from emp order by sal desc;ENAME SAL-------------------- ----------KING 5000FORD 3000SCOTT 3000JONES 2975BLAKE 2850CLARK 2450ALLEN 1600TURNER 1500MILLER 1300WARD 1250MARTIN 1250ENAME SAL-------------------- ----------ADAMS 1100JAMES 950SMITH 800已选择14行。 desc 为降序， asc 为升序(默认) 照部门号升序而雇员工资降序排列(知道某和部门最高工资的员工和最低工资的员工是谁) 1234567891011121314151617181920212223SQL&gt; select * from emp order by deptno asc,sal desc; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7839 KING PRESIDENT 1981-11-17 5000 10 7782 CLARK MANAGER 7839 1981-06-09 2450 10 7934 MILLER CLERK 7782 1982-01-23 1300 10 7788 SCOTT ANALYST 7566 1987-04-19 3000 20 7902 FORD ANALYST 7566 1981-12-03 3000 20 7566 JONES MANAGER 7839 1981-04-02 2975 20 7876 ADAMS CLERK 7788 1987-05-23 1100 20 7369 SMITH CLERK 7902 1980-12-17 800 20 7698 BLAKE MANAGER 7839 1981-05-01 2850 30 7499 ALLEN SALESMAN 7698 1981-02-20 1600 300 30 7844 TURNER SALESMAN 7698 1981-09-08 1500 0 30 EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7654 MARTIN SALESMAN 7698 1981-09-28 1250 1400 30 7521 WARD SALESMAN 7698 1981-02-22 1250 500 30 7900 JAMES CLERK 7698 1981-12-03 950 30已选择14行。 使用列的别名排序1234567891011121314151617181920212223SQL&gt; select ename,sal * 12 "年薪" from emp order by "年薪" asc;ENAME 年薪-------------------- ----------SMITH 9600JAMES 11400ADAMS 13200WARD 15000MARTIN 15000MILLER 15600TURNER 18000ALLEN 19200CLARK 29400BLAKE 34200JONES 35700ENAME 年薪-------------------- ----------SCOTT 36000FORD 36000KING 60000已选择14行。 Oracle 的复杂查询在实际应用中经常需要执行复杂的数据统计,经常需要现实多张表的数据，所以经常要用到数据分组函数如 max() , min() , avg() , sum() , count() 等。 分组函数显示所有员工中最高工资和最低工资 12345SQL&gt; select max(sal),min(sal) from emp; MAX(SAL) MIN(SAL)---------- ---------- 5000 800 注意如果列里面有一个分组函数，其它的都必须是分组函数， 否则就出错；如本例中不能写成： 12345SQL&gt; select ename, sal from emp where sal = max(sal);select ename, sal from emp where sal = max(sal) *第 1 行出现错误:ORA-00934: 此处不允许使用分组函数 因为： max 是分组函数，而 ename 不是分组函数。 查询最高，最低工资的员工(利用子查询) 1234567891011SQL&gt; select ename,sal from emp where sal = (select max(sal) from emp);ENAME SAL-------------------- ----------KING 5000SQL&gt; select ename,sal from emp where sal = (select min(sal) from emp);ENAME SAL-------------------- ----------SMITH 800 示工资最高的员工的名字，工作岗位 12345SQL&gt; select ename,job from emp where sal = (select max(sal) from emp);ENAME JOB-------------------- ------------------KING PRESIDENT 显示工资高于平均工资的员工信息 首先我们可以查询所有员工的平均工资 12345SQL&gt; select avg(sal) from emp; AVG(SAL)----------2073.21429 然后再查询高于平均工资的员工信息 123456789101112SQL&gt; select * from emp where sal &gt; 2073; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7566 JONES MANAGER 7839 1981-04-02 2975 20 7698 BLAKE MANAGER 7839 1981-05-01 2850 30 7782 CLARK MANAGER 7839 1981-06-09 2450 10 7788 SCOTT ANALYST 7566 1987-04-19 3000 20 7839 KING PRESIDENT 1981-11-17 5000 10 7902 FORD ANALYST 7566 1981-12-03 3000 20已选择6行。 当然也可以利用子查询 123456789101112SQL&gt; select * from emp where sal &gt; (select avg(sal) from emp); EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7566 JONES MANAGER 7839 1981-04-02 2975 20 7698 BLAKE MANAGER 7839 1981-05-01 2850 30 7782 CLARK MANAGER 7839 1981-06-09 2450 10 7788 SCOTT ANALYST 7566 1987-04-19 3000 20 7839 KING PRESIDENT 1981-11-17 5000 10 7902 FORD ANALYST 7566 1981-12-03 3000 20已选择6行。 如果这里不是 * 号而是 ename,sal 等字段与分组函数那么在语句的最后要加上 group by ename,sal..(与 select 后的字段一致) 123456789101112SQL&gt; select ename,sal from emp where sal &gt; (select avg(sal) from emp) group by ename,sal;ENAME SAL-------------------- ----------JONES 2975SCOTT 3000KING 5000BLAKE 2850CLARK 2450FORD 3000已选择6行。 group by 和 having 子句group by 用于对查询结果分组统计having 子句用于限制分组显示结果 显示每个部门的平均工资和最高工资 1234567SQL&gt; select avg(sal),max(sal),deptno from emp group by deptno; AVG(SAL) MAX(SAL) DEPTNO---------- ---------- ----------1566.66667 2850 30 2175 3000 202916.66667 5000 10 分组字段依据必须出现在查询结果中，否则结果可读性太差。 显示每个部门的每种岗位的平均工资和最低工资 123456789101112131415SQL&gt; select avg(sal),min(sal),deptno,job from emp group by job,deptno; AVG(SAL) MIN(SAL) DEPTNO JOB---------- ---------- ---------- ------------------ 2975 2975 20 MANAGER 5000 5000 10 PRESIDENT 1300 1300 10 CLERK 1400 1250 30 SALESMAN 3000 3000 20 ANALYST 2850 2850 30 MANAGER 2450 2450 10 MANAGER 950 950 30 CLERK 950 800 20 CLERK已选择9行。 显示平均工资低于 2000 的部门号和它的平均工资与最高工资 12345SQL&gt; select avg(sal),max(sal),deptno from emp group by deptno having avg(sal) &lt; 2000; AVG(SAL) MAX(SAL) DEPTNO---------- ---------- ----------1566.66667 2850 30 对分组函数的总结 分组函数只能出现在选择列表, having , group by , order by 子句中 如果在select语句中同时包含有 group by , having , order by ,那么顺序为 group by , having , order by 在选择列中如果有列,表达式,和分组函数,那么这些列表达式必须有一个出现在 group by 子句中,否则出错 如: 1select deptno,avg(sal),max(sal) from emp group by deptno having avg(sal) &gt; 2000; /*这里的deptno就一定要出现在group by中*/ 多表查询基于两个或两个以上的表或是视图的查询，查单表满足不了要求，如部门和员工的关系。 1234567891011121314151617181920212223SQL&gt; select a.ename,a.sal,b.dname from emp a,dept b where a.deptno = b.deptno;ENAME SAL DNAME-------------------- ---------- ----------------------------CLARK 2450 ACCOUNTINGKING 5000 ACCOUNTINGMILLER 1300 ACCOUNTINGJONES 2975 RESEARCHFORD 3000 RESEARCHADAMS 1100 RESEARCHSMITH 800 RESEARCHSCOTT 3000 RESEARCHWARD 1250 SALESTURNER 1500 SALESALLEN 1600 SALESENAME SAL DNAME-------------------- ---------- ----------------------------JAMES 950 SALESBLAKE 2850 SALESMARTIN 1250 SALES已选择14行。 如果不加 where 子句,就会产生笛卡尔集,所谓笛卡尔集,就是不加筛选,将所有的都查询出来。 结论：两张表关联,至少需要一个条件排除笛卡尔集三张表关联,至少需要二个条件排除笛卡尔集以此类推:多表查询中,判断条件至少是表的个数 -1。 显示部门号为10的部门名,员工名和工资 1234567SQL&gt; select d.dname,e.ename,e.sal from emp e,dept d where e.deptno = d.deptno and d.deptno = 10;DNAME ENAME SAL---------------------------- -------------------- ----------ACCOUNTING CLARK 2450ACCOUNTING KING 5000ACCOUNTING MILLER 1300 显示各个员工的姓名,工资及工资的级别 123456789101112131415161718192021222324252627282930313233SQL&gt; select * from salgrade; /*先查看 salgrade 的表结构和记录*/ GRADE LOSAL HISAL---------- ---------- ---------- 1 700 1200 2 1201 1400 3 1401 2000 4 2001 3000 5 3001 9999SQL&gt; select e.ename,e.sal,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal;ENAME SAL GRADE-------------------- ---------- ----------SMITH 800 1JAMES 950 1ADAMS 1100 1WARD 1250 2MARTIN 1250 2MILLER 1300 2TURNER 1500 3ALLEN 1600 3CLARK 2450 4BLAKE 2850 4JONES 2975 4ENAME SAL GRADE-------------------- ---------- ----------SCOTT 3000 4FORD 3000 4KING 5000 5已选择14行。 这里用到了 between … and 子句,表示在 losal 和 hisal 之间。 显示雇员名,雇员工资及所在部门的名字,并部门排序 1234567891011121314151617181920212223SQL&gt; select e.ename,e.sal,d.dname from emp e,dept d where e.deptno = d.deptno order by e.deptno;ENAME SAL DNAME-------------------- ---------- ----------------------------CLARK 2450 ACCOUNTINGKING 5000 ACCOUNTINGMILLER 1300 ACCOUNTINGJONES 2975 RESEARCHFORD 3000 RESEARCHADAMS 1100 RESEARCHSMITH 800 RESEARCHSCOTT 3000 RESEARCHWARD 1250 SALESTURNER 1500 SALESALLEN 1600 SALESENAME SAL DNAME-------------------- ---------- ----------------------------JAMES 950 SALESBLAKE 2850 SALESMARTIN 1250 SALES已选择14行。 如果用 group by ,一定要把 e.deptno 放到查询列里面。 自连接自连接是指在同一张表的连接查询。 显示某个员工的上级领导的姓名 12345SQL&gt; select worker.ename,boss.ename from emp worker,emp boss where worker.mgr = boss.empno and worker.ename = 'FORD';ENAME ENAME-------------------- --------------------FORD JONES 根据 FORD 的名字找到 FORD 的 mgr 编号再根据这个编号找到 boss 的 empno,最后显示出来。 子查询子查询:指嵌入在其他 SQL 语句中的 select 语句,也叫做嵌套查询。 单行子查询指只返回一行数据的子查询语句。 显示与 SMITH 同一部门的所有员工 分两步: 查出 SMITH 所在部门 根据部门查出所有员工 123456789101112131415SQL&gt; select deptno from emp where ename = 'SMITH'; DEPTNO---------- 20SQL&gt; select * from emp where deptno = (select deptno from emp where ename = 'SMITH'); EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7369 SMITH CLERK 7902 1980-12-17 800 20 7566 JONES MANAGER 7839 1981-04-02 2975 20 7788 SCOTT ANALYST 7566 1987-04-19 3000 20 7876 ADAMS CLERK 7788 1987-05-23 1100 20 7902 FORD ANALYST 7566 1981-12-03 3000 20 数据库在执行 SQL 是从左到右扫描的， 如果有括号的话，括号里面的先被优先执行。 多行子查询返回多行数据的子查询 查询和部门 10 的工作相同的雇员的名字,岗位,工资,部门号 1.首先查出部门 10 的工作种类 1234567SQL&gt; select job from emp where deptno = 10;JOB------------------MANAGERPRESIDENTCLERK 发现有重复结果,所以在 job 前加上 distinct 1234567SQL&gt; select distinct job from emp where deptno = 10;JOB------------------CLERKPRESIDENTMANAGER 2.根据工作的种类查询 1234567891011121314SQL&gt; select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno = 10);ENAME JOB SAL DEPTNO-------------------- ------------------ ---------- ----------CLARK MANAGER 2450 10BLAKE MANAGER 2850 30JONES MANAGER 2975 20KING PRESIDENT 5000 10MILLER CLERK 1300 10JAMES CLERK 950 30ADAMS CLERK 1100 20SMITH CLERK 800 20已选择8行。 注意这里 job 之后用的是” in “而非” = “,因为等号 = 是一对一的。 all 操作符显示工资比部门 30 的所有员工的工资高的员工的姓名,工资和部门号 12345678SQL&gt; select ename,sal,deptno from emp where sal &gt; all (select sal from emp where deptno = 30);ENAME SAL DEPTNO-------------------- ---------- ----------JONES 2975 20SCOTT 3000 20FORD 3000 20KING 5000 10 也可以使用 max 方法 12345678SQL&gt; select ename,sal,deptno from emp where sal &gt; (select max(sal) from emp where deptno = 30);ENAME SAL DEPTNO-------------------- ---------- ----------JONES 2975 20SCOTT 3000 20KING 5000 10FORD 3000 20 max 方法的效率较高,原因是使用 all 操作符时,要和子查询所得结果逐一比较而使用 max 只需和 sal 中的最大值比较,减少了比较的次数,缩短了时间。数据量较大是会比较明显,数据量较小基本看不出来。 any 操作符显示工资比部门 30 的任意一个员工的工资高的员工的姓名,工资和部门号 123456789101112131415161718192021SQL&gt; select ename,sal,deptno from emp where sal &gt; any (select sal from emp where deptno = 30);ENAME SAL DEPTNO-------------------- ---------- ----------KING 5000 10FORD 3000 20SCOTT 3000 20JONES 2975 20BLAKE 2850 30CLARK 2450 10ALLEN 1600 30TURNER 1500 30MILLER 1300 10WARD 1250 30MARTIN 1250 30ENAME SAL DEPTNO-------------------- ---------- ----------ADAMS 1100 20已选择12行。 也可以使用 min 方法 123456789101112131415161718192021SQL&gt; select ename,sal,deptno from emp where sal &gt; (select min(sal) from emp where deptno = 30);ENAME SAL DEPTNO-------------------- ---------- ----------ALLEN 1600 30WARD 1250 30JONES 2975 20MARTIN 1250 30BLAKE 2850 30CLARK 2450 10SCOTT 3000 20KING 5000 10TURNER 1500 30ADAMS 1100 20FORD 3000 20ENAME SAL DEPTNO-------------------- ---------- ----------MILLER 1300 10已选择12行。 原理同上 多列子查询单行子查询是指子查询只返回单列、单行数据，多行子查询是指返回单列多行数据， 都是针对单列而言的，而多列子查询是指查询返回多个列数据的子查询语句。 查询与 SMITH 的部门和岗位完全相同的所有雇员 1.查询出 SMITH 的部门号,岗位 12345SQL&gt; select deptno,job from emp where ename = 'SMITH'; DEPTNO JOB---------- ------------------ 20 CLERK 2.显示结果 123456SQL&gt; select * from emp where (deptno,job) = (select deptno,job from emp where ename = 'SMITH'); EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7369 SMITH CLERK 7902 1980-12-17 800 20 7876 ADAMS CLERK 7788 1987-05-23 1100 20 在 from 子句中使用子查询显示高于自己部门的平均工资员工信息 1.查询各个部门的平均工资和部门号 1234567SQL&gt; select avg(sal),deptno from emp group by deptno; AVG(SAL) DEPTNO---------- ----------1566.66667 30 2175 202916.66667 10 2.把上面的查询看作是一张子表 123456789101112SQL&gt; select e.ename,e.deptno,e.sal,ds.mysal from emp e,(select deptno, avg(sal) mysal from emp group by deptno) ds where e.deptno = ds.deptno and e.sal &gt; ds.mysal;ENAME DEPTNO SAL MYSAL-------------------- ---------- ---------- ----------ALLEN 30 1600 1566.66667JONES 20 2975 2175BLAKE 30 2850 1566.66667SCOTT 20 3000 2175KING 10 5000 2916.66667FORD 20 3000 2175已选择6行。 将这两个表做关联查询,当在 from 子句中使用子查询时,该子查询会被作为一个视图来对待,因此叫做内嵌视图,当在 from 子句中使用子查询时,必须为子查询指定别名。 注意：别名不能用 as ,如: 12345SQL&gt; select e.ename,e.deptno,e.sal,ds.mysal from emp e,(select deptno, avg(sal) mysal from emp group by deptno) as ds where e.deptno = ds.deptno and e.sal &gt; ds.mysal;select e.ename,e.deptno,e.sal,ds.mysal from emp e,(select deptno, avg(sal) mysal from emp group by deptno) as ds where e.deptno = ds.deptno and e.sal &gt; ds.mysal *第 1 行出现错误:ORA-00933: SQL 命令未正确结束 在 ds 前不能加 as ,否则会报错 (给表取别名的时候，不能加 as ;但是给列取别名，是可以加 as 的)。 Oracle 的分页Oracle 的分页一共有三种方式: 根据 rowid 来分（效率最好） 按分析函数来分（效率次之） 按 rownum 来分（效率最差） 下面最主要介绍第三种：按 rownum 来分 12345678910SQL&gt; select * from (select a.*,rownum rn from (select * from emp) a where rownum &lt;= 15) where rn &gt; 10; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO RN---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- ---------- 7876 ADAMS CLERK 7788 1987-05-23 1100 20 11 7900 JAMES CLERK 7698 1981-12-03 950 30 12 7902 FORD ANALYST 7566 1981-12-03 3000 20 13 7934 MILLER CLERK 7782 1982-01-23 1300 10 14已用时间: 00: 00: 00.02 这条语句是用来将 11-15 条记录提取出来,拆分这条语句: 1.将所有想要的结果查询出来 12345678910111213141516171819202122232425SQL&gt; select * from emp; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7369 SMITH CLERK 7902 1980-12-17 800 20 7499 ALLEN SALESMAN 7698 1981-02-20 1600 300 30 7521 WARD SALESMAN 7698 1981-02-22 1250 500 30 7566 JONES MANAGER 7839 1981-04-02 2975 20 7654 MARTIN SALESMAN 7698 1981-09-28 1250 1400 30 7698 BLAKE MANAGER 7839 1981-05-01 2850 30 7782 CLARK MANAGER 7839 1981-06-09 2450 10 7788 SCOTT ANALYST 7566 1987-04-19 3000 20 7839 KING PRESIDENT 1981-11-17 5000 10 7844 TURNER SALESMAN 7698 1981-09-08 1500 0 30 7876 ADAMS CLERK 7788 1987-05-23 1100 20 EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- 7900 JAMES CLERK 7698 1981-12-03 950 30 7902 FORD ANALYST 7566 1981-12-03 3000 20 7934 MILLER CLERK 7782 1982-01-23 1300 10已选择14行。已用时间: 00: 00: 00.08 2.将上一步的结果作为一个视图,给每一条记录加上一个 rn 编号并将前 15 条记录查询出来;其中 rownum 为 Oracle 的关键字,且在第一次在查询字段中使用 rownum 时,如果有条件限制在 where 子句中也要用 rownum,不可以用 rn。 12345678910111213141516171819202122232425SQL&gt; select a.*,rownum rn from (select * from emp) a where rownum &lt;= 15; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO RN---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- ---------- 7369 SMITH CLERK 7902 1980-12-17 800 20 1 7499 ALLEN SALESMAN 7698 1981-02-20 1600 300 30 2 7521 WARD SALESMAN 7698 1981-02-22 1250 500 30 3 7566 JONES MANAGER 7839 1981-04-02 2975 20 4 7654 MARTIN SALESMAN 7698 1981-09-28 1250 1400 30 5 7698 BLAKE MANAGER 7839 1981-05-01 2850 30 6 7782 CLARK MANAGER 7839 1981-06-09 2450 10 7 7788 SCOTT ANALYST 7566 1987-04-19 3000 20 8 7839 KING PRESIDENT 1981-11-17 5000 10 9 7844 TURNER SALESMAN 7698 1981-09-08 1500 0 30 10 7876 ADAMS CLERK 7788 1987-05-23 1100 20 11 EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO RN---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- ---------- 7900 JAMES CLERK 7698 1981-12-03 950 30 12 7902 FORD ANALYST 7566 1981-12-03 3000 20 13 7934 MILLER CLERK 7782 1982-01-23 1300 10 14已选择14行。已用时间: 00: 00: 00.03 3.将前 15 条数据作为一个视图,提取出 11-15 条。 12345678910SQL&gt; select * from (select a.*,rownum rn from (select * from emp) a where rownum &lt;=15) where rn &gt; 10; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO RN---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- ---------- 7876 ADAMS CLERK 7788 1987-05-23 1100 20 11 7900 JAMES CLERK 7698 1981-12-03 950 30 12 7902 FORD ANALYST 7566 1981-12-03 3000 20 13 7934 MILLER CLERK 7782 1982-01-23 1300 10 14已用时间: 00: 00: 00.01 在 Java 程序中只需要替换 15 和 10 这两个数字就可以实现分页了。 用查询结果创建新表这个命令是一种快捷的建表方法 123456789101112131415SQL&gt; select * from (select a.*,rownum rn from (select * from emp) a where rownum &lt;=15) where rn &gt; 10; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO RN---------- -------------------- ------------------ ---------- ---------- ---------- ---------- ---------- ---------- 7876 ADAMS CLERK 7788 1987-05-23 1100 20 11 7900 JAMES CLERK 7698 1981-12-03 950 30 12 7902 FORD ANALYST 7566 1981-12-03 3000 20 13 7934 MILLER CLERK 7782 1982-01-23 1300 10 14已用时间: 00: 00: 00.01SQL&gt; create table mytable(id,name,sal,job,deptno) as select empno,ename,sal,job,deptno from emp;表已创建。已用时间: 00: 00: 00.64 创建好之后,我们可以查看一下表结构 1234567891011121314151617181920SQL&gt; desc mytable; 名称 是否为空? 类型 ----------------------------------------------------- -------- ------------------------------------ ID NUMBER(4) NAME VARCHAR2(10) SAL NUMBER(7,2) JOB VARCHAR2(9) DEPTNO NUMBER(2)SQL&gt; desc emp; 名称 是否为空? 类型 ----------------------------------------------------- -------- ------------------------------------ EMPNO NOT NULL NUMBER(4) ENAME VARCHAR2(10) JOB VARCHAR2(9) MGR NUMBER(4) HIREDATE DATE SAL NUMBER(7,2) COMM NUMBER(7,2) DEPTNO NUMBER(2) 可以看出，新建表的字段类型和查询表的一样。 合并查询有时在实际应用中，为了合并多个 select 语句的结果，可以使用集合操作符号 union, union all, intersect (交集), minus (差集) 多用于数据量比较大的数据局库，运行速度快。 union该操作符用于取得两个结果集的并集。当使用该操作符时，会自动去掉结果集中重复行。 1234567891011121314SQL&gt; select ename,sal,job from emp where sal &gt; 2500 union select ename,sal,job from emp where job = 'MANAGER';ENAME SAL JOB-------------------- ---------- ------------------BLAKE 2850 MANAGERCLARK 2450 MANAGERFORD 3000 ANALYSTJONES 2975 MANAGERKING 5000 PRESIDENTSCOTT 3000 ANALYST已选择6行。已用时间: 00: 00: 00.00 union all该操作符与 union 相似，但是它不会取消重复行，而且不会排序。 12345678910111213141516SQL&gt; select ename,sal,job from emp where sal &gt; 2500 union all select ename,sal,job from emp where job = 'MANAGER';ENAME SAL JOB-------------------- ---------- ------------------JONES 2975 MANAGERBLAKE 2850 MANAGERSCOTT 3000 ANALYSTKING 5000 PRESIDENTFORD 3000 ANALYSTJONES 2975 MANAGERBLAKE 2850 MANAGERCLARK 2450 MANAGER已选择8行。已用时间: 00: 00: 00.01 intersect使用该操作符用于取得两个结果集的交集。 12345678SQL&gt; select ename,sal,job from emp where sal &gt; 2500 intersect select ename,sal,job from emp where job = 'MANAGER';ENAME SAL JOB-------------------- ---------- ------------------BLAKE 2850 MANAGERJONES 2975 MANAGER已用时间: 00: 00: 00.00 minus使用改操作符用于取得两个结果集的差集， 他只会显示存在第一个集合中， 而不存在第二个集合中的数据。 123456789SQL&gt; select ename,sal,job from emp where sal &gt; 2500 minus select ename,sal,job from emp where job = 'MANAGER';ENAME SAL JOB-------------------- ---------- ------------------FORD 3000 ANALYSTKING 5000 PRESIDENTSCOTT 3000 ANALYST已用时间: 00: 00: 00.00 集合操作要比 and， or 效率高很多。 操作数据使用特定的格式插入日期值。 使用to_date函数插入带有日期的表,并按照年月日格式插入 12345SQL&gt; insert into emp values(9999,'huang','PERSIDENT',null,to_date('1997-01-01','YYYY-MM-DD'),800,1000,10);已创建 1 行。已用时间: 00: 00: 00.06 使用 to_date 函数可以插入任意形式的日期 使用子查询插入数据一条 insert 语句可以插入大量的数据，当处理行迁移或者装载外部表的数据到数据库时, 可以使用子查询插入数据。 12345678910111213141516171819202122232425262728293031323334SQL&gt; insert into mytable(id,name,deptno) select empno,ename,deptno from emp where deptno = 10;已创建4行。已用时间: 00: 00: 00.02SQL&gt; select * from mytable; ID NAME SAL JOB DEPTNO---------- -------------------- ---------- ------------------ ---------- 7369 SMITH 800 CLERK 20 7499 ALLEN 1600 SALESMAN 30 7521 WARD 1250 SALESMAN 30 7566 JONES 2975 MANAGER 20 7654 MARTIN 1250 SALESMAN 30 7698 BLAKE 2850 MANAGER 30 7782 CLARK 2450 MANAGER 10 7788 SCOTT 3000 ANALYST 20 7839 KING 5000 PRESIDENT 10 7844 TURNER 1500 SALESMAN 30 7876 ADAMS 1100 CLERK 20 ID NAME SAL JOB DEPTNO---------- -------------------- ---------- ------------------ ---------- 7900 JAMES 950 CLERK 30 7902 FORD 3000 ANALYST 20 7934 MILLER 1300 CLERK 10 7782 CLARK 10 7839 KING 10 7934 MILLER 10 9999 huang 10已选择18行。已用时间: 00: 00: 00.02 后面 4 行为新插入的数据。 使用子查询更新数据希望员工 huang 的岗位、工资与 SCOOT 一样 12345678910111213141516171819202122232425262728293031323334SQL&gt; update mytable set(job,sal) = (select job,sal from mytable where name='SCOTT') where name = 'huang';已更新 1 行。已用时间: 00: 00: 00.00SQL&gt; select * from mytable; ID NAME SAL JOB DEPTNO---------- -------------------- ---------- ------------------ ---------- 7369 SMITH 800 CLERK 20 7499 ALLEN 1600 SALESMAN 30 7521 WARD 1250 SALESMAN 30 7566 JONES 2975 MANAGER 20 7654 MARTIN 1250 SALESMAN 30 7698 BLAKE 2850 MANAGER 30 7782 CLARK 2450 MANAGER 10 7788 SCOTT 3000 ANALYST 20 7839 KING 5000 PRESIDENT 10 7844 TURNER 1500 SALESMAN 30 7876 ADAMS 1100 CLERK 20 ID NAME SAL JOB DEPTNO---------- -------------------- ---------- ------------------ ---------- 7900 JAMES 950 CLERK 30 7902 FORD 3000 ANALYST 20 7934 MILLER 1300 CLERK 10 7782 CLARK 10 7839 KING 10 7934 MILLER 10 9999 huang 3000 ANALYST 10已选择18行。已用时间: 00: 00: 00.02 name 的值要用大写, Oracle 对值的大小写是敏感的。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构——Redis进阶]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E2%80%94%E2%80%94Redis%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式架构 Redis]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E2%80%94%E2%80%94Redis%2F</url>
    <content type="text"><![CDATA[分布式应用程序就是指应用程序分布在不同计算机上，通过网络来共同完成一项任务，通常为服务器/客户端模式。更广义上理解“分布”，不只是应用程序，还包括数据库等，分布在不同计算机，完成同一个任务。这种架构提供了负载均衡的能力，大大提高了系统负载能力，解决了网站高并发的需求。 分布式的特点优点 降低了耦合度：把模块拆分,使用接口通信,降低模块之间的耦合度。 责任清晰：把项目拆分成若干个子项目,不同的团队负责不同的子项目。 扩展方便：增加功能时只需要再增加一个子项目,调用其他系统的接口就可以。 部署方便:可以灵活的进行分布式部署。 提高代码的复用性：比如 Service 层，如果不采用分布式 REST 服务（REST 服务是一种 Web 服务架构，其目标是为了创建具有良好扩展性的分布式系统）方式架构就会在手机 WAP 商城，微信商城，PC， Android， IOS 每个端都要写一个 Service 层逻辑,开发量大,难以维护一起升级，这时候就可以采用分布式 REST 服务方式，公用一个 Service 层。 缺点 系统之间的交互要使用远程通信,接口开发增大工作量,但是利大于弊。 Redis 简介Redis 介绍Remote Dictionary Server（Redis)）是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的 Key-Value 数据库。 Key 字符类型， 其值（value）可以是字符串（String）, 哈希（Map）, 列表（list）, 集合（sets）和有序集合（sorted sets）等类型， 每种数据类型有自己的专属命令。 所以它通常也被称为数据结构服务器。 主要特点 Redis 数据库完全在内存中，使用磁盘仅用于持久性。 与许多键值数据存储相比， Redis 拥有一套较为丰富的数据类型。 Redis 可以将数据复制到任意数量的从服务器 在Linux 使用 RedisRedis 在 Linux 系统上发挥的性能比在 Windows 系统上好。 启动 Redis前台启动进入 Redis 的安装路径 123[huang@localhost home]$ cd /usr/local[huang@localhost local]$ cd redis-3.2.10/[huang@localhost redis-3.2.10]$ cd src Redis 应用以前台的方式启动，不能退出当前窗口， 退出窗口，应用终止。 1[huang@localhost src]$ ./redis-server 在其他窗口查看 Redis 启动的进程 后台启动Redis 应用以后台的方式启动，关闭窗口，查看 Redis 进程，依然存在。 1[huang@localhost src]$ ./redis-server &amp; 关闭 RedisRedis 数据类型操作命令字符串类型 string字符串类型是 Redis 中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据，序列化后的数据， JSON 化的对象甚至是一张图片（描述大段的文本信息）。最大 512M。 key value username 张三和李四 基本命令set将字符串值 value 设置到 key 中 语法： set key value 查看已经插入的 key 向已经存在的 key 设置新的 value，会覆盖原来的值 get获取 key 中设置的字符串值。 语法： get key 例如：获取 username 这个 key 对应的 value incr将 key 中储存的数字值加 1，如果 key 不存在，则 key 的值先被初始化为 0 再执行 incr 操作（只能对数字类型的数据操作）。 语法： incr key decr将 key 中储存的数字值减1，如果 key 不存在，则么 key 的值先被初始化为 0 再执行 decr 操作（只能对数字类型的数据操作）。 语法： decr key append语法： append key value 如果 key 存在， 则将 value 追加到 key 原来旧值的末尾，如果 key 不存在， 则将 key 设置值为 value。 返回值：追加字符串之后的总长度。 常用命令strlen语法： strlen key 说明： 返回 key 所储存的字符串值的长度。 返回值： 如果key存在，返回字符串值的长度 key不存在，返回0 getrange语法： getrange key start end 作用： 获取 key 中字符串值从 start 开始 到 end 结束 的子字符串,包括 start 和 end, 负数表示从字符串的末尾开始， -1 表示最后一个字符。 返回值： 截取的子字符串。 使用的字符串 key: school, value: guangxian setrange语法： setrange key offset value 说明： 用 value 覆盖（替换） key 的存储的值从 offset 开始,不存在的 key 做空白字符串。 返回值： 修改后的字符串的长度。 mset语法： mset key value [key value…] 说明： 同时设置一个或多个 key-value 对。 返回值： OK mget语法： mget key [key …] 作用： 获取所有(一个或多个)给定 key 的值。 返回值： 包含所有 key 的列表。 哈希类型 hashRedis hash 是一个 string 类型的 field 和 value 的映射表， hash 特别适合用于存储对象（存对象， Redis 中所有的 key 都是文本类型）。 key loginuser filed value unname 张三 times 5 region 北京 基本命令hset语法： hset hash 表的 key field value 作用： 将哈希表 key 中的域 field 的值设为 value ， 如果 key 不存在， 则新建 hash 表，执行赋值，如果有 field ,则覆盖值。 返回值： 如果 field 是 hash 表中新 field，且设置值成功，返回 1 如果 field 已经存在，旧值覆盖新值，返回 0 hget语法： hget key field 作用： 获取哈希表 key 中给定域 field 的值。 返回值： field 域的值，如果 key 不存在或者 field 不存在返回 nil hmset语法： hmset key field value [field value…] 说明： 同时将多个 field-value (域-值)设置到哈希表 key 中，此命令会覆盖已经存在的 field，hash 表 key 不存在，创建空的 hash 表，执行 hmset。 返回值：设置成功返回 ok， 如果失败返回一个错误 hmget语法： hmget key field [field…] 作用:获取哈希表 key 中一个或多个给定域的值。 返回值：返回和 field 顺序对应的值，如果 field 不存在，返回 nil hgetall语法： hgetall key 作用： 获取哈希表 key 中所有的域和值。 返回值：以列表形式返回 hash 中域和域的值 ， key 不存在，返回空 hash hdel语法： hdel key field [field…] 作用： 删除哈希表 key 中的一个或多个指定域 field，不存在 field 直接忽略。 返回值：成功删除的 field 的数量 常用命令hkeys语法： hkeys key 作用：查看哈希表 key 中的所有 field 域。 返回值：包含所有 field 的列表， key 不存在返回空列表 hvals语法： hvals key 作用： 返回哈希表 中所有域的值。 返回值：包含哈希表所有域值的列表， key 不存在返回空列表 hexists语法： hexists key field 作用： 查看哈希表 key 中，给定域 field 是否存在。 返回值： 如果 field 存在，返回 1， 其他返回 0 列表 listRedis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素导列表的头部（左边）或者尾部（右边）(保证数据出现的顺序，按照一定顺序出现)。 key value region 北京 上海 天津 基本命令lpush语法： lpush key value [value…] 作用： 将一个或多个值 value 插入到列表 key 的表头（最左边），从左边开始加入值， 从左到右的顺序依次插入到表头。 返回值： 数字， 新列表的长度 rpush语法： rpush key value [value…] 作用： 将一个或多个值 value 插入到列表 key 的表尾（最右边）， 各个 value 值按从左到右的顺序依次插入到表尾。 返回值：数字，新列表的长度 lrange语法： lrange key start stop 作用： 获取列表 key 中指定区间内的元素， 0 表示列表的第一个元素，以 1 表示列表的第二个元素； start , stop 是列表的下标值，也可以负数的下标， -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 start ， stop 超出列表的范围不会出现错误。 返回值： 指定区间的列表 lindex语法： lindex key index 作用： 获取列表 key 中下标为指定 index 的元素， 列表元素不删除， 只是查询。 0 表示列表的第一个元素，以 1 表示列表的第二个元素； start , stop 是列表的下标值，也可以负数的下标， -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 返回值：指定下标的元素； index 不在列表范围，返回 nil llen语法： llen key 作用： 获取列表 key 的长度。 返回值： 数值，列表的长度； key 不存在返回 0 常用命令lrem语法： lrem key count value 作用： 根据参数 count 的值，移除列表中与参数 value 相等的元素， count &gt;0 ， 从列表的左侧向右开始移除； count &lt; 0 从列表的尾部开始移除； count = 0 移除表中所有与 value 相等的值。 返回值： 数值，移除的元素个数 lset语法： lset key index value 作用： 将列表 key 下标为 index 的元素的值设置为 value。 返回值：设置成功返回 ok ; key 不存在或者 index 超出范围返回错误信息 linsert语法： linsert key BEFORE|ALFTER pivot value 作用： 将值 value 插入到列表 key 当中位于值 pivot 之前或之后的位置。 key 不存在， pivot 不在列表中，不执行任何操作。 返回值： 命令执行成功，返回新列表的长度。没有找到 pivot 返回 -1， key 不存在返回 0 集合类型 setRedis 的 set 是 string 类型的无序集合，集合成员是唯一的，即集合中不能出现重复的数据。 key value framework spring mybatis struts 有序集合类型 zset (sorted set)Redis 有序集合 zset 和集合 set 一样也是 string 类型元素的集合，且不允许重复的成员。不同的是 zset 的每个元素都会关联一个分数（分数可以重复）， Redis 通过分数来为集合中的成员进行从小到大的排序。 key value score salary 张三 3500 李四 5000 王五 8000 未完……]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常用的注解]]></title>
    <url>%2F2019%2F08%2F23%2FJava%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解本身没有功能的，就和 xml 一样。注解和 xml 都是一种元数据，元数据即解释数据的数据，这就是所谓配置。 Spring 部分声明 bean 的注解@Component 组件，没有明确的角色，在类上使用注解@Component，该注解的 value 属性用于指定该 bean 的 id 值 @Repository 用于对 DAO 实现类进行注解 @Service 用于对 Service 实现类进行注解 @Controller 用于对 Controller 实现类进行注解 注入 bean 的注解@Autowired：由 Spring 提供 @Inject：由 JSR-330 提供 @Resource：由 JSR-250 提供 都可以注解在 set 方法和属性上，推荐注解在属性上(一目了然，少写代码)。 Java 配置类相关注解@Configuration 表示当前类充当 Spring 容器，即所有的 Bean 将由这个类来创建(类上) @Bean 注解在方法上，声明当前方法的返回值为一个 bean ，替代 xml 中的方式（方法上） @Configuration 声明当前类为配置类，其中内部组合了 @Component 注解，表明这个类是一个 bean (类上) @ComponentScan 用于对 Component 进行扫描，相当于 xml 中的（类上） @WishlyConfiguration 为 @Configuration 与 @ComponentScan 的组合注解，可以替代这两个注解 切面（AOP）相关注解Spring 支持 AspectJ 的注解式切面编程。 @Aspect 指定当前 POJO 类将作为切面(类上) 使用 @After 、 @Before 、 @Around 定义建言 (advice) ，可直接将拦截规则（切点）作为参数。 @After 在方法执行之后执行（方法上） @Before 在方法执行之前执行（方法上） @Around 在方法执行之前与之后执行（方法上） @Pointcut 定义切入点 在 Java 配置类中使用 @EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 代理的支持（类上） @Bean 的属性支持@Scope 设置 Spring 容器如何新建 Bean 实例(方法上，得有 @Bean ) 其设置类型包括： Singleton (单例,一个 Spring 容器中只有一个 bean 实例，默认模式)Protetype (每次调用新建一个 bean )Request ( web 项目中，给每个 http request 新建一个 bean )Session ( web项 目中，给每个 http session 新建一个 bean )GlobalSession (给每一个 global http session 新建一个 Bean 实例) @StepScope 在 Spring Batch 中还有涉及 @PostConstruct 由 JSR-250 提供，在构造函数执行完之后执行，等价于 xml 配置文件中 bean 的 initMethod @PreDestory 由 JSR-250 提供，在 Bean 销毁之前执行，等价于 xml 配置文件中 bean 的 destroyMethod @Value注解@Value 为属性注入值(属性上)支持如下方式的注入： 注入普通字符串123@Value("normal") private String normal 注入文件资源123@Value("classpath:com/huang/spring/configinject/config.txt")private Resource resourceFile; 注入 URL 资源123 @Value("https://www.huangyuanzhi.top")private Resource testUrl; 注入表达式结果123 @Value("#&#123; T(java.lang.Math).random() * 100.0 &#125;")private double randomNumber; 注入其它 bean 属性12@Value("&#123;domeClass.name&#125;")String name; 注入配置文件123@Value("$&#123;book.name&#125;") private String bookName; 注入配置使用方法： (1) 编写配置文件（test.properties） 1book.name=《三体》 (2) @PropertySource 加载配置文件(类上) 1@PropertySource("classpath:com/huang/spring/configinject/config.properties") (3) 还需配置一个 PropertySourcesPlaceholderConfigurer 的 bean 。 环境切换@Profile 通过设定 Environment 的 ActiveProfiles 来设定当前 context 需要使用的配置环境。(类或方法上) @Conditional Spring4 中可以使用此注解定义条件话的 bean ，通过实现 Condition 接口，并重写 matches 方法，从而决定该 bean 是否被实例化。(方法上) 异步相关@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性 AsyncConfigurer 接口(类上) @Async 在实际执行的 bean 方法使用该注解来申明其是一个异步任务(方法上或类上所有的方法都将异步，需要 @EnableAsync 开启异步任务) 定时任务相关@EnableScheduling 在配置类上使用，开启计划任务的支持(类上) @Scheduled 来申明这是一个任务，包括 cron , fixDelay , fixRate 等类型(方法上，需先开启计划任务的支持) @Enable* 注解说明这些注解主要用来开启对xxx的支持。 @EnableAspectJAutoProxy 开启对 AspectJ 自动代理的支持 @EnableAsync 开启异步方法的支持 @EnableScheduling 开启计划任务的支持 @EnableWebMvc 开启 Web MVC 的配置支持 @EnableConfigurationProperties 开启对 @ConfigurationProperties 注解配置 Bean 的支持 @EnableJpaRepositories 开启对 SpringData JPA Repository 的支持 @EnableTransactionManagement 开启注解式事务的支持 @EnableCaching 开启注解式的缓存支持 测试相关注解@RunWith 运行器，Spring 中通常用于对 JUnit 的支持 @ContextConfiguration 用来加载配置 ApplicationContext ，其中 classes 属性用来加载配置类 Spring MVC 部分@EnableWebMvc 在配置类中开启 Web MVC 的配置支持，如一些 ViewResolver 或者 MessageConverter 等，若无此句，重写 WebMvcConfigurerAdapter 方法(用于对 SpringMVC 的配置)。 @Controller 表示当前类为处理器 @RequestMapping 表示当前方法为处理器方法；该方法要对 value 属性所指定的 URL 进行处理与响应； 被注解的方法的方法名可以随意。 @ResponseBody 支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据（返回值旁或方法上） @RequestBody 允许 request 的参数在 request 体中，而不是在直接连接在地址后面。（放在参数前） @PathVariable 用于接收路径参数，比如@ RequestMapping(“/hello/{name}”) 申明的路径，将注解放在参数中前，即可获取该值，通常作为 Restful 的接口实现方法。 @RestController 该注解为一个组合注解，相当于 @Controller 和 @ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了 @ResponseBody。 @ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了 @Controller 的类的方法可使用 @ExceptionHandler 、 @InitBinder 、 @ModelAttribute 注解到方法上，这对所有注解了 @RequestMapping 的控制器内的方法有效。 @ExceptionHandler 用于全局处理控制器里的异常 @InitBinder 用来设置 WebDataBinder ， WebDataBinder 用来自动绑定前台请求参数到 Model 中。 @ModelAttribute 本来的作用是绑定键值对到 Model 里，在 @ControllerAdvice 中是让全局的 @RequestMapping 都能获得在此处设置的键值对。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis常用的设计模式]]></title>
    <url>%2F2019%2F08%2F21%2FMyBatis%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Builder 模式Builder 模式的定义是“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。”，它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和 Builder 模式，相对于工厂模式会产出一个完整的产品，Builder 应用于更加复杂的对象的构建，甚至只会构建产品的一个部分。 在 MyBatis环境的初始化过程中，SqlSessionFactoryBuilder 会调用 XMLConfigBuilder 读取所有的 MyBatisMapConfig.xml 和所有的 *Mapper.xml 文件，构建 MyBatis 运行的核心对象 Configuration 对象，然后将该 Configuration 对象作为参数构建一个 SqlSessionFactory 对象。 其中 XMLConfigBuilder 在构建 Configuration 对象时，也会调用 XMLMapperBuilder 用于读取 *.Mapper 文件，而 XMLMapperBuilder 会使用 XMLStatementBuilder 来读取和 build 所有的 SQL 语句。 在这个过程中，有一个相似的特点，就是这些 Builder 会读取文件或者配置，然后做大量的 XpathParser 解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决。 对于 Builder 的具体类，方法都大都用 build* 开头，比如 SqlSessionFactoryBuilder 为例，它包含以下方法： 即根据不同的输入参数来构建 SqlSessionFactory 这个工厂对象。 工厂模式在 MyBatis 中比如 SqlSessionFactory 使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 简单工厂模式SqlSession 可以认为是一个 MyBatis 工作的核心的接口，通过这个接口可以执行执行 SQL 语句、获取 Mappers 、管理事务。类似于连接 MySQL 的 Connection 对象。 可以看到，该 Factory的openSession 方法重载了很多个，分别支持 autoCommit 、Executor 、Transaction 等参数的输入，来构建核心的 SqlSession 对象。在 DefaultSqlSessionFactory 的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品： 123456789101112131415private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; Transaction tx = null; try &#123; final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); final Executor executor = configuration.newExecutor(tx, execType, autoCommit); return new DefaultSqlSession(configuration, executor); &#125; catch (Exception e) &#123; closeTransaction(tx); // may have fetched a connection so lets call close() throw ExceptionFactory.wrapException("Error opening session. Cause: " + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 是一个 openSession 调用的底层方法，该方法先从 configuration 读取对应的环境配置，然后初始化 TransactionFactory 获得一个 Transaction 对象，然后通过 Transaction 获取一个 Executor 对象，最后通过 configuration、Executor、是否 autoCommit 三个参数构建了 SqlSession。SqlSession 的执行，其实是委托给对应的 Executor 来进行的。 而对于LogFactory，它的实现代码： 123456789public final class LogFactory &#123; private static Constructor&lt;? extends Log&gt; logConstructor; private LogFactory() &#123; // disable construction &#125; public static Log getLog(Class&lt;?&gt; aClass) &#123; return getLog(aClass.getName()); 这里有个特别的地方，Log 变量的的类型是 Constructor&lt;? extendsLog&gt;，也就是说该工厂生产的不只是一个产品，而是具有 Log 公共接口的一系列产品，比如 Log4jImpl、Slf4jImpl 等很多具体的 Log。 单例模式单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。 在 MyBatis 中有两个地方用到单例模式，ErrorContext 和 LogFactory，其中 ErrorContext 是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息，而 LogFactory 则是提供给整个 MyBatis 使用的日志工厂，用于获得针对项目配置好的日志对象。 ErrorContext 的单例实现代码： 123456789101112131415161718192021private static final ThreadLocal&lt;ErrorContext&gt; LOCAL = new ThreadLocal&lt;ErrorContext&gt;();private ErrorContext stored;private String resource;private String activity;private String object;private String message;private String sql;private Throwable cause;private ErrorContext() &#123;&#125;public static ErrorContext instance() &#123; ErrorContext context = LOCAL.get(); if (context == null) &#123; context = new ErrorContext(); LOCAL.set(context); &#125; return context;&#125; 构造函数是 private 修饰，具有一个 static 的局部 instance 变量和一个获取 instance 变量的方法，在获取实例的方法中，先判断是否为空如果是的话就先创建，然后返回构造好的对象。 需要注意的是是，LOCAL 的静态实例变量使用了 ThreadLoca l修饰，也就是说它属于每个线程各自的数据，而在 instance() 方法中，先获取本线程的该实例，如果没有就创建该线程独有的 ErrorContext。 代理模式代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英 文叫做 Proxy 或 Surrogate，它是一种对象结构型模式。代理模式可以认为是 MyBatis 的核心使用的模式，正是由于这个模式，我们只需要编写 Mapper.java 接口，不需要实现，由 MyBatis 后台帮我们完成具体 SQL 的执行。 代理模式包含如下角色： Subject: 抽象主题角色 Proxy: 代理主题角色 RealSubject: 真实主题角色 这里有两个步骤，第一个是提前创建一个Proxy，第二个是使用的时候会自动请求Proxy，然后由Proxy来执行具体事务； 当我们使用 Configuration 的 getMapper 方法时，会调用 mapperRegistry.getMapper 方法，而该方法又会调用 mapperProxyFactory.newInstance(sqlSession) 来生成一个具体的代理： 12345678910111213141516171819202122232425262728public class MapperProxyFactory&lt;T&gt; &#123; private final Class&lt;T&gt; mapperInterface; private Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;(); public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123; return methodCache; &#125; @SuppressWarnings("unchecked") protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy); &#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125;&#125; 在这里，先通过 T newInstance(SqlSession sqlSession) 方法会得到一个 MapperProxy 对象，然后调用 T newInstance(MapperProxy mapperProxy) 生成代理对象然后返回。 而查看 MapperProxy 的代码，可以看到如下内容： 123456789101112131415161718192021222324public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123; private static final long serialVersionUID = -6424540398559729838L; private final SqlSession sqlSession; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache; public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123; this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; this.methodCache = methodCache; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; try &#123; return method.invoke(this, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args); &#125; 这是非常典型的，该 MapperProxy 类实现了 InvocationHandler 接口，并且实现了该接口的 invoke 方法。 通过这种方式，我们只需要编写 Mapper.java 接口类，当真正执行一个 Mapper 接口的时候，就会转发给 MapperProxy.invoke 方法，而该方法则会调用后续的 sqlSession.cud&gt;executor.execute&gt;prepareStatement 等一系列方法，完成 SQL 的执行和返回。 组合模式组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。 组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。 在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。 组合模式MyBatis 支持动态 SQL 的强大功能，比如下面的这个SQL： 123456789101112131415&lt;update id="update" parameterType="org.format.dynamicproxy.mybatis.bean.User"&gt; UPDATE users &lt;trim prefix="SET" prefixOverrides=","&gt; &lt;if test="name != null and name != ''"&gt; name = #&#123;name&#125; &lt;/if&gt; &lt;if test="age != null and age != ''"&gt; , age = #&#123;age&#125; &lt;/if&gt; &lt;if test="birthday != null and birthday != ''"&gt; , birthday = #&#123;birthday&#125; &lt;/if&gt; &lt;/trim&gt; where id = $&#123;id&#125;&lt;/update&gt; 在这里面使用到了 trim、i f等动态元素，可以根据条件来生成不同情况下的 SQL 。 在 DynamicSqlSource.getBoundSql 方法里，调用了 rootSqlNode.apply(context) 方法，apply 方法是所有的动态节点都实现的接口： 123public interface SqlNode &#123; boolean apply(DynamicContext context);&#125; 对于实现该 SqlSource 接口的所有节点，就是整个组合模式树的各个节点： SqlNode组合模式的简单之处在于，所有的子节点都是同一类节点，可以递归的向下执行，比如对于 TextSqlNode ，因为它是最底层的叶子节点，所以直接将对应的内容 append 到 SQL 语句中： 12345public boolean apply(DynamicContext context) &#123; GenericTokenParser parser = createParser(new BindingTokenParser(context)); context.appendSql(parser.parse(text)); return true;&#125; 但是对于 IfSqlNode ，就需要先做判断，如果判断通过，仍然会调用子元素的 SqlNode ，即 contents.apply 方法，实现递归的解析。 123456789 public boolean apply(DynamicContext context) &#123; if (evaluator.evaluateBoolean(test, context.getBindings())) &#123; contents.apply(context); return true; &#125; return false; &#125;&#125; 模板方法模式模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。 模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。 模板类定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式在 MyBatis 中，sqlSession 的 SQL 执行，都是委托给 Executor 实现的，Executor 包含以下结构： Executor接口其中的 BaseExecutor 就采用了模板方法模式，它实现了大部分的 SQL 执行逻辑，然后把以下几个方法交给子类定制化完成： 123456789 public boolean apply(DynamicContext context) &#123; if (evaluator.evaluateBoolean(test, context.getBindings())) &#123; contents.apply(context); return true; &#125; return false; &#125;&#125; 该模板方法类有几个子类的具体实现，使用了不同的策略： 简单 SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。（可以是 Statement 或 PrepareStatement 对象） 重用 ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map 内，供下一次使用。（可以是 Statement 或 PrepareStatement 对象） 批量 BatchExecutor：执行 update （没有 select，JDBC 批处理不支持 select ），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch() 完毕后，等待逐一执行 executeBatch() 批处理的；BatchExecutor 相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是 Statement 或 PrepareStatement 对象） 比如在 SimpleExecutor 中这样实现 update 方法： 1234567891011public int doUpdate(MappedStatement ms, Object parameter) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null, null); stmt = prepareStatement(handler, ms.getStatementLog()); return handler.update(stmt); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 适配器模式适配器模式(Adapter Pattern)的定义是，将某个类的接口转换为接口客户所需的类型。 换句话说， 适配器模式解决的问题是， 使得原本由于接口不兼容而不能一起工作、不能统一管理的那些类可以在一起工作、可以进行统一管理，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 在 MyBatsi 的 logging 包中，有一个 Log 接口： 1234567891011121314151617public interface Log &#123; boolean isDebugEnabled(); boolean isTraceEnabled(); void error(String s, Throwable e); void error(String s); void debug(String s); void trace(String s); void warn(String s);&#125; 该接口定义了 MyBatis 直接使用的日志方法，而 Log 接口具体由谁来实现呢？MyBatis 提供了多种日志框架的实现，这些实现都匹配这个 Log 接口所定义的接口方法，最终实现了所有外部日志框架到 MyBatis 日志包的适配： 比如对于 Log4jImpl 的实现来说，该实现持有了 org.apache.log4j.Logger 的实例，然后所有的日志方法，均委托该实例来实现。 123456789101112131415161718192021222324252627282930313233343536373839public class Log4jImpl implements Log &#123; private static final String FQCN = Log4jImpl.class.getName(); private Logger log; public Log4jImpl(String clazz) &#123; log = Logger.getLogger(clazz); &#125; public boolean isDebugEnabled() &#123; return log.isDebugEnabled(); &#125; public boolean isTraceEnabled() &#123; return log.isTraceEnabled(); &#125; public void error(String s, Throwable e) &#123; log.log(FQCN, Level.ERROR, s, e); &#125; public void error(String s) &#123; log.log(FQCN, Level.ERROR, s, null); &#125; public void debug(String s) &#123; log.log(FQCN, Level.DEBUG, s, null); &#125; public void trace(String s) &#123; log.log(FQCN, Level.TRACE, s, null); &#125; public void warn(String s) &#123; log.log(FQCN, Level.WARN, s, null); &#125;&#125; 装饰者模式装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。 装饰者模式在 MyBatis 中，缓存的功能由根接口Cache（org.apache.ibatis.cache.Cache）定义。整个体系采用装饰器设计模式，数据存储和缓存的基本功能由 PerpetualCache（org.apache.ibatis.cache.impl.PerpetualCache）永久缓存实现，然后通过一系列的装饰器来对 PerpetualCache 永久缓存进行缓存策略等方便的控制。如下图： Cache用于装饰 PerpetualCache 的标准装饰器共有8个（全部在 org.apache.ibatis.cache.decorators 包中）： FifoCache：先进先出算法，缓存回收策略 LoggingCache：输出缓存命中的日志信息 LruCache：最近最少使用算法，缓存回收策略 ScheduledCache：调度缓存，负责定时清空缓存 SerializedCache：缓存序列化和反序列化存储 SoftCache：基于软引用实现的缓存管理策略 SynchronizedCache：同步的缓存装饰器，用于防止多线程并发访问 WeakCache：基于弱引用实现的缓存管理策略 另外，还有一个特殊的装饰器 TransactionalCache：事务性的缓存 正如大多数持久层框架一样，MyBatis 缓存同样分为一级缓存和二级缓存 一级缓存，又叫本地缓存，是 PerpetualCache 类型的永久缓存，保存在执行器中（BaseExecutor），而执行器又在 SqlSession（DefaultSqlSession） 中，所以一级缓存的生命周期与 SqlSession 是相同的。 二级缓存，又叫自定义缓存，实现了 Cache 接口的类都可以作为二级缓存，所以可配置如 encache 等的第三方缓存。二级缓存以 namespace 名称空间为其唯一标识，被保存在 Configuration 核心配置对象中。 二级缓存对象的默认类型为 PerpetualCache ，如果配置的缓存是默认类型，则 MyBatis 会根据配置自动追加一系列装饰器。 Cache对象之间的引用顺序为： SynchronizedCache–&gt;LoggingCache–&gt;SerializedCache–&gt;ScheduledCache–&gt;LruCache–&gt;PerpetualCache 迭代器模式迭代器（Iterator）模式，又叫做游标（Cursor）模式。GOF 给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。 Java 的 Iterator 就是迭代器模式的接口，只要实现了该接口，就相当于应用了迭代器模式： 比如 MyBatis 的 PropertyTokenizer 是 property 包中的重量级类，该类会被 reflection 包中其他的类频繁的引用到。这个类实现了 Iterator 接口，在使用时经常被用到的是 Iterator 接口中的 hasNext 这个函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class PropertyTokenizer implements Iterable&lt;PropertyTokenizer&gt;, Iterator&lt;PropertyTokenizer&gt; &#123; private String name; private String indexedName; private String index; private String children; public PropertyTokenizer(String fullname) &#123; int delim = fullname.indexOf('.'); if (delim &gt; -1) &#123; name = fullname.substring(0, delim); children = fullname.substring(delim + 1); &#125; else &#123; name = fullname; children = null; &#125; indexedName = name; delim = name.indexOf('['); if (delim &gt; -1) &#123; index = name.substring(delim + 1, name.length() - 1); name = name.substring(0, delim); &#125; &#125; public String getName() &#123; return name; &#125; public String getIndex() &#123; return index; &#125; public String getIndexedName() &#123; return indexedName; &#125; public String getChildren() &#123; return children; &#125; public boolean hasNext() &#123; return children != null; &#125; public PropertyTokenizer next() &#123; return new PropertyTokenizer(children); &#125; public void remove() &#123; throw new UnsupportedOperationException("Remove is not supported, as it has no meaning in the context of properties."); &#125; public Iterator&lt;PropertyTokenizer&gt; iterator() &#123; return this; &#125;&#125; 可以看到，这个类传入一个字符串到构造函数，然后提供了 iterator 方法对解析后的子串进行遍历，是一个很常用的方法类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC核心技术]]></title>
    <url>%2F2019%2F08%2F17%2FSpringMVC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[SpringMVC 以 DispatcherServlet 为核心，负责协调和组织不同组件以完成请求处理并返回响应的工作，实现了 MVC 模式。 请求转发与重定向当处理器对请求处理完毕后，向其它资源进行跳转时，有两种跳转方式：请求转发与重定向。而根据所要跳转的资源类型，又可分为两类：跳转到页面与跳转到其它处理器。 注意：对于请求转发的页面，可以是WEB-INF中页面；而重定向的页面，是不能为WEB-INF中页的。因为重定向相当于用户再次发出一次请求，而用户是不能直接访问 WEB-INF 中资源的。 返回 ModelAndView 时的请求转发默认情况下， 当处理器方法返回 ModelAndView 时，跳转到指定的 View，使用的是请求转发。但也可显式的进行指出，此时，需在 setViewName()指定的视图前添加 forward:，且此时的视图不会再与视图解析器中的前辍与后辍进行拼接。即必须写出相对于项目根的路径。 相关知识请查看之前的文章：Spring配置式开发SpringMVC注解式开发 1. 请求转发到页面当通过请求转发跳转到目标资源（页面或 Controller）时，若需要向下传递数据，除了可以使用 request， session 外，还可以将数据存放于 ModelAndView 中的 Model 中。页面通过 EL 表达式可直接访问该数据。 2. 请求转发到其它 Controller 返回 ModelAndView 时的重定向返回 ModelAndView 时的重定向，需在 setViewName()指定的视图前添加 redirect:，且此时的视图不会再与视图解析器中的前辍与后辍进行拼接。即必须写出相对于项目根的路径。 1. 重定向到页面在重定向时，请求参数是无法通过 request 的属性向下一级资源中传递的。但可以通过以下方式将请求参数向下传递。 （1） 通过 ModelAndView 的 Model 携带参数 当 ModelAndView 中的 Model 存入数据后，视图解析器 InternalResourceViewResolver 会将 map 中的 key 与 value，以请求参数的形式放到请求的 URL 后。 由于视图解析器会将 Map 的 value 放入到 URL 后作为请求参数传递出去，所以无论什么类型的 value，均会变为 String。故此， 放入到 Model 中的 value，只能是基本数据类型与 String，不能是自定义类型的对象数据。 重定向的面页中是无法从 request 中读取数据的。但由于 map 中的 key 与 value，以请求参数的形式放到了请求的 URL 后，所以，页面可以通过 EL 表达式中的请求参数 param 读取。 重定向的页面不能是/WEB-INF 中的页面。 （2） 使用 HttpSession 携带参数 2. 重定向到 Controller重定向到其它 Controller 时，若要携带参数， 完全可以采用前面的方式。而对于目标 Controller 接收这些参数，则各不相同。 （1） 通过 ModelAndView 的 Model 携带参数 目标 Controller 在接收这些参数时， 只要保证目标 Controller 的方法形参名称与发送 Controller发送的参数名称相同即可接收。当然，目标Controller也可以进行参数的整体接收。只要保证参数名称与目标 Controller 接收参数类型的属性名相同即可。 （2） 使用 HttpSession 携带参数 返回 String 时的请求转发当处理器方法返回 String 时，该 String 即为要跳转的视图。 在其前面加上前辍 forward:，则可显式的指定跳转方式为请求转发。 同样，视图解析器不会对其进行前辍与后辍的拼接。请求转发的目标资源无论是一个页面，还是一个 Controller，用法相同。 注意：此时不能再使用 ModelAndView 传递数据了。因为在处理器方法中定义的 ModelAndView 对象就是个局部变量，方法运行结束，变量销毁。而当前的处理器方法返回的为 String，而非 ModelAndView，所以 ModelAndView 不起作用了。 返回 String 时的重定向当重定向到目标资源时，若需要向下传递参数值，除了可以直接通过请求 URL 携带参数，通过 HttpSession 携带参数外，还可使用其它方式。 1. 重定向到页面（1） 通过 Model 形参携带参数 可以在 Controller 形参中添加 Model 参数，将要传递的数据放入 Model 中进行参数传递。该方式同样也是将参数拼接到了重定向请求的 URL 后，所以放入其中的数据只能是基本类型数据，不能是自定义类型。 （2） 通过形参 RedirectAttributes 的 addAttribute()携带参数 RedirectAttributes 是一个继承自 Model 的接口，其底层仍然使用 ModelMap 实现。通过 addAttribute()方法会将参数名及参数值放入该 Map 中，然后视图解析器会将其拼接到请求的 URL 中。 所以，这种携带参数的方式，不能携带自定义对象。 2. 重定向到 Controller重定向到 Controller 时，携带参数的方式，除了可以使用请求 URL 后携带方式， HttpSession携带方式， Model 形参携带方式，及 RedirectAttributes 形参的 addAttibute()携带方式外，还可以使用 RedirectAttributes 形参的 addFlushAttibute()携带方式。 （1） 通过 Model 形参携带参数 （2） 通过形参 RedirectAttributes 的 addFlushAttribute()携带参数 RedirectAttributes 形参的 addFlushAttibute()携带方式不会将放入其中的属性值通过请求 URL 传递， 所以其中可以存放任意对象。 返回 void 时的请求转发当处理器方法返回 void 时，若要实现请求转发，则需要使用 HttpServletRequest 的请求转发方法。 无论下一级资源是页面，还是 Controller，用法相同。 注意：若有数据需要向下一级资源传递，则需要将数据放入到 request 或 session 中。 不能将数据放到 Model、 RedirectAttributes 中。 返回 void 时的重定向当处理器方法返回 void 时，若要实现重定向，则需要使用 HttpServletResponse 的重定向方法 sendRedirect()。 注意：若有数据需要向下一级资源传递，则需要将数据放入到 session 中。 异常处理1. SimpleMappingExceptionResolver 异常处理器该方式只需要在 SpringMVC 配置文件中注册该异常处理器 Bean 即可。该 Bean 比较特殊，没有 id 属性，无需显式调用或被注入给其它&lt;bean/&gt;，当异常发生时会自动执行该类。 缺点：在捕获到指定异常时，不能执行一些操作 （1） 自定义异常类 定义三个异常类： NameException、 AgeException、 StudentException。其中 StudentException 是另外两个异常的父类。 （2） 定义处理器 12345678910111213141516171819202122232425@Controller //表示当前类是一个处理器@RequestMapping("/test") //命名空间public class MyController &#123; @RequestMapping("/register.do") //底层使用类型转换器 public ModelAndView doRegister(String name,int age) throws StudentException &#123; // int i = 3 / 0; if (!"huang".equals(name)) &#123; throw new NameException("用户名不正确!"); &#125; if (age &gt; 60) &#123; throw new AgeException("年龄太大了!"); &#125; ModelAndView mv = new ModelAndView(); mv.addObject("name",name); mv.addObject("age",age); mv.setViewName("/WEB-INF/jsp/welcome.jsp"); return mv; &#125; &#125; （3） 注册异常处理器 1234567891011&lt;!-- 配置异常处理器 --&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="defaultErrorView" value="errors/error.jsp"/&gt; &lt;property name="exceptionAttribute" value="ex"/&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;prop key="com.huang.exceptions.NameException"&gt;/errors/nameError.jsp&lt;/prop&gt; &lt;prop key="com.huang.exceptions.AgeException"&gt;/errors/ageError.jsp&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; exceptionMappings： Properties 类型属性，用于指定具体的不同类型的异常所对应的异常响应页面。 Key 为异常类的全限定性类名， value 则为响应页面路径。 defaultErrorView：指定默认的异常响应页面。若发生的异常不是 exceptionMappings 中指定的异常，则使用默认异常响应页面。 exceptionAttribute：捕获到的异常对象。一般异常响应页面中使用。 （4） 定义异常响应页面 在 WebRoot 下新建一个目录 errors，在其中定义三个异常响应页面。 （5） 运行结果 2. 自定义异常处理器自定义异常处理器，需要实现 HandlerExceptionResolver 接口，并且该类需要在 SpringMVC 配置文件中进行注册。 （1） 定义异常处理器 当一个类实现了 HandlerExceptionResolver 接口后，只要有异常发生，无论什么异常，都会自动执行接口方法 resolveException()。 1234567891011121314151617181920212223public class MyHandlerExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //将异常对象加入数据模型中 ModelAndView mv = new ModelAndView(); mv.addObject("ex",ex); //这是默认错误响应界面 mv.setViewName("/errors/error.jsp"); //设置NameException响应界面 if (ex instanceof NameException) &#123; mv.setViewName("/errors/nameError.jsp"); &#125; //设置AgeException响应界面 if (ex instanceof AgeException) &#123; mv.setViewName("/errors/ageError.jsp"); &#125; return mv; &#125; （2） 注册异常处理器 12&lt;!-- 注册异常处理器 --&gt;&lt;bean class="com.huang.resolvers.MyHandlerExceptionResolver"/&gt; 3. 异常处理注解使用注解@ExceptionHandler 可以将一个方法指定为异常处理方法。该注解只有一个可选属性 value，为一个 Class&lt;?&gt;数组，用于指定该注解的方法所要处理的异常类，即所要匹配的异常。 （1） 定义异常处理的 Controller 123456789101112131415161718192021222324252627282930313233@Controllerpublic class BaseController &#123; // 处理NameException异常 @ExceptionHandler(NameException.class) public ModelAndView handlerNameException(Exception ex) &#123; ModelAndView mv = new ModelAndView(); mv.addObject("ex",ex); mv.setViewName("/errors/nameError.jsp"); return mv; &#125; // 处理AgeException异常 @ExceptionHandler(AgeException.class) public ModelAndView handlerAgeException(Exception ex) &#123; ModelAndView mv = new ModelAndView(); mv.addObject("ex",ex); mv.setViewName("/errors/ageError.jsp"); return mv; &#125; // 处理其它异常 @ExceptionHandler public ModelAndView handlerException(Exception ex) &#123; ModelAndView mv = new ModelAndView(); mv.addObject("ex",ex); mv.setViewName("/errors/error.jsp"); return mv; &#125;&#125; （2） 修改 Controller （3） 修改 springmvc 配置文件 类型转换器表单提交的无论是 int 还是 double 类型的请求参数，用于处理该请求的处理器方法的形参，均可直接接收到相应类型的相应数据，而非接收到 String 再手工转换。那是因为在 SpringMVC 框架中， 有默认的类型转换器。这些默认的类型转换器，可以将 String 类型的数据，自动转换为相应类型的数据。 自定义类型转换器若要定义类型转换器，则需要实现 Converter 接口。 该 Converter 接口有两个泛型：第一个为待转换的类型，第二个为目标类型。而该接口的方法 convert()，用于完成类型转换。 （1） 实现 Converter 接口 1234567891011121314151617//Converter接口中的两个泛型表示：//第一个：表示源的类型//第二个：表示宿的类型，即转换为的目标类型public class MyDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); try &#123; return sdf.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; （2） 修改 springmvc 配置文件 在 SpringMVC 的配置文件中对类型转换进行配置，首先要注册类型转换器，然后再注册一个转换服务 Bean。将类型转换器注入给该转换服务 Bean。最后由处理器适配器来使用该转换服务 Bean。 12345678910111213&lt;!-- 注册组件扫描器 --&gt;&lt;context:component-scan base-package="com.huang.handlers"/&gt;&lt;!-- 注册类型转换器 --&gt;&lt;bean id="myDateConverter" class="com.huang.converters.MyDateConverter"/&gt;&lt;!-- 注册转换服务对象：创建转换服务 Bean --&gt;&lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters" ref="myDateConverter"/&gt;&lt;/bean&gt;&lt;!-- 注册mvc注解驱动： 使用转换服务 Bean--&gt;&lt;mvc:annotation-driven conversion-service="conversionService"/&gt; （3） 修改处理器、目标文件、index页面 （4） 运行结果 接收多种日期格式的类型转换器采用下面这种方法，日期格式可以为 yyyy-MM-dd、yyyy/MM/dd 或 yyyyMMdd，修改类型转换器： 12345678910111213141516171819202122232425262728293031public class MyDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; SimpleDateFormat sdf = getDateFormat(source); try &#123; return sdf.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125; private SimpleDateFormat getDateFormat(String source) &#123; SimpleDateFormat sdf = new SimpleDateFormat(); //日期格式为 yyyy-MM-dd if (Pattern.matches("^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$",source)) &#123; sdf = new SimpleDateFormat("yyyy-MM-dd"); //日期格式为 yyyy/MM/dd &#125;else if (Pattern.matches("^\\d&#123;4&#125;/\\d&#123;2&#125;/\\d&#123;2&#125;$",source)) &#123; sdf = new SimpleDateFormat("yyyy/MM/dd"); //日期格式为 yyyyMMdd &#125;else if (Pattern.matches("^\\d&#123;4&#125;\\d&#123;2&#125;\\d&#123;2&#125;$",source)) &#123; sdf = new SimpleDateFormat("yyyyMMdd"); &#125; return sdf; &#125;&#125; 数据回显当数据类型转换发生异常后，需要返回到表单页面，让用户重新填写。但正常情况下，发生类型转换异常，系统会自动跳转到 400 页面。所以，若要在发生类型转换异常后，跳转到指定页面，则需要将异常捕获，然后通过异常处理器跳转到指定页面。 （1） 修改处理器 数据回显原理： 在异常处理器中， 通过 request.getParameter()将用户输入的表单原始数据获取到后，直接放入到 ModelAndView 中的 Model 中，然后从要转向的页面中就可以直接通过 EL 表达式读取出，也就实现了数据回显。 12345678910111213@ExceptionHandler(TypeMismatchException.class)public ModelAndView exceptionResolver(HttpServletRequest request, Exception ex) &#123; ModelAndView mv = new ModelAndView(); mv.addObject("ex",ex); String age = request.getParameter("age"); String birthday = request.getParameter("birthday"); mv.addObject("age", age); mv.addObject("birthday", birthday); mv.setViewName("/index.jsp"); return mv;&#125; （2） 修改页面表单 12345678&lt;body&gt;$&#123;ex.message &#125;&lt;br&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/test/register.do" method="POST"&gt; 年龄：&lt;input type="text" name="age" value="$&#123;age &#125;"/&gt;&lt;br&gt; 生日：&lt;input type="text" name="birthday" value="$&#123;birthday &#125;"/&gt;&lt;br&gt; &lt;input type="submit" value="注册"/&gt; &lt;/form&gt;&lt;/body&gt; （3） 修改类型转换器 1234 //抛出一个类型匹配异常。&#125;else &#123; throw new TypeMismatchException("",Date.class);&#125; （4） 运行结果 自定义类型转换失败后提示信息SpringMVC 并没有专门的用于自定义类型转换失败后提示信息的功能。需要程序员自己实现。 （1） 修改处理器 12345678910111213141516171819202122@ExceptionHandler(TypeMismatchException.class)public ModelAndView exceptionResolver(HttpServletRequest request, Exception ex) &#123; ModelAndView mv = new ModelAndView(); String age = request.getParameter("age"); String birthday = request.getParameter("birthday"); // 捕获到的异常信息 String errorMSG = ex.getMessage(); if(errorMSG.contains(age)) &#123; mv.addObject("ageErrors", "年龄输入有误"); &#125; if(errorMSG.contains(birthday)) &#123; mv.addObject("birthErrors", "日期输入有误"); &#125; mv.addObject("age", age); mv.addObject("birthday", birthday); mv.addObject("ex", ex); mv.setViewName("/index.jsp"); return mv;&#125; （2） 修改页面表单 123456789&lt;body&gt; $&#123;ex.message &#125; &lt;br&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/test/register.do" method="POST"&gt; 年龄：&lt;input type="text" name="age" value="$&#123;age &#125;"/&gt;$&#123;ageErrors &#125;&lt;br&gt; 生日：&lt;input type="text" name="birthday" value="$&#123;birthday &#125;"/&gt;$&#123;birthErrors &#125;&lt;br&gt; &lt;input type="submit" value="注册"/&gt; &lt;/form&gt;&lt;/body&gt; （3） 运行结果 数据验证在 Web 应用程序中，为了防止客户端传来的数据引发程序的异常，常常需要对数据进行验证。输入验证分为客户端验证与服务器端验证。客户端验证主要通过 JavaScript 脚本进行，而服务器端验证则主要是通过 Java 代码进行验证。为了保证数据的安全性，一般情况下，客户端验证与服务器端验证都是要进行的。 需求：要求用户输入的表单数据满足如下要求：姓名：非空，且长度 3-6 个字符成绩： 0-100 分手机号：非空，且必须符合手机号格式 （1） 定义实体 123456public class Student &#123; private String name; private double score; private String mobile;&#125; （2） 在实体属性上添加验证注解 在注解的 message 属性中，可以使用{属性名}的方式来引用指定的注解的属性值。 1234567891011121314//姓名3~6个字符@NotNull(message="姓名不能为空")@Size(min=3, max=6, message="姓名长度应在&#123;min&#125;-&#123;max&#125;个字符")private String name;//成绩0~100@Min(value=0, message="成绩不能小于&#123;value&#125;")@Max(value=100, message="成绩不能大于&#123;value&#125;")private double score;//手机号格式：1[3/4/5/7/8]xxxxxxxxx@NotNull(message="电话不能为空")@Pattern(regexp="^1[34578]\\d&#123;9&#125;$", message="手机号格式不正确")private String mobile; Hibernate Validator 中常用的验证注解介绍： 序号 验证注解 说明 1 @AssertFalse 验证注解的元素值是 false 2 @AssertTrue 验证注解的元素值是 true 3 @DecimalMin（ value=x） 验证注解的元素值小于等于指定的十进制 value 值 4 @DecimalMax（ value=x） 验证注解的元素值大于等于指定的十进制 value 值 5 @Digits(integer=整数位数,fraction=小数位数) 验证注解的元素值的整数位数和小数位数上限 6 @Future 验证注解的元素值（日期类型）比当前时间晚 7 @Max（ value=x） 验证注解的元素值小于等于指定的 value 值 8 @Min（ value=x） 验证注解的元素值大于等于指定的 value 值 9 @NotNull 验证注解的元素值不是 null 10 @Null 验证注解的元素值是 null 11 @Past 验证注解的元素值（日期类型）比当前时间早 12 @Pattern(regex=正则表达式) 验证注解的元素值不指定的正则表达式匹配 13 @Size(min=最小值, max=最大值) 验证注解的元素值的在 min 和 max（包含）指定区间之内，如字符长度、集合大小 14 @Valid 验证关联的对象，如账户对象里有一个订单对象，指定验证订单对象 15 @NotEmpty 验证注解的元素值不为 null 且丌为空（字符串长度丌为 0、集合大小丌为 0） 16 @Range(min=最小值, max=最大值) 验证注解的元素值在最小值和最大值之间 17 @NotBlank 验证注解的元素值不为空（不为 null、去除首位空格后长度为 0），不同于@NotEmpty， @NotBlank 只应用于字符串且在比较时会去除字符串的空格 18 @Length(min=下限, max=上限) 验证注解的元素值长度在 min 和 max 区间内 19 @Email 验证注解的元素值是 Email，也可以通过正则表达式和 flag 指定自定义的 email 格式 （3） 定义 Controller 123456789101112131415161718192021222324252627282930313233343536@Controller //表示当前类是一个处理器@RequestMapping("/test") //命名空间public class MyController &#123; @RequestMapping("/register.do") //底层使用类型转换器 public ModelAndView doRegister(@Validated Student student,BindingResult br) &#123; ModelAndView mv = new ModelAndView(); mv.addObject("student",student); mv.setViewName("/WEB-INF/jsp/welcome.jsp"); int errorCount = br.getErrorCount(); if (errorCount &gt; 0) &#123; FieldError nameError = br.getFieldError("name"); FieldError scoreError = br.getFieldError("score"); FieldError mobileError = br.getFieldError("mobile"); if (nameError != null) &#123; String nameErrorMSG = nameError.getDefaultMessage(); mv.addObject("nameErrorMSG",nameErrorMSG); &#125; if (scoreError != null) &#123; String scoreErrorMSG = scoreError.getDefaultMessage(); mv.addObject("scoreErrorMSG",scoreErrorMSG); &#125; if (mobileError != null) &#123; String mobileErrorMSG = mobileError.getDefaultMessage(); mv.addObject("mobileErrorMSG",mobileErrorMSG); &#125; mv.setViewName("/index.jsp"); &#125; return mv; &#125; &#125; 由于这里使用的验证器为 Bean 对象验证器，所以对于要验证的参数数据，需要打包后由处理器方法以 Bean 形参类型的方式接收，并使用@Validated 注解标注。注意， 不能将 @Validated 注解在 String 类型与基本类型的形参前。紧跟着@Validated 所注解的形参的后面，是一个 BindingResult 类型的形参。通过该形参可获取到所有验证异常信息。 BindingResult 接口中常用的方法有： getAllErrors()：获取到所有的异常信息。其返回值为 List，但若没有发生异常，则该 List 为也被创建，只不过其 size()为 0，而非 List 为 Null。 getFieldError()：获取指定属性的异常信息。 getErrorCount()：获取所有异常的数量。 getRawFieldValue()：获取到用户输入的引发验证异常的原始值。 （4） 定义 SpringMVC 配置文件 12345678910 &lt;!-- 注册组件扫描器 --&gt; &lt;context:component-scan base-package="com.huang.handlers"/&gt; &lt;!-- 生成验证器 --&gt;&lt;bean id="myValidator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"&gt; &lt;property name="providerClass" value="org.hibernate.validator.HibernateValidator"/&gt;&lt;/bean&gt;&lt;!-- 注册mvc注解驱动 --&gt;&lt;mvc:annotation-driven validator="myValidator"/&gt; （5） 定义目标页面和 index 页面 空字符串转换成 double 类型会出错 （6） 运行结果 文件上传上传单个文件（1） 定义上传页面 定义具有文件上传功能的页面 index.jsp， 其表单的设置需要注意， method 属性为 POST，enctype 属性为 multipart/form-data。 123456&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/test/upload.do" method="POST" enctype="multipart/form-data"&gt; 文件：&lt;input type="file" name="img"/&gt;&lt;br&gt; &lt;input type="submit" value="上传"/&gt; &lt;/form&gt;&lt;/body&gt; （2） 定义处理器 123456789101112131415161718192021222324@Controller //表示当前类是一个处理器@RequestMapping("/test") //命名空间public class MyController &#123; @RequestMapping("/upload.do") public String doFileUpload(MultipartFile img, HttpSession session) throws Exception &#123; //服务端的images目录需要手工先创建好 // String path = "d:/images"; String path = session.getServletContext().getRealPath("/images"); if (img.getSize() &gt; 0) &#123; // 获取到上传文件的原始名称 String fileName = img.getOriginalFilename(); //限制上传文件类型 if (fileName.endsWith("jpg") || fileName.endsWith("png")) &#123; File file = new File(path, fileName); //完成上传 img.transferTo(file); &#125; &#125; return "/success.jsp"; &#125;&#125; 对于处理器的定义，需要注意以下几点： 处理器方法的形参 用于接收表单元素所提交参数的处理器方法的形参类型不是 File，而是 MultipartFile。MultipartFile 为一个接口，专门用于处理文件上传问题。该接口中具有很多有用的方法，例如获取参数名称 getName()； 获取文件的原始名称 getOriginalFilename()； 获取文件大小 getSize()； 判断文件是否为空 isEmpty()； 文件上传transferTo()等。 MultipartFile 接口常用的实现类为 CommonsMultipartResolver。 而该实现类中具有设置上传文件大小、上传文件字符集等属性，可以通过为其注入值，来限定上传的文件。 未选择上传文件 若用户未选择上传的文件就直接提交了表单，此时处理器方法的 MultipateFile 形参所接收到的实参值并非为 null，而是一个内容为 empty 的文件。所以，对于未选择上传文件的情况的处理，其判断条件为 file.isEmpty()，而非 file == null。 上传文件类型 SpringMVC 的文件上传功能并未有直接的用于限定文件上传类型的方法或属性，需要对获取到的文件名后辍加以判断。此时使用 String 的 endWith()方法较为简捷。 上传方法 对于上传单个文件，直接使用 MultipartFile 的 transferTo()方法，就可以完成上传功能。但是，需要注意的是，该方法要求服务端用于存放客户上传文件的目录必须存在，否则报错。即其不会自己创建该目标目录。 （3） 在 SpringMVC 中注册文件上传处理器 1234567891011121314151617181920&lt;!-- 注册组件扫描器 --&gt;&lt;context:component-scan base-package="com.huang.handlers" /&gt;&lt;!-- MultipartFile 接口的实现类 CommonsMultipartResolver 的 Bean。要求该 Bean 的 id 必须为 multipartResolver。 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 文件上传字符集 --&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;!-- 单位：B 如果不对该属性进行设置，或指定其值为-1，则表示不对上传文件大小作限制 --&gt; &lt;property name="maxUploadSize" value="1048576" /&gt;&lt;/bean&gt;&lt;mvc:annotation-driven /&gt;&lt;!-- 注册异常处理器 --&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="defaultErrorView" value="/error.jsp" /&gt;&lt;/bean&gt; 注意：该大小为上传文件的总大小。即，若上传多个文件，则多个文件的大小之和不能大小该设定值。当然，也可通过设置属性 maxUploadSizePerFile，再添加对每个上传文件的大小设置。即每个文件的大小不能超过 maxUploadSizePerFile 指定值，而文件大小总和也不能超过 maxUploadSize 指定值。 （4） 定义上传成功与失败页面 上传多个文件（1） 修改 index 页面 12345678&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/test/upload.do" method="POST" enctype="multipart/form-data"&gt; 文件1：&lt;input type="file" name="img"/&gt;&lt;br&gt; 文件2：&lt;input type="file" name="img"/&gt;&lt;br&gt; 文件3：&lt;input type="file" name="img"/&gt;&lt;br&gt; &lt;input type="submit" value="上传"/&gt; &lt;/form&gt;&lt;/body&gt; （2） 修改处理器类 （3） 运行结果 拦截器Interceptor 拦截器的主要作用是拦截指定的用户请求， 并进行相应的预处理与后处理。 其拦截的时间点在“处理器映射器根据用户提交的请求映射出了所要执行的处理器类， 并且也找到了要执行该处理器类的处理器适配器，在处理器适配器执行处理器之前”。当然，在处理器映射器映射出所要执行的处理器类时，已经将拦截器与处理器组合为了一个处理器执行链，并返回给了中央调度器。 一个拦截器的执行（1） 自定义拦截器 123456789101112131415161718192021public class OneInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("执行OneIntercepor ---- preHandle()方法 ------"); return true; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("执行OneIntercepor ---- postHandle()方法 ------"); &#125; public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("执行OneIntercepor ---- afterCompletion()方法 ------"); &#125;&#125; 自定义拦截器，需要实现 HandlerInterceptor 接口。而该接口中含有三个方法： 1preHandle(request, response, Object handler) 该方法在处理器方法执行之前执行。其返回值为 boolean，若为 true，则紧接着会执行处理器方法，且会将 afterCompletion()方法放入到一个专门的方法栈中等待执行。 1postHandle(request, response, Object handler, modelAndView) 该方法在处理器方法执行之后执行。处理器方法若最终未被执行，则该方法不会执行。由于该方法是在处理器方法执行完后执行，且该方法参数中包含 ModelAndView，所以该方法可以修改处理器方法的处理结果数据，且可以修改跳转方向。 1afterCompletion(request, response, Object handler, Exception ex) 当 preHandle()方法返回 true 时，会将该方法放到专门的方法栈中，等到对请求进行响应的所有工作完成之后才执行该方法。 即该方法是在中央调度器渲染（数据填充） 了响应页面之后执行的，此时对 ModelAndView 再操作也对响应无济于事。 （2） 注册拦截器 12345678910 &lt;!-- 注册组件扫描器 --&gt; &lt;context:component-scan base-package="com.huang.*"/&gt; &lt;!-- 注册拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="com.huang.interceptors.OneInterceptor"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; &lt;mvc:mapping/&gt;用于指定当前所注册的拦截器可以拦截的请求路径，而/**表示拦截所有请求。 （3） 定义处理器 123456789101112@Controller //表示当前类是一个处理器@RequestMapping("/test") //命名空间public class MyController &#123; @RequestMapping("/some.do") public String doSome() &#123; System.out.println("执行处理器的doSome()方法"); return "/WEB-INF/jsp/welcome.jsp"; &#125;&#125; （4） 运行结果 （5） 一个拦截器中方法与处理器方法的执行顺序 多个拦截器的执行（1） 再定义一个拦截器 （2） 多个拦截器的注册与执行 （3） 运行结果 当有多个拦截器时，形成拦截器链。拦截器链的执行顺序，与其注册顺序一致。当某一个拦截器的 preHandle()方法返回 true 并被执行到时，会向一个专门的方法栈中放入该拦截器的 afterCompletion()方法。 （4） 多个拦截器中方法与处理器方法的执行顺序 只要有一个 preHandle()方法返回 false，则上部的执行链将被断开，其后续的处理器方法与 postHandle()方法将无法执行。但是，无论执行链执行情况怎样，只要方法栈中有方法，即执行链中只要有 preHandle()方法返回 true，就会执行方法栈中的 afterCompletion()方法，最终都会给出响应。]]></content>
      <categories>
        <category>SpringMVC核心技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC注解式开发]]></title>
    <url>%2F2019%2F08%2F15%2FSpringMVC%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[所谓 SpringMVC 的注解式开发是指，处理器是基于注解的类的开发。 对于每一个定义的处理器，无需在配置文件中逐个注册，只需在代码中通过对类与方法的注解，便可完成注册。即注解替换的是配置文件中对于处理器的注册部分。 第一个注解式开发程序开发流程五个步骤请查看之前的文章 注册组件扫描器这里的组件即处理器，需要指定处理器所在基本包。 1&lt;context:component-scan base-package="com.huang.handlers"/&gt; 定义处理器此时的处理器类无需继承任何父类，实现任何接口。只需在类上与方法上添加相应注解即可。 @Controller：表示当前类为处理器 @RequestMapping：表示当前方法为处理器方法。该方法要对 value 属性所指定的 URL 进行处理与响应。(被注解的方法的方法名可以随意)。 123456789101112@Controllerpublic class MyController &#123; @RequestMapping("/my.do") public ModelAndView doFirst(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject("message", "Hello World SpringMVC World!"); mv.setViewName("/WEB-INF/jsp/welcome.jsp"); return mv; &#125;&#125; 若有多个请求路径均可匹配该处理器方法的执行，则@RequestMapping 的 value 属性中可以写上一个数组。 1@RequestMapping(&#123;"/my.do","/hello.do"&#125;) 处理器的请求映射规则的定义通过@RequestMapping 注解可以定义处理器对于请求的映射规则。 该注解可以注解在方法上，也可以注解在类上，但意义是不同的。 对请求 URI 的命名空间的定义@RequestMapping 的 value 属性用于定义所匹配请求的 URI。但对于注解在方法上与类上，其 value 属性所指定的 URI，意义是不同的。 一个@Controller 所注解的类中，可以定义多个处理器方法。当然，不同的处理器方法所匹配的 URI 是不同的。 这些不同的 URI 被指定在注解于方法之上的@RequestMapping 的 value 属性中。 但若这些请求具有相同的 URI 部分，则这些相同的 URI， 可以被抽取到注解在类之上的@RequestMapping 的 value 属性中。此时的这个 URI 称为命名空间。 123456789101112131415161718192021@Controller //表示当前类是一个处理器@RequestMapping("/test") //命名空间public class MyController &#123; @RequestMapping("/first.do") public ModelAndView doFirst(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject("message", "执行doFirst()方法"); mv.setViewName("/WEB-INF/jsp/welcome.jsp"); return mv; &#125; @RequestMapping("/second.do") public ModelAndView doSecond(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject("message", "执行doSecond()方法"); mv.setViewName("/WEB-INF/jsp/welcome.jsp"); return mv; &#125;&#125; 请求 URI 中通配符的应用在处理器方法所映射的 URI 中，可以使用通配符，有两种用法。 1. 资源名称中使用通配符在请求的资源名称中使用通配符，表示请求的资源名称中只要包含指定的字符即可完成匹配。 1234@RequestMapping("/third*.do") // 资源名称必须以third开头，后面可加其它字符@RequestMapping("/*fourth.do") // 资源名称必须以fourth结尾，前面可加其它字符 2. 资源路径中使用通配符 路径级数的精确匹配：/xxx/*/my.do： 表示在 my.do 的资源名称前面，只能有两级路径，第一级必须是/xxx，而第二级随意。 路径级数的可变匹配：/xxx/**/my.do： 表示在 my.do 的资源名称前面，必须以/xxx 路径开头，而其它级的路径是否包含，若包含又包含几级，各级又叫什么名称，均随意。 12//路径级数的精确匹配@RequestMapping("/*/fifth.do") // 路径级数的绝对匹配，即要求在test与fifth.do之间必须要有一级路径 访问方式 12//路径级数的可变匹配@RequestMapping("/**/sixth.do") // 要求在test与sixth.do之间可以包含多级路径，也可以没有其它路径 访问方式(两种) 对请求提交方式的定义对于@RequestMapping，其有一个属性 method，用于对被注解方法所处理请求的提交方式进行限制，即只有满足该 method 属性指定的提交方式的请求，才会执行该被注解方法。 12//对请求提交方式的定义@RequestMapping("value=&#123;\"/my.do\", \"hello.do\"&#125;, method=RequestMethod.POST") 由于 POST 提交只能通过表单或者 AJAX 提交，所以通过地址栏访问会出现 404 错误 注意：若不指定 method 属性，则无论是 GET 还是 POST 提交方式，均可匹配。即对于请求的提交方式无要求。 客户端浏览器常用的请求方式，及其提交方式有以下几种： 序号 请求方式 提交方式 1 表单请求 默认 GET,可以指定 POST 2 AJAX 请求 默认 GET,可以指定 POST 3 地址栏请求 GET 请求 4 超链接请求 GET 请求 5 src 资源路径请求 GET 请求 对请求中携带参数的定义@RequestMapping 中 params 属性中定义了请求中必须携带的参数的要求。 @RequestMapping(value=”/xxx.do”, params={“name”,”age”}) ：要求请求中必须携带请求参数 name 与 age @RequestMapping(value=”/xxx.do”, params={“!name”,”age”}) ：要求请求中必须携带请求参数 age，但必须不能携带参数 name @RequestMapping(value=”/xxx.do”, params={“name=zs”,”ag=23”}) ：要求请求中必须携带请求参数 name，且其值必须为 zs；必须携带参数 age，其其值必须为 23 @RequestMapping(value=”/xxx.do”, params=“name!=zs”) ：要求请求中必须携带请求参数 name，且其值必须不能为 zs 处理器方法的参数处理器方法可以包含以下五类参数，这些参数会在系统调用时由系统自动赋值，即程序员可在方法内直接使用。 HttpServletRequest HttpServletResponse HttpSession 用于承载数据的 Model 请求中所携带的请求参数 逐个参数接收只要保证请求参数名与该请求处理方法的参数名相同即可。 （1） 处理器类 MyController 123456789101112131415161718@Controller //表示当前类是一个处理器@RequestMapping("/test") //命名空间public class MyController &#123; @RequestMapping("/register.do") //底层使用类型转换器 public ModelAndView doRegister(String name,int age) &#123; System.out.println("name =" + name); System.out.println("age =" + age); ModelAndView mv = new ModelAndView(); mv.addObject("name",name); mv.addObject("age",age); mv.setViewName("/WEB-INF/jsp/welcome.jsp"); return mv; &#125; &#125; （2） index 页面 1234567&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/test/register.do" method="POST"&gt; 姓名：&lt;input type="text" name="name"/&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"/&gt;&lt;br&gt; &lt;input type="submit" value="注册"/&gt; &lt;/form&gt; &lt;/body&gt; (3) 目标页面 1234&lt;body&gt; name = $&#123;name &#125;&lt;br&gt; age = $&#123;age &#125;&lt;br&gt;&lt;/body&gt; （4） 运行结果的注册页面 请求参数中文乱码问题对于前面所接收的请求参数，若含有中文，则会出现中文乱码问题。 Spring 对于请求参数中的中文乱码问题，给出了专门的字符集过滤器 解决方案在 web.xml 中注册字符集过滤器，即可解决 Spring 的请求参数的中文乱码问题。不过，最好将该过滤器注册在其它过滤器之前。因为过滤器的执行是按照其注册顺序进行的。 12345678910111213141516171819202122232425&lt;!-- 注册字符集过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- 指定字符集 --&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 指定强制使用指定的字符集 如果为true，不管系统有没有设置字符集，通通按照自己定义的字符集，即utf-8 如果没有设置或者false，若系统设置了字符集按系统的，没设置按照自定义的 --&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 源码分析打开 CharacterEncodingFilter 类的源码，发现有两个 set 属性： encoding 与 forceEncoding。 encoding： String 类型，指定字符集。 forceEncoding： boolean 类型，指定是否强制使用指定的字符集。若为 true，则代码中指定的字符集将不起作用。若为 false，则代码中若指定了字符集，就使用代码指定字符集；若代码中没有指定字符集，则使用这里指定的字符集。 校正请求参数名@RequestParam若请求 URL 所携带的参数名称与处理方法中指定的参数名不相同时， 则需在处理方法参数前， 添加一个注解@RequestParam(“请求参数名”)，指定请求 URL 所携带参数的名称。该注解是对处理器方法参数进行修饰的。@RequestParam()有三个属性： value： 指定请求参数的名称。 required： 指定该注解所修饰的参数是否是必须的， boolean 类型。若为 true，则表示请求中所携带的参数中必须包含当前参数。若为 false，则表示有没有均可。 defaultValue：指定当前参数的默认值。若请求 URI 中没有给出当前参数，则当前方法参数将取该默认值。即使 required 为 true，且 URI 中没有给出当前参数，该处理器方法参数会自动取该默认值，而不会报错。 整体参数接收将处理器方法的参数定义为一个对象，只要保证请求参数名与这个对象的属性同名即可(表单的参数名与实体的属性一致)。 （1） 定义 VO 类 Student 12345public class Student &#123; private String name; private int age;&#125; （2） 修改处理器类 12345678910111213141516@Controller //表示当前类是一个处理器@RequestMapping("/test") //命名空间public class MyController &#123; @RequestMapping("/register.do") public ModelAndView doRegister(Student student) &#123; System.out.println("name =" + student.getName()); System.out.println("age =" + student.getAge()); ModelAndView mv = new ModelAndView(); mv.addObject("student",student); mv.setViewName("/WEB-INF/jsp/welcome.jsp"); return mv; &#125; &#125; (3) 定义目标页面 123&lt;body&gt; student = $&#123;student &#125;&lt;br&gt;&lt;/body&gt; （4） 修改 index 页面 12345678&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/test/register.do" method="POST"&gt; &lt;!-- 整体接收时，要求表单参数名与对象属性名相同 --&gt; 姓名：&lt;input type="text" name="name"/&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"/&gt;&lt;br&gt; &lt;input type="submit" value="注册"/&gt; &lt;/form&gt;&lt;/body&gt; 注意：参数名称中不用写为“对象.属性”的形式。 （5） 注册结果 域属性参数的接收所谓域属性，即对象属性。当请求参数中的数据为某类对象域属性的属性值时，要求请求参数名为“域属性名.属性”。 （1） 定义 VO 类 12345public class School &#123; private String sname; private String address;&#125; 123456public class Student &#123; private String name; private int age; private School school;&#125; （2） 修改 index 页面 1234567891011 &lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/test/register.do" method="POST"&gt; &lt;!-- 整体接收时，要求表单参数名与对象属性名相同 --&gt; 姓名：&lt;input type="text" name="name"/&gt;&lt;br&gt; 年龄：&lt;input type="text" name="age"/&gt;&lt;br&gt;&lt;!-- 请求参数名为“域属性名.属性” --&gt; 学校：&lt;input type="text" name="school.sname"/&gt;&lt;br&gt; 校址：&lt;input type="text" name="school.address"/&gt;&lt;br&gt; &lt;input type="submit" value="注册"/&gt; &lt;/form&gt; &lt;/body&gt; 注意：参数名称中要写为“对象.属性”的形式。 路径变量@PathVariable对于处理器方法中所接收的请求参数，可以来自于请求中所携带的参数，也可以来自于请求的 URI 中所携带的变量，即路径变量。不过，此时，需要借助@PathVariable 注解(参数在访问路径)。 @PathVariable 在不指定参数的情况下，默认其参数名，即路径变量名与用于接收其值的属性名相同。若路径变量名与用于接收其值的属性名不同，则@PathVariable 可通过参数指出路径变量名称。 （1） 处理器类 （2） 访问方式 处理器方法的返回值使用@Controller 注解的处理器的处理器方法，其返回值常用的有四种类型： 1. 返回 ModelAndView若处理器方法处理完后，需要跳转到其它资源，且又要在跳转的资源间传递数据， 此时处理器方法返回 ModelAndView 比较好。当然，若要返回 ModelAndView，则处理器方法中需要定义 ModelAndView 对象。 2. 返回 String处理器方法返回的字符串可以指定逻辑视图名，通过视图解析器解析可以将其转换为物理视图地址。 返回内部资源逻辑视图名若要跳转的资源为内部资源，则视图解析器可以使用 InternalResourceViewResolver 内部资源视图解析器。此时处理器方法返回的字符串就是要跳转页面的文件名去掉文件扩展名后的部分。这个字符串与视图解析器中的 prefix、 suffix 相结合，即可形成要访问的 URI。 也可以直接返回资源的物理视图名。此时就不需要在视图解析器中再配置前辍与后辍。 返回 View 对象名若要跳转的资源为外部资源，则视图解析器可以使用 BeanNameViewResolver，然后在配置文件中再定义一些外部资源视图 View 对象，此时处理器方法返回的字符串就是要跳转资源视图 View 的名称。 （1） 修改 springmvc 配置文件 （2） 修改处理器 1234567891011121314@Controller // 表示当前类是一个处理器@RequestMapping("/test") // 命名空间public class MyController &#123; @RequestMapping("/my.do") public String doSome() &#123; /*// 逻辑视图 return "welcome";*/ // 物理视图 return "taobao"; &#125;&#125; 3. 返回 void对于处理器方法返回 void 的应用场景，主要有两种： 通过 ServletAPI 传递数据并完成跳转可在方法参数中放入 HttpServletRequest 或 HttpSession，使方法中可以直接将数据放入到 request、 session 的域中，也可通过 request.getServletContext()获取到 ServletContext，从而将数据放入到 application 的域中。可在方法参数中放入 HttpServletRequest 与 HttpServletResponse，使方法可以完成请求转发与重定向。 注意，重定向是无法完成对/WEB-INF/下资源的访问的。 请求转发： request.getRequestDispatcher(“目标页面”).forward(request,response); 重定向： response.sendRedirect(“目标页面”); （1） 定义 VO 类 Student 12345public class Student &#123; private String name; private int age;&#125; （2） 修改处理器 1234567891011121314@Controller // 表示当前类是一个处理器@RequestMapping("/test") // 命名空间public class MyController &#123; @RequestMapping("/my.do") public void register(HttpServletRequest request,HttpServletResponse response,Student student)throws Exception &#123; request.setAttribute("myStudent", student); //请求转发 request.getRequestDispatcher("/WEB-INF/jsp/welcome.jsp").forward(request, response); &#125;&#125; （3） 修改 springmvc 配置文件 12&lt;!-- 注册组件扫描器 --&gt;&lt;context:component-scan base-package="com.huang.*"/&gt; AJAX 响应若处理器对请求处理后，无需跳转到其它任何资源，此时可以让处理器方法返回 void。例如，对于 AJAX 的异步请求的响应。 （1） 定义 index 页面 1234567891011121314151617181920212223&lt;script type="text/javascript" src="js/jquery-1.8.3.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function() &#123; $("button").click(function() &#123; $.ajax(&#123; url:"test/myAjax.do", data:&#123; name:"张三", age:23 &#125;, success:function(data)&#123; var json = eval("(" + data + ")"); alert(json.pname + " " + json.page); &#125; &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;提交Ajax请求&lt;/button&gt; &lt;/body&gt; （2） 修改处理器类 1234567891011121314151617181920212223@Controller @RequestMapping("/test") public class MyController &#123; @RequestMapping("/myAjax.do") public void doAjax(String name, int age, HttpServletResponse response) throws IOException &#123; //将数据存放到map中 Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("pname", name); map.put("page", age); //将map转为JSON JSONObject myJson = JSONObject.fromObject(map); String jsonStr = myJson.toString(); //将数据发回客户端 PrintWriter out = response.getWriter(); out.print(jsonStr); out.close(); &#125;&#125; 4. 返回 Object处理器方法也可以返回 Object 对象。 但返回的这个 Object 对象不是作为逻辑视图出现的，而是作为直接在页面显示的数据出现的。返回 Object 对象，需要使用@ResponseBody 注解， 将转换后的 JSON 数据放入到响应体中。 返回数值型对象（1） 注册注解驱动 将 Object 数据转化为 JSON 数据，需要由 Http 消息转换器 HttpMessageConverter 完成。而转换器的开启，需要由&lt;mvc:annotation-driven/&gt;来完成。 12&lt;!-- 注册MVC注解驱动 --&gt;&lt;mvc:annotation-driven/&gt; （2） 修改 index 页面 123456789101112131415161718&lt;script type="text/javascript" src="js/jquery-1.8.3.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $("button").click(function() &#123; $.ajax(&#123; url:"test/myAjax.do", success:function(data)&#123; alert(data); &#125; &#125;); &#125;); &#125;);&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;提交Ajax请求&lt;/button&gt; &lt;/body&gt; （3） 修改处理器 1234567891011@Controller @RequestMapping("/test") public class MyController &#123; @RequestMapping(value="/myAjax.do") @ResponseBody // 将返回的数据放入到响应体中 public Object doAjax() &#123; return 123.456; &#125;&#125; （4） 修改配置文件 12345&lt;!-- 注册MVC注解驱动 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 注册组件扫描器 --&gt;&lt;context:component-scan base-package="com.huang.handlers"/&gt; 返回字符串对象返回的字符串中带有中文字符，则接收方页面将会出现乱码 。此时需要使用@RequestMapping 的 produces 属性指定字符集，该属性用于设置输出结果类型。 1234567891011@Controller @RequestMapping("/test") public class MyController &#123; @RequestMapping(value="/myAjax.do",produces="text/html;charset=utf-8") @ResponseBody // 将返回的数据放入到响应体中 public Object doAjax() &#123; return "广东广州"; &#125;&#125; 返回自定义类型对象返回自定义类型对象时，不能以对象的形式直接返回给客户端浏览器，而是将对象转换为 JSON 格式的数据发送给浏览器的。 （1） 定义 VO 类 （2） 修改处理器 MyController （3） 修改 index 页面 返回 Map 集合（1） 修改处理器 123456789101112131415@Controller @RequestMapping("/test") public class MyController &#123; @RequestMapping("/myAjax.do") @ResponseBody // 将返回的数据放入到响应体中 public Object doAjax() &#123; Map&lt;String, Student&gt; map = new HashMap&lt;String, Student&gt;(); map.put("stu1", new Student("张三", 23) ); map.put("stu2", new Student("李四", 24) ); return map; &#125;&#125; （2） 修改 index 页面 123456789101112131415161718&lt;script type="text/javascript" src="js/jquery-1.8.3.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $("button").click(function() &#123; $.ajax(&#123; url:"test/myAjax.do", success:function(data)&#123; alert(data.stu1.name + " " + data.stu2.age); &#125; &#125;); &#125;); &#125;);&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;提交Ajax请求&lt;/button&gt; &lt;/body&gt; 返回 List 集合（1） 修改处理器 （2） 修改 index 页面]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC配置式开发]]></title>
    <url>%2F2019%2F08%2F14%2FSpringMVC%E9%85%8D%E7%BD%AE%E5%BC%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[配置式开发是指，“处理器类是程序员手工定义的、实现了特定接口的类，然后在 SpringMVC 配置文件中对该类进行显式的、明确的注册”的开发方式。 处理器映射器 HandlerMappingHandlerMapping 接口负责根据 request 请求找到对应的 Handler 处理器及 Interceptor 拦截器，并将它们封装在 HandlerExecutionChain 对象中，返回给中央调度器。其常用的实现类有两种： 1. BeanNameUrlHandlerMappingBeanNameUrlHandlerMapping 处理器映射器， 会根据请求的 url 与 spring 容器中定义的处理器 bean 的 name 属性值进行匹配，从而在 spring 容器中找到处理器 bean 实例。 打开BeanNameUrlHandlerMapping的源码， 从处理器映射器的方法中可以看出，对于处理器的 Bean 的名称，必须以“/”开头，否则无法加入到 urls 数组中。 缺点： 处理器 Bean 的 id 为一个 url 请求路径，而不是 Bean 的名称，有些不伦不类。 处理器Bean的定义与请求url绑定在了一起。 若出现多个url请求同一个处理器的情况，就需要在 Spring 容器中配置多个该处理器类的&lt;bean/&gt;。这将导致容器会创建多个该处理器类实例。 2. SimpleUrlHandlerMappingSimpleUrlHandlerMapping 处理器映射器，会根据请求的 url 与 Spring 容器中定义的处理器映射器子标签的 key 属性进行匹配。匹配上后，再将该 key 的 value 值与处理器 bean 的 id 值进行匹配，从而在 spring 容器中找到处理器 bean。 123456789101112&lt;!-- 注册HandlerMapping --&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/my.do"&gt;myController&lt;/prop&gt; &lt;prop key="/hello.do"&gt;myController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 注册处理器 --&gt;&lt;bean id="myController" class="com.huang.handlers.MyController"/&gt; 也可以使用 urlMap 属性： 12345678910&lt;!-- 注册HandlerMapping --&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="urlMap"&gt; &lt;map&gt; &lt;entry key="/my.do" value="myController"/&gt; &lt;entry key="/hello.do" value="myController"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 优点： 可以将 url 与处理器的定义分离 还可以对 url 进行统一映射管理 处理器适配器 HandlerAdapter有关适配器模式的详细介绍，请点击这里 之所以要将 Handler 定义为 Controller 接口的实现类， 就是因为这里使用的处理器适配器是 SimpleControllerHandlerAdapter。打开其源码，可以看到将 handler 强转为了 Controller。在定义 Handler 时，若不将其定义为 Controller 接口的实现类，这里的强转要出错的。 注意：中央调度器首先会调用该适配器的 supports()方法，判断该 Handler 是否与 Controller 具有 is-a 关系。在具有 is-a 关系的前提下，才会强转。 1. SimpleControllerHandlerAdapter所有实现了 Controller 接口的处理器 Bean，均是通过此适配器进行适配、执行的。Controller 接口中有一个方法： 该方法用于处理用户提交的请求。通过调用 Service 层代码，实现对用户请求的计算响应，并最终将计算所得数据及要响应的页面，封装为一个对象 ModelAndView，返回给中央调度器。 2. HttpRequestHandlerAdapter所有实现了 HttpRequestHandler 接口的处理器 Bean，均是通过此适配器进行适配、执行的。 HttpRequestHandler 接口中有一个方法： 该方法没有返回值，不能像 ModelAndView 一样，将数据及目标视图封装为一个对象。但可以将数据直接放入到 request、 session 等域属性中，并由 request 或 response 完成到目标页面的跳转。 此时 springmvc.xml 配置文件中无需声明视图解析器的 Bean 。 处理器处理器除了实现 Controller 接口外，还可以继承自一些其它的类来完成一些特殊的功能。 继承自 AbstractController 类若处理器继承自 AbstractController 类，那么该控制器就具有了一些新的功能。因为 AbstractController 类还继承自一个父类 WebContentGenerator。 WebContentGenerator 类具有 supportedMethods 属性， 可以设置支持的 HTTP 数据提交方式。 默认支持 GET、 POST。 若处理器继承自 AbstractController 类，那么处理器就可以通过属性 supportedMethods 来限制 HTTP 请求提交方式。 12345&lt;!-- 注册处理器 --&gt;&lt;!-- 指定只支持 POST 的 HTTP 请求提交方式 ，这里的 POST 必须写为大写--&gt;&lt;bean id="/my.do" class="com.huang.handlers.MyController"&gt; &lt;property name="supportedMethods" value="POST"/&gt;&lt;/bean&gt; 请求只能通过表单或 AJAX 请求方式进行提交，而不能通过地址栏、超链接、 Html 标签中的 src 方式进行提交。因为地址栏、超链接、 Html 标签中的 src 方式都是 GET 提交。 否则，会给出请求方法不允许的 405 错误： 客户端浏览器常用的请求方式，及其提交方式有以下几种： 序号 请求方式 提交方式 1 表单请求 默认 GET,可以指定 POST 2 AJAX 请求 默认 GET,可以指定 POST 3 地址栏请求 GET 请求 4 超链接请求 GET 请求 5 src 资源路径请求 GET 请求 AbstractController 类中有一个抽象方法需要实现： 即定义处理器时，就需要实现其抽象方法 handleRequestInternal()。 继承自 MultiActionController 类MultiActionController 类继承自 AbstractController，所以继承自 MultiActionController 类的子类也可以设置 HTTP 请求提交方式。除此之外，继承自该类的处理器中可以定义多个处理方法。 这些方法的签名为公共的方法，返回值为 ModelAndView，包含参数 HttpServletRequest 与 HttpServletResponse，抛出 Exception 异常，方法名随意。 （1） 修改处理器类 123456789101112131415161718public class MyController extends MultiActionController &#123; public ModelAndView doFirst(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject("message", "执行doFirst()方法"); mv.setViewName("/WEB-INF/jsp/welcome.jsp"); return mv; &#125; public ModelAndView doSecond(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject("message", "执行doSecond()方法"); mv.setViewName("/WEB-INF/jsp/welcome.jsp"); return mv; &#125;&#125; （2） 修改 springmvc 配置文件 处理器类的映射路径的写法：要求必须以/xxx/*的路径方式定义映射路径。其中*为通配符，在访问时使用要访问的方法名代替。 12345678910&lt;!-- 注册HandlerMapping --&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="urlMap"&gt; &lt;map&gt; &lt;entry key="/my/*.do" value="myController"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 注册处理器 --&gt;&lt;bean id="myController" class="com.huang.handlers.MyController"/&gt; （3） 访问方式 InternalPathMethodNameResolver 方法名解析器MultiActionController 类具有一个默认的 MethodNameResolver 解析器。该方法名解析器要求方法名以 URI 中资源名称的身份出现，即方法作为一种可以被请求的资源出现。即前面的写法： /xxx/方法名。 PropertiesMethodNameResolver 方法名解析器该方法名解析器中的方法名是作为 URI 资源名称中的一部分出现的，即方法名并非单独作为一种资源名称出现。例如请求时可以写为/xxx_doFirst，则会访问 xxx 所映射的处理器的doFirst()方法。 （1） 修改 springmvc配置文件 注意：这里的指定的请求，必须要加上.do，否则，无法完成匹配，将报 404 错误。 （2） 访问方式 ParameterMethodNameResolver 方法名解析该方法名解析器中的方法名作为请求参数的值出现。 （1） 修改 springmvc配置文件 （2） 访问方式 不指定参数名称，则可以使用 action 作为参数。 （1） 修改 springmvc 配置文件 12345678910111213141516&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="urlMap"&gt; &lt;map&gt; &lt;entry key="/my.do" value-ref="myController"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 注册方法名称解析器 --&gt;&lt;!-- 不指定paramName属性，则默认参数名称是action --&gt;&lt;bean id="parameterMethodNameResolver" class="org.springframework.web.servlet.mvc.multiaction.ParameterMethodNameResolver"&gt;&lt;/bean&gt;&lt;!-- 注册处理器 --&gt;&lt;bean id="myController" class="com.huang.handlers.MyController"&gt; &lt;property name="methodNameResolver" ref="parameterMethodNameResolver"/&gt;&lt;/bean&gt; （2） 访问方式 ModelAndViewModelAndView 即模型与视图 ，通过 addObject()方法向模型中添加数据，通过setViewName()方法向模型添加视图名称。 模型模型的本质就是 HashMap跟踪 addObject()方法，可以看出这里的模型就是 ModelMap，而 ModelMap 的本质就是个 HashMap，向 ModelAndView 中添加数据，就是向 HashMap 中添加数据。 HashMap 是一个单向查找数组HashMap底层是哈希表(散列表)，哈希表就是一个数组，数组的每个元素是一个单向链表；即 HashMap 的本质是一个单向链表数组。HashMap 类的内部类为 Entry 类，是一个可单向链表的数据结构：因为其只能通过 next 查找下一个元素，而无法查找上一个元素。 LinkedHashMapLinkedHashMap(双向链表) 的本质是一个 HashMap，但其将 Entry 内部类进行了扩展。 LinkedHashMap 中的 Entry 变为了双向的，可以通过 before 查找上一个元素，通过 after 查找下一个元素。 即从性能上说，LinkedHashMap 的操作性能要高于 HashMap。 总结：ModelAndView 中的模型对象是 ModelMap，其本质是一个 HashMap，向 ModelMap 中添加数据就是向 HashMap 中添加数据。这个 ModelMap 要比 HashMap 的性能更高。 视图通过 setViewName()指定视图名称。注意，这里的视图名称将会对应一个视图对象，一般是不会在这里直接写上要跳转的页面的。这个视图对象，将会被封装在ModelAndView中，传给视图解析器来解析，最终转换为相应的页面。 但需要注意的是，这里的 View 对象本质仅仅是一个 String 而已。后续的步骤中，还会继续对这个 View 对象进行进一步的封装。 若处理器方法返回的 ModelAndView 中并没有数据要携带，则可直接通过 ModelAndView 的带参构造器将视图名称放入 ModelAndView 中。 视图解析器 ViewResolver视图解析器 ViewResolver 接口负责将处理结果生成 View 视图。 常用的实现类有四种： 1. InternalResourceViewResolver(默认)该视图解析器用于完成对当前 Web 应用内部资源的封装与跳转。而对于内部资源的查找规则是，将 ModelAndView 中指定的视图名称与为视图解析器配置的前辍与后辍相结合的方式， 拼接成一个 Web 应用内部资源路径。拼接规则是： 前辍 + 视图名称 + 后辍。 InternalResourceView 解析器会把处理器方法返回的模型属性都存放到对应的 request 中，然后将请求转发到目标 URL。 缺点： 只可以完成将内部资源封装后的跳转。但无法转向外部资源，如外部网页。 对于内部资源的定义，也只能定义一种格式的资源：存放于同一目录的同一文件类型的资源文件。 2. BeanNameViewResolverBeanNameViewResolver 视图解析器，顾名思义就是将资源封装为“Spring 容器中注册的 Bean 实例”， ModelAndView 通过设置视图名称为该 Bean 的 id 属性值来完成对该资源的访问。 所以在 springmvc.xml 中， 可以定义多个 View 视图 Bean，让处理器中 ModelAndView 通过对这些 Bean 的 id 的引用来完成向 View 中封装资源的跳转。 RedirectView： 定义外部资源视图对象 JstlView： 定义内部资源视图对象 （1） 修改 springmvc 配置文件 1234567891011121314151617181920&lt;!-- 定义一个外部资源视图：京东 --&gt;&lt;bean id="jd" class="org.springframework.web.servlet.view.RedirectView"&gt; &lt;property name="url" value="http://www.jd.com"/&gt;&lt;/bean&gt; &lt;!-- 定义一个外部资源视图：淘宝 --&gt;&lt;bean id="taobao" class="org.springframework.web.servlet.view.RedirectView"&gt; &lt;property name="url" value="http://www.taobao.com"/&gt;&lt;/bean&gt;&lt;!-- 定义一个内部资源视图 --&gt;&lt;bean id="internalResource" class="org.springframework.web.servlet.view.JstlView"&gt; &lt;property name="url" value="/WEB-INF/jsp/welcome.jsp"/&gt;&lt;/bean&gt;&lt;!-- 注册视图解析器 --&gt;&lt;bean class="org.springframework.web.servlet.view.BeanNameViewResolver"/&gt;&lt;!-- 注册处理器 --&gt;&lt;bean id="/my.do" class="com.huang.handlers.MyController"&gt;&lt;/bean&gt; （2） 修改处理器类 123456789public class MyController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;// return new ModelAndView("taobao"); return new ModelAndView("jd"); &#125;&#125; 缺点：需要定义的 View 视图对象很多时，就会使 springmvc.xml 文件变得很大，很臃肿，不便于管理。 3. XmlViewResolverXmlViewResolver 解析器是将 View 视图对象专门抽取出来，单独定义为一个 xml 文件。 （1） 定义 myView 配置文件 123456789101112&lt;!-- 定义一个外部资源视图：淘宝 --&gt;&lt;bean id="taobao" class="org.springframework.web.servlet.view.RedirectView"&gt; &lt;property name="url" value="http://www.taobao.com"/&gt;&lt;/bean&gt;&lt;!-- 定义一个外部资源视图：京东 --&gt;&lt;bean id="jd" class="org.springframework.web.servlet.view.RedirectView"&gt; &lt;property name="url" value="http://www.jd.com"/&gt;&lt;/bean&gt;&lt;!-- 定义一个内部资源视图 --&gt;&lt;bean id="internalResource" class="org.springframework.web.servlet.view.JstlView"&gt; &lt;property name="url" value="/WEB-INF/jsp/welcome.jsp"/&gt;&lt;/bean&gt; （2） 定义 springmvc 配置文件 12345678&lt;!-- 注册视图解析器 --&gt;&lt;bean class="org.springframework.web.servlet.view.XmlViewResolver"&gt; &lt;property name="location" value="classpath:myViews.xml"/&gt;&lt;/bean&gt;&lt;!-- 注册处理器 --&gt;&lt;bean id="/my.do" class="com.huang.handlers.MyController"&gt;&lt;/bean&gt; 4. ResourceBundleViewResolverResourceBundleViewResolver 解析器需要定义在类路径下，即 src 下。而对于属性文件的写法，是有格式要求的： 资源名称.(class)=封装资源的 View 全限定性类名资源名称.url=资源路径 （1） 定义 properties 文件 12345678taobao.(class)=org.springframework.web.servlet.view.RedirectViewtaobao.url=http://www.taobao.comjd.(class)=org.springframework.web.servlet.view.RedirectViewjd.url=http://www.jd.cominternalResource.(class)=org.springframework.web.servlet.view.JstlViewinternalResource.url=/WEB-INF/jsp/welcome.jsp （2） 定义 springmvc 配置文件 12345678&lt;!-- 注册视图解析器 --&gt;&lt;bean class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt; &lt;property name="basename" value="myViews"/&gt;&lt;/bean&gt;&lt;!-- 注册处理器 --&gt;&lt;bean id="/my.do" class="com.huang.handlers.MyController"&gt;&lt;/bean&gt; 视图解析器的优先级视图解析器有一个 order 属性，专门用于设置多个视图解析器的优先级。 数字越小，优先级越高。数字相同，先注册的优先级高。 一般不为 InternalResourceViewResolver 解析器指定优先级，即让其优先级是最低的。 若没有 order 属性，四个视图解析器中，ResourceBundleViewResolver 解析器的优先级最高。]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC概述]]></title>
    <url>%2F2019%2F08%2F12%2FSpringMVC%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[SpringMVC 全称是 Spring Web MVC，是 Spring 框架一部分，是一个 MVC 的框架，和 Struts2 一样是一个表现层框架，是在 Spring3.0 后发布的。 SpringMVC简介 由以上 Spring 的结构图可以看出， Spring 由四大部分组成： Dao 部分（DAO 与 ORM）、AOP 部分、 Web 部分（JEE 与 Web），及 IoC 容器部分（Core）。Web 部分第一个就是 Spring Web MVC，其实 SpringMVC 是 Spring 框架的一个模块 第一个SpringMVC程序需求：用户提交一个请求，服务端处理器在接收到这个请求后，给出一条欢迎信息，在响应页面中显示该信息。 开发流程1. 注册中央调度器1234567891011121314151617181920212223&lt;!-- 注册中央调度器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定springMVC配置文件的位置及文件名 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 在Tomcat启动时直接创建当前Servlet --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;load-on-startup/&gt;在&lt;servlet/&gt;中添加&lt;load-on-startup/&gt;的作用是，标记是否在Web服务器（这里是Tomcat）启动时会创建这个 Servlet 实例，即是否在 Web 服务器启动时调用执行该 Servlet 的 init()方法， 而不是在真正访问时才创建。它的值必须是一个整数。 当值大于等于 0 时，表示容器在启动时就加载并初始化这个 servlet，数值越小，该 Servlet 的优先级就越高， 其被创建的也就越早。 当值小于 0 或者没有指定时，则表示该 Servlet 在真正被使用时才会去创建。 当值相同时，容器会自己选择创建顺序。 &lt;url-pattern/&gt;对于&lt;url-pattern/&gt;，不能写为/*，最好也不要写为/，建议写为*.do 的形式。 2. 定义处理器该处理器需要实现 Controller 接口。 1234567891011public class MyController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject("message", "Hello SpringMVC World!"); mv.setViewName("welcome"); return mv; &#125;&#125; 注意：odelAndView 类中的 addObject()方法用于向其 Model 中添加数据。 Model 的底层为一个 Map。addObject()方法的返回值为 ModelAndView，则说明可向该 Model 中连续添加多个数据。 3. 定义目标页面在 WEB-INF 目录下新建一个子目录 jsp，在其中新建一个 jsp 页面 welcome.jsp。 1234567891011&lt;%@ page language="java" contentType="text/html; charset=ISO-8859-1" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;welcome page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;message &#125;&lt;/body&gt;&lt;/html&gt; 4. 创建 SpringMVC 配置文件在工程的类路径即 src 目录下创建 SpringMVC 的配置文件 springmvc.xml。该文件名可以任意命名。 1234567891011 &lt;!-- 注册视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt;&lt;!-- 注册处理器 :处理器的 id 属性值为一个请求 URI。表示当客户端提交该请求时，会访问 class 指定的这个处理器。--&gt; &lt;bean id="/my.do" class="com.huang.handlers.MyController"&gt;&lt;/bean&gt; 5. 定义 index 页面123456789101112&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; This is my JSP page. &lt;br&gt; &lt;/body&gt;&lt;/html&gt; SpringMVC执行流程 执行流程简单分析（1）浏览器提交请求到中央调度器。（2）中央调度器直接将请求转给处理器映射器。（3）处理器映射器会根据请求，找到处理该请求的处理器，并将其封装为处理器执行链后返回给中央调度器。（4）中央调度器根据处理器执行链中的处理器，找到能够执行该处理器的处理器适配器。（5）处理器适配器调用执行处理器。（6）处理器将处理结果及要跳转的视图封装到一个对象 ModelAndView 中，并将其返回给处理器适配器。（7）处理器适配器直接将结果返回给中央调度器。（8）中央调度器调用视图解析器，将 ModelAndView 中的视图名称封装为视图对象。（9）视图解析器将封装了的视图对象返回给中央调度器。（10）中央调度器调用视图对象，让其自己进行渲染，即进行数据填充，形成响应对象。（11）中央调度器响应浏览器。 API 简要说明DispatcherServlet中央调度器，也称为前端控制器，在 MVC 架构模式中充当控制器 C， DispatcherServlet是整个流程的控制中心，由它调用诸如处理器映射器、处理器适配器、视图解析器等其它组件处理用户请求。 中央调度器的存在降低了组件之间的耦合度。 HandlerMapping处理器映射器， 负责根据用户请求找到相应的将要执行的 Handler，即处理器。 即用于完成将用户请求映射为要处理该请求的处理器，并将处理器封装为处理器执行链传给中央调度器。 HandlAdapter处理器适配器， 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 中央调度器会根据不同的处理器自动为处理器选择适配器，以执行处理器。 Handler处理器，也称为后端控制器，在 DispatcherServlet 的控制下 Handler 调用 Service 层对具体的用户请求进行处理。由于 Handler 涉及到具体的用户业务请求，所以一般情况下需要程序员根据业务需求自己开发 Handler。 ViewResolver视图解析器， 负责将处理结果生成 View 视图， ViewResolver 首先将逻辑视图名解析为物理视图名，即具体的页面地址，再生成 View 视图对象。最后将处理结果通过页面形式展示给用户。SpringMVC 框架提供了很多的 View 视图类型，包括： JstlView、 RedirectView 等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 DispatcherServlet 的默认配置 组件名称 默认值 处理器映射器 BeanNameUrlHandlerMapperingDefaultAnnotationHandlerMapping 处理器适配器 HttpRequestHandlerAdaperSimpleControllerHandlerAdaperAnnotationMethodHandlerAdaper 视图解析器 InternalResourceViewResolver 详解&lt;url-pattern/&gt;配置详解建议写为*.do 形式在没有特殊要求的情况下， SpringMVC 的中央调度器 DispatcherServlet 的&lt;url-pattern/&gt;常使用后辍匹配方式，如写为*.do。 不能写为/*这里的 url-pattern 不能写为/*，因为 DispatcherServlet 会将向动态页面的跳转请求， 即向 JSP 页面的跳转请求也当作是一个普通的 Controller 请求。 中央调度器会调用处理器映射器为其查找相应的处理器。当然是找不到的，所以在这种情况下， 所有的 JSP 页面跳转均会报 404 错误。 最好也不要写为/最好也不要写为/，因为 DispatcherServlet 会将向静态资源的获取请求，例如.css、 .js、 .jpg、 .png 等资源的获取请求，当作是一个普通的 Controller 请求。 中央调度器会调用处理器映射器为其查找相应的处理器。当然也是找不到的，所以在这种情况下，所有的静态资源获取请求也均会报 404 错误(动态资源不会提交)。 静态资源访问1. 使用 Tomcat 中名为 default 的 Servlet在 Tomcat 中，有一个专门用于处理静态资源访问的 Servlet – DefaultServlet。 其&lt;servlet-name/&gt;为 default。可以处理各种静态资源访问请求。 该 Servlet 注册在 Tomcat 服务器的 web.xml 中。在 Tomcat 安装目录/conf/web.xml。 直接在 web.xml 中注册&lt;servlet-mapping/&gt;即可使用。 1234567891011121314&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2. 使用&lt;mvc:default-servlet-handler/*gt;1&lt;mvc:default-servlet-handler/&gt; &lt;mvc:default-servlet-handler/&gt; 会将对静态资源的访问请求添加到 SimpleUrlHandlerMapping 的 urlMap 中， key 就是请求的 URI， 而 value 则为默认 Servlet 请求处理器 DefaultServletHttpRequestHandler 对象。而该处理器调用了 Tomcat 的 DefaultServlet 来处理静态资源的访问请求。 注意：使用&lt;mvc: …/&gt;标签，需要引入 mvc 约束。 3. 使用&lt;mvc:resources/&gt;在 Spring3.0.4 版本后， Spring 中定义了专门用于处理静态资源访问请求的处理器 ResourceHttpRequestHandler。并且添加了&lt;mvc:resources/&gt;标签，专门用于解决静态资源无法访问问题。 需要在 springmvc.xml 中添加如下形式的配置： 1&lt;mvc:resources location="/images/" mapping="/images/**"/&gt; location 表示静态资源所在目录。 当然，这里的目录包含/WEB-INF/目录及其子目录。 mapping 表示对该资源的请求。 注意，后面是两个星号**。 该配置会把对该静态资源的访问请求添加到 SimpleUrlHandlerMapping 的 urlMap 中， key 就是真正与 mapping 的 URI 匹配的 URI ， 而 value 则为静态资源处理器对象ResourceHttpRequestHandler。 绝对路径与相对路径前面对于 my.do 请求的提交是通过地址栏直接提交请求的。对于浏览器请求的提交方式，还可以有表单提交、超链接提交、 Ajax 提交等。与地址栏提交不同的时，这些提交方式均需要将请求写在页面文件中。下面以超链接提交方式来讲解有关路径问题。 访问路径与资源名称通常的 URL 资源访问路径由两部分构成： 访问路径与资源名称。资源名称指的是要访问资源的直接名称，如 index.jsp，或与要访问资源存在映射关系的间接名称，如 my.do。而访问路径，则是通过该路径则可以定位到指定的资源，即在 URL 资源访问路径中除了资源名称以外的其它部分。 据“访问路径是否可以独立完成资源准确定位”的判别标准，可以将访问路径分为绝对路径与相对路径。 绝对路径绝对路径，是指根据给出的访问路径可以准确定位到资源的路径。对于计算机中 Web 应用的绝对路径， 则是指带访问协议的路径。 例如下面的路径就是一个带有 http 访问协议的绝对路径。 1http://localhost:8080/primary/my.do 相对路径相对路径，是指仅根据访问路径无法准确定位资源的路径。 相对路径必须要结合其参照路径才可组成可以准确定位资源的绝对路径。 参照路径的不同，所形成的可以准确定位资源的绝对路径也是不同的。在进行资源访问时，必须要将相对路径转换为绝对路径才可完成资源的准确定位。 在 Web 应用中，相对路径的写法有两种：一种是以斜杠开头的相对路径，一种是不以斜杠开头的相对路径。 根据相对路径是否以斜杠开头，且出现的文件所处位置的不同，其默认的参照路径是不同的。 这也是相对路径容易出错的地方。 1. 以斜杠开头的相对路径以斜杠开头的相对路径，根据路径所在文件所处位置的不同，分为两种：前台路径与后台路径。 前台路径所谓前台路径是指，由浏览器解析执行的代码中所包含的路径。例如， html、 css、 js中的路径，及 jsp 中静态部分的路径。像 html 及 jsp 中的静态部分中的&lt;img src=””/&gt;、 &lt;a href=””&gt;&lt;/a&gt;、 &lt;form action=””&gt;&lt;/form&gt;等；像 css 中的 background:img(“”)等；像 js 中的 window.location.href=””等，都属于前台路径。前台路径的参照路径是 Web 服务器的根路径，即 http://localhost:8080/ 后台路径所谓后台路径是指，由服务器解析执行的代码及文件中所包含的路径。例如， java 代码中的路径、 jsp 文件动态部分（java 代码块） 中的路径、 xml 文件中的路径（xml 文件是要被java 代码加载入内存，并由 java 代码解析的）等。后台路径的参照路径是 Web 应用的根路径。http://localhost:8080/primary/ 后台路径特例当代码中使用 response 的 sendRedirect()方法进行重定向时，其参照路径不是 web 应用的根路径，而是 web 服务器的根路径。所以若要使用重定向，要么写为无斜杠的相对路径(在定义处理器接口步骤修改Java代码)： 1response.sendRedirect(“welcome.jsp”); 要么写在路径上添加上项目名称： 1response.sendRedirect(request.getContextPath + “/welcome.jsp”); 2. 不以斜杠开头的相对路径不以斜杠开头的相对路径，无论是前台路径，还是后台路径， 其参照路径都是当前资源的访问路径，而不是当前资源的保存路径(去掉资源名称)。 相关现象解析为什么页面超链接的 herf 属性值加上斜杠会报错原因分析为什么在 springmvc.xml 中注册处理器时其 name 属性值是以斜杠开头，而 index.jsp 页面中的超链接的 herf 属性值加上斜杠后会报错？ 1&lt;bean id="/my.do" class="com.huang.handlers.MyController"&gt;&lt;/bean&gt; 解释：这是后台路径：出现在Java代码、xml文件或properties等配置文件中的，以斜杠/开头的路径为后台路径后台路径的参照路径是：当前web应用的根 http://localhost:8080/requestPath绝对路径 = 参照路径 + 相对路径这里对于处理器的注册，意思是，若要想访问MyController这个处理器，必须提交一个请求，这个请求，以后台路径的方式给出这个/my.do后台路径，转变为绝对路径是： http://localhost:8080/requestPath/my.do也就是说，用户若要访问MyContrller这个处理器，必须提交的请求为： http://localhost:8080/requestPath/my.do 12&lt;!-- 这个请求是访问不到的 --&gt;&lt;a href="/my.do"&gt;跳转到welcome页面&lt;/a&gt; 解释：这个是前台路径：出现在jsp页面中的路径，就是前台路径前台路径的参照路径是：当前web服务器的根，就本例而言，当前web服务器的根是： http://localhost:8080绝对路径 = 参照路径 + 相对路径这里提交的请求是以相对路径的方式提交的，将这个相对路径转变为绝对路径是： http://localhost:8080/my.do也就是说，这里提交的请求是： http:/localhost:8080/my.do 解决办法（1） 手工为 href 属性值的相对路径上添加项目名称(不建议使用此方法)。 1&lt;a href="/requestPath/my.do"&gt;跳转到welcome页面&lt;/a&gt; （2） 通过 EL 表达式${pageContext.request.contextPath}动态的获取到项目名称。 1&lt;a href="$&#123;pageContext.request.contextPath &#125;/my.do"&gt;跳转到welcome页面&lt;/a&gt; 为什么跳转回 index 页面后地址栏会多出一个 test原因分析为什么会多出一个/test 呢？因为超链接的 herf 属性值为无斜杠的相对路径，所以其参照路径为当前的访问路径 。 （1） springmvc 配置文件 1&lt;bean id="/test/my.do" class="com.huang.handlers.MyController"/&gt; （2） index 页面 1&lt;a href="test/my.do"&gt;我是一个表单的提交按键&lt;/a&gt; 解释：请求路径 = 访问路径 + 资源名称不带斜杠的相对路径，其参照路径是：当前的访问路径绝对路径 = 参照路径 + 相对路径发出第一次请求时的访问路径是： http://localhost:8080/requestPath当前超链接所提交的相对路径转变为绝对路径是： http://localhost:8080/requestPath/test/my.do发出第一次请求时的访问路径是： http://localhost:8080/requestPath/test当前超链接所提交的相对路径转变为绝对路径是：http://localhost:8080/requestPath/test/test/my.do 解决办法（1） 使用斜杠开头的请求路径 1&lt;a href="$&#123;pageContext.request.contextPath &#125;/test/my.do"&gt;我是一个表单的提交按键&lt;/a&gt; （2） 不使用斜杠开头的请求路径 使用 JSP 的&lt;base/&gt;标签。页面中的&lt;base/&gt;标签，会在当前页面的资源请求路径前自动加上&lt;base/&gt;标签所代表的路径，将相对路径变为带访问协议的绝对路径。 1234567891011121314151617&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="test/my.do"&gt;我是一个表单的提交按键&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring与DAO]]></title>
    <url>%2F2019%2F08%2F10%2FSpring%E4%B8%8EDAO%2F</url>
    <content type="text"><![CDATA[Spring 所使用的操作数据库的技术： JDBC 模板的使用和 Spring 对于事务的管理。 JDBC 模板的使用，是 IoC 的应用，将 JDBC 模板对象注入给了 Dao 层的实现类。 Spring 的事务管理， 是 AOP 的应用，将事务作为切面织入到了 Service 层的业务方法中。 Spring与JDBC模板为了避免直接使用 JDBC 而带来的复杂且冗长的代码， Spring 提供了一个强有力的模板类——JdbcTemplate 来简化 JDBC 操作。并且，数据源 DataSource 对象与模板 JdbcTemplate 对象均可通过 Bean 的形式定义在配置文件中，充分发挥了依赖注入的威力。 数据源的配置使用 JDBC 模板，首先需要配置好数据源，数据源直接以 Bean 的形式配置在 Spring 配置文件中。根据数据源的不同，其配置方式不同。常用数据源的配置方式有三种： Spring 默认的数据源 DBCP 数据源 C3P0 数据源 Spring 默认的数据源Spring 默认的数据源为 DriverManagerDataSource，其有一个属性 DriverClassName，用于接收 DB 驱动。DriverManagerDataSource 类继承自 AbstractDriverBasedDataSource。其有三个属性用于接收连接数据库的 URL、用户名与密码。 1234567&lt;!-- 注册数据源：Spring内置连接池 --&gt;&lt;bean id="myDataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt;&lt;/bean&gt; DBCP 数据源DBCP(DataBase Connection Pool)，是 apache 下的项目，DBCP 数据源是 BasicDataSource，其有 driverClassName、 url、 username、 password 四个 DB 连接属性。 1234567&lt;!-- 注册数据源：DBCP --&gt;&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt;&lt;/bean&gt; C3P0 数据源C3P0 数据源是 ComboPooledDataSource ，其有 DriverClass、JdbcUrl、 User、 Password 四个 DB 连接属性。 1234567&lt;!-- 注册数据源：C3P0 --&gt;&lt;bean id="myDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt; 从属性文件读取数据库连接信息为了便于维护，可以将数据库连接信息写入到属性文件中，使 Spring 配置文件从中读取数据。 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.user=rootjdbc.password=123456 Spring 配置文件从属性文件中读取数据时，需要在&lt;property/&gt;的 value 属性中使用${ }，将在属性文件中定义的 key 括起来，以引用指定属性的值。 该属性文件若要被 Spring 配置文件读取，其必须在配置文件中进行注册。注册方式有两种： &lt;bean/&gt;方式 &lt;context/&gt;方式 &lt;bean/&gt;方式以 PropertyPlaceholderConfigurer 类的 bean 实例的方式进行注册。该类有一个属性 location，用于指定属性文件的位置。 1234&lt;!-- 注册属性文件：方式一 --&gt;&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties"/&gt;&lt;/bean&gt; &lt;context:property-placeholder/&gt;方式12&lt;!-- 注册属性文件：方式二 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; 注意：该方式要求在 Spring 配置文件头部加入 context 的约束，&lt;context:property-placeholder/&gt;标签中有一个属性 location，用于指定属性文件的位置。 配置JDBC模板JDBC 模板类 JdbcTemplate 从其父类 JdbcAccessor 继承了一个属性 dataSource，用于接收数据源。 12345&lt;!-- 注册JdbcTemplate --&gt;&lt;bean id="myJdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt; Dao实现类继承JdbcDaoSupportJdbcDaoSupport 类中有一个属性 JdbcTemplate，用于接收 JDBC 模板。所以 Dao 实现类继承了 JdbcDaoSupport 类后，也就具有了 JDBC 模板属性。在配置文件中，只要将模板对象注入即可。 对DB的增、删、改操作JdbcTemplate 类中提供了对 DB 进行修改、查询的方法。 Dao 实现类使用继承自 JdbcDaoSupport 的 getTemplate()方法，可以获取到 JDBC 模板对象。 123456789101112public interface IStudentDao &#123; void insertStudent(Student student); void deleteById(int id); void updateStudent(Student student); List&lt;String&gt; selectAllStudentsNames(); String selectStudentNameById(int id); List&lt;Student&gt; selectAllStudents(); Student selectStudnetById(int id);&#125; 对 DB 的增、删、改都是通过 update()方法实现的。该方法常用的重载方法有两个： 1public int update ( String sql) 1public int update ( String sql, Object… args) 第 1 个参数为要执行的 sql 语句，第 2 个参数为要执行的 sql 语句中所包含的动态参数。其返回值为所影响记录的条数。一般不用。 对DB的查询操作JDBC 模板的查询结果均是以对象的形式返回。根据返回对象类型的不同，可以将查询分为两类： 简单对象查询：查询结果为 String、 Integer 等简单对象类型，或该类型做为元素的集合类型，如 List&lt;String&gt;等。 自定义对象查询：查询结果为自定义类型，如 User 等，或该类型做为元素的集合类型，如 List&lt;User&gt;等。 简单对象查询常用的简单对象查询方法有：查询结果为单个对象的 queryForObject()与查询结果为 List的 queryForList()。 1pubic T queryForObject (String sql, Class&lt;T&gt; type, Object... args) 1pubic List&lt;T&gt; queryForList (String sql, Class&lt;T&gt; type, Object... args) 1234567891011@Overridepublic List&lt;String&gt; selectAllStudentsNames() &#123; String sql = "select name from student"; return this.getJdbcTemplate().queryForList(sql, String.class);&#125;@Overridepublic String selectStudentNameById(int id) &#123; String sql = "select name from student where id=?"; return this.getJdbcTemplate().queryForObject(sql, String.class, id);&#125; 自定义对象查询常用的自定义对象查询方法有：查询结果为单个对象的 queryForObject()与查询结果为List 的 query()。 1pubic T queryForObject (String sql, RowMapper&lt;T&gt; m , Object... args) 1pubic List&lt;T&gt; query (String sql, RowMapper&lt;T &gt; m, Object... args) RowMapper 为记录映射接口，用于将查询结果集中每一条记录包装为指定对象。该接口中有一个方法需要实现： 1public Object mapRow(ResultSet rs, int rowNum) 参数 rowNum 表示总的结果集中当前行的行号，但参数 rs 并不表示总的结果集，而是表示 rowNum 所代表的当前行的记录所定义的结果集，仅仅是当前行的结果。一般来说，该方法体中就是实现将查询结果中当前行的数据包装为一个指定对象。 123456789101112131415public class StudentRowMapper implements RowMapper&lt;Student&gt; &#123; // rs：当查询出总的结果集后，框架会自动遍历这个结果集，每一次遍历的一行数据，都会被存放到 // 这个方法的rs参数中。也就是说，这里的rs代表的是一行数据，并非所有查询结果。换个角度 // 来说，只要能执行到这个方法，就说明这里的rs不会是空的 @Override public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Student student = new Student(); student.setId(rs.getInt("id")); student.setName(rs.getString("name")); student.setAge(rs.getInt("age")); return student; &#125;&#125; 1234567891011@Overridepublic List&lt;Student&gt; selectAllStudents() &#123; String sql = "select id,name,age from student"; return this.getJdbcTemplate().query(sql, new StudentRowMapper());&#125;@Overridepublic Student selectStudnetById(int id) &#123; String sql = "select id,name,age from student where id=?"; return this.getJdbcTemplate().queryForObject(sql, new StudentRowMapper(), id);&#125; 注意：JdbcTemplate 对象是多例的，即系统会为每一个使用模板对象的线程（方法）创建一个 JdbcTemplate 实例，并且在该线程（方法）结束时，自动释放 JdbcTemplate 实例。所以在每次使用 JdbcTemplate 对象时，都需要通过 getJdbcTemplate()方法获取。 Spring的事务管理事务原本是数据库中的概念，在 Dao 层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。在 Spring 中通常可以通过以下三种方式来实现对事务的管理： 使用 Spring 的事务代理工厂管理事务 使用 Spring 的事务注解管理事务 使用 AspectJ 的 AOP 配置管理事务 Spring事务管理APISpring 的事务管理，主要用到两个事务相关的接口。 1. 事务管理器接口事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。 常用的两个实现类 DataSourceTransactionManager：使用 JDBC 或 iBatis 进行持久化数据时使用。 HibernateTransactionManager：使用 Hibernate 进行持久化数据时使用。 Spring 的回滚方式Spring 事务的默认回滚方式是： 发生运行时异常时回滚，发生受查异常时提交。对于受查异常，也可以手工设置其回滚方式。 错误与异常 Throwable 类是 Java 语言中所有错误或异常的超类。只有当对象是此类(或其子类之一)的实例时， 才能通过 Java 虚拟机或者 Java 的 throw 语句抛出。 Error 是程序在运行过程中出现的无法处理的错误，比如OutOfMemoryError、ThreadDeath、 NoSuchMethodError 等。当这些错误发生时，程序是无法处理（捕获或抛出）的， JVM 一般会终止线程。 程序在编译和运行时出现的另一类错误称之为异常，它是 JVM 通知程序员的一种方式。通过这种方式，让程序员知道已经或可能出现错误，要求程序员对其进行处理。 异常分为运行时异常与受查异常： 运行时异常， 是 RuntimeException 类或其子类 ， 即只有在运行时才出现的异常。如，NullPointerException、 ArrayIndexOutOfBoundsException、 IllegalArgumentException 等均属于运行时异常。这些异常由 JVM 抛出，在编译时不要求必须处理（捕获或抛出）。但，只要代码编写足够仔细，程序足够健壮，运行时异常是可以避免的。(Hibernate 异常 HibernateException 也属于运行时异常)。 受查异常，也叫编译时异常，即在代码编写时要求必须捕获或抛出的异常，若不处理，则无法通过编译。如 SQLException， ClassNotFoundException， IOException 等都属于受查异常。 RuntimeException 及其子类以外的异常，均属于受查异常。当然，用户自定义的 Exception 的子类，即用户自定义的异常也属受查异常。 定义异常时，只要未明确声明定义的为 RuntimeException 的子类，那么定义的就是受查异常。 2. 事务定义接口事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量： 事务隔离级别、事务传播行为、事务默认超时时限， 及对它们的操作。 定义了五个事务隔离级别常量这些常量均是以 ISOLATION_开头。即形如 ISOLATION_XXX。 DEFAULT： 采用 DB 默认的事务隔离级别。 MySql 的默认为 REPEATABLE_READ； Oracle 默认为 READ_COMMITTED。 READ_UNCOMMITTED： 读未提交。 未解决任何并发问题。 READ_COMMITTED： 读已提交。解决脏读，存在不可重复读与幻读。 REPEATABLE_READ： 可重复读。解决脏读、不可重复读，存在幻读。 SERIALIZABLE： 串行化。不存在并发问题。 定义了七个事务传播行为常量谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如， A 事务中的方法 doSome()调用 B 事务中的方法 doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。 事务传播行为常量都是以 PROPAGATION_ 开头，形如 PROPAGATION_XXX。 REQUIRED： 指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。 SUPPORTS： 指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。 MANDATORY： 指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。 REQUIRES_NEW： 总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。 NOT_SUPPORTED： 指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。 NEVER： 指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。 NESTED： 指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。 定义了默认事务超时时常量 TIMEOUT_DEFAULT 定义了事务底层默认的超时时限，及不支持事务超时时限设置的 none 值。 注意：事务的超时时限起作用的条件比较多，且超时的时间计算点较复杂。所以，该值一般就使用默认值即可。 程序举例需求：实现模拟购买股票。存在两个实体：银行账户 Account 与股票账户 Stock。当要购买股票时，需要从 Account 中扣除相应金额的存款，然后在 Stock 中增加相应的股票数量。而在这个过程中，可能会抛出一个用户自定义的异常。异常的抛出，将会使两个操作回滚。 实现步骤： 1. 创建数据库表 2. 创建实体类123456public class Account &#123; private Integer aid; private String aname; private double balance; //余额&#125; 123456public class Stock &#123; private Integer sid; private String sname; //股票名称 private int count; //股票数量&#125; 3. 定义 service 的实现类根据需求，我们可以先定义 Service 实现类，自动生成 Service 接口、Dao 接口和异常类，以减少代码写入。 123456789101112131415161718192021222324252627282930313233343536public class BuyStockServiceImpl implements IBuyStockService &#123; private IAccountDao adao; private IStockDao sdao; public void setAdao(IAccountDao adao) &#123; this.adao = adao; &#125; public void setSdao(IStockDao sdao) &#123; this.sdao = sdao; &#125; @Override public void openAccount(String aname, double money) &#123; adao.insertAccount(aname,money); &#125; @Override public void openStock(String sname, int amount) &#123; sdao.insertStock(sname,amount); &#125; @Override public void buyStock(String aname, double money, String sname, int amount) throws BuyStockException &#123; boolean isBuy = true; adao.updateAccount(aname,money,isBuy); if(1 == 1) &#123; throw new BuyStockException("购买股票异常"); &#125; sdao.updateStock(sname,amount,isBuy); &#125;&#125; 4. 定义 Service 接口1234567public interface IBuyStockService &#123; void openAccount(String aname,double money); void openStock(String sname, int amount); void buyStock(String aname,double money,String sname,int amount) throws BuyStockException;&#125; 5. 定义 dao 接口1234567public interface IAccountDao &#123; void insertAccount(String aname, double money); void updateAccount(String aname, double money, boolean isBuy);&#125; 1234567public interface IStockDao &#123; void insertStock(String sname, int amount); void updateStock(String sname, int amount, boolean isBuy);&#125; 6. 定义异常类12345678910public class BuyStockException extends Exception &#123; public BuyStockException() &#123; super(); &#125; public BuyStockException(String message) &#123; super(message); &#125;&#125; 7. 定义 dao 实现类123456789101112131415161718public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123; @Override public void insertAccount(String aname, double money) &#123; String sql = "insert into account(aname, balance) values(?,?)"; this.getJdbcTemplate().update(sql, aname, money); &#125; @Override public void updateAccount(String aname, double money, boolean isBuy) &#123; String sql = "update account set balance=balance+? where aname=?"; if (isBuy) &#123; sql = "update account set balance=balance-? where aname=?"; &#125; this.getJdbcTemplate().update(sql, money, aname); &#125;&#125; 12345678910111213141516171819public class StockDaoImpl extends JdbcDaoSupport implements IStockDao &#123; @Override public void insertStock(String sname, int amount) &#123; String sql = "insert into stock(sname,count) values(?,?)"; this.getJdbcTemplate().update(sql, sname,amount); &#125; @Override public void updateStock(String sname, int amount, boolean isBuy) &#123; String sql = "update stock set count=count-? where sname=?"; if (isBuy) &#123; sql = "update stock set count=count+? where sname=?"; &#125; this.getJdbcTemplate().update(sql, amount,sname); &#125;&#125; 8. 定义 Spring 配置文件(IoC应用)123456789101112131415161718192021222324&lt;!-- 注册数据源：C3P0 --&gt;&lt;bean id="myDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/bean&gt;&lt;!-- 注册属性文件 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;!-- 注册Dao --&gt;&lt;bean id="accountDao" class="com.huang.dao.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt;&lt;bean id="stockDao" class="com.huang.dao.StockDaoImpl"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt;&lt;!-- 注册Service --&gt;&lt;bean id="buyStockService" class="com.huang.service.BuyStockServiceImpl"&gt; &lt;property name="adao" ref="accountDao"/&gt; &lt;property name="sdao" ref="stockDao"/&gt;&lt;/bean&gt; 9. 定义测试类1234567891011121314151617181920212223242526public class MyTest &#123; private IBuyStockService service; @Before public void before() &#123; // 创建容器对象，加载Spring配置文件 String resource = "applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); service = (IBuyStockService) ac.getBean("buyStockService"); &#125; @Test public void test01() &#123; service.openAccount("张三", 10000); service.openStock("现代学院", 0); &#125; @Test public void test02() throws BuyStockException &#123; service.buyStock("张三", 2000, "现代学院", 5); &#125; &#125; 10. 运行结果 使用Spring的事务代理工厂管理事务该方式是，需要为目标类，即 Service 的实现类创建事务代理。事务代理使用的类是 TransactionProxyFactoryBean，该类需要初始化如下一些属性： （1） transactionManager：事务管理器（2） target：目标对象，即 Service 实现类对象（3） transactionAttributes：事务属性 1. 修改 Spring 配置文件(AOP应用)1234567891011121314151617181920&lt;!-- 注册事务管理器 --&gt;&lt;bean id="myTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt;&lt;!-- 生成事务代理对象 --&gt;&lt;bean id="serviceProxy" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt; &lt;property name="transactionManager" ref="myTransactionManager"/&gt; &lt;property name="target" ref="buyStockService"/&gt; &lt;property name="transactionAttributes"&gt; &lt;props&gt; &lt;prop key="open*"&gt;ISOLATION_DEFAULT,PROPAGATION_REQUIRED&lt;/prop&gt; &lt;!-- -异常：表示发生指定异常后回滚，这时的异常通常是受查异常 +异常：表示发生指定异常后提交，这时的异常通常是运行时异常 --&gt; &lt;prop key="buyStock"&gt;ISOLATION_DEFAULT,PROPAGATION_REQUIRED, -BuyStockException&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 2. 修改测试类1service = (IBuyStockService) ac.getBean("serviceProxy"); 使用Spring的事物注解管理事务通过@Transactional 注解方式，也可将事务织入到相应方法中。而使用注解方式，只需在配置文件中加入一个 tx 标签，以告诉 spring 使用注解来完成事务的织入。该标签只需指定一个属性，事务管理器。 @Transactional 的所有可选属性如下所示： propagation： 用于设置事务传播属性。该属性类型为 Propagation 枚举，默认值为 Propagation.REQUIRED。 isolation： 用于设置事务的隔离级别。该属性类型为 Isolation 枚举 ，默认值为 Isolation.DEFAULT。 readOnly： 用于设置该方法对数据库的操作是否是只读的。该属性为 boolean，默认值为 false。 timeout： 用于设置本操作与数据库连接的超时时限。单位为秒，类型为 int，默认值为-1，即没有时限。 rollbackFor： 指定需要回滚的异常类。类型为 Class[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。 rollbackForClassName： 指定需要回滚的异常类类名。类型为 String[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。 noRollbackFor： 指定不需要回滚的异常类。类型为 Class[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。 noRollbackForClassName： 指定不需要回滚的异常类类名。类型为 String[]，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。 注意：@Transactional 若用在方法上，只能用于 public 方法上。对于其他非 public方法，如果加上了注解@Transactional，虽然 Spring 不会报错，但不会将指定事务织入到该方法中。因为 Spring 会忽略掉所有非 public 方法上的@Transaction 注解。若@Transaction 注解在类上，则表示该类上所有的方法均将在执行时织入事务。 1. 修改 Spring 配置文件(AOP应用)1234567&lt;!-- 注册事务管理器 --&gt;&lt;bean id="myTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt;&lt;!-- 注册事务注解驱动 --&gt;&lt;tx:annotation-driven transaction-manager="myTransactionManager"/&gt; 2. 修改测试类1service = (IBuyStockService) ac.getBean("buyStockService"); 3. 在 Service 实现类方法上添加注解 使用AspectJ的AOP配置管理事务使用 XML 配置事务代理的方式的不足是，每个目标类都需要配置事务代理。当目标类较多，配置文件会变得非常臃肿。使用 XML 配置顾问方式可以自动为每个符合切入点表达式的类生成事务代理。 修改配置文件(AOP应用)123456789101112131415161718192021&lt;!-- 注册事务管理器 --&gt;&lt;bean id="myTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="myDataSource"/&gt;&lt;/bean&gt;&lt;!-- 注册事务通知 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="myTransactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 这里指定的是：为每一个连接点指定所要应用的事务属性 --&gt; &lt;tx:method name="open*" isolation="DEFAULT" propagation="REQUIRED"/&gt; &lt;tx:method name="buyStock" isolation="DEFAULT" propagation="REQUIRED" rollback-for="BuyStockException"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- AOP配置 --&gt;&lt;aop:config&gt; &lt;!-- 这里指定的是切入点 --&gt; &lt;aop:pointcut expression="execution(* *..service.*.*(..))" id="myPointcut"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="myPointcut"/&gt;&lt;/aop:config&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>DAO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring与AOP]]></title>
    <url>%2F2019%2F08%2F08%2FSpring%E4%B8%8EAOP%2F</url>
    <content type="text"><![CDATA[AOP 简介AOP（Aspect Orient Programming），面向切面编程，是面向对象编程 OOP 的一种补充。面向对象编程是从静态角度考虑程序的结构，而面向切面编程是从动态角度考虑程序运行过程。AOP 底层采用两种动态代理模式实现： JDK 的动态代理与 CGLIB 的动态代理。 AOP 编程术语1. 切面切面(Aspect)泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面有通知与顾问。实际就是对主业务逻辑的一种增强。 2. 织入织入(Weaving)是指将切面代码插入到目标对象的过程。 3. 连接点连接点(JoinPoint)指可以被切面织入的方法。通常业务接口中的方法均为连接点。 4. 切入点切入点(Pointcut)指切面具体织入的方法。注意，被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改的，不能被增强的。 5. 目标对象目标对象(Target)指将要被增强的对象，即包含主业务逻辑的类的对象 。 6. 通知通知(Advice)是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。换个角度来说， 通知定义了增强代码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同(切入点定义切入的位置，通知定义切入的时间)。 7. 顾问顾问(Advisor)是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。 通知 Advice通知（Advice），切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。 常用通知有：前置通知、后置通知、环绕通知、异常处理通知。 通知详解通知（Advice）是 Spring 提供的一种切面（Aspect）。但其功能过于简单：只能将切面织入到目标类的所有目标方法中， 无法完成将切面织入到指定目标方法中。 前置通知定义前置通知，需要实现 MethodBeforeAdvice 接口。该接口中有一个方法 before()，会在目标方法执行之前执行。 前置通知的特点： 在目标方法执行之前先执行。 不改变目标方法的执行流程，前置通知代码不能阻止目标方法执行。 不改变目标方法执行的结果。 （1） 定义业务接口与目标类 1234567public interface ISomeService &#123; //主业务方法 void doFirst(); //主业务方法 void doSecond();&#125; 12345678910111213141516//目标类public class SomeServiceImpl implements ISomeService &#123; //目标方法 @Override public void doFirst() &#123; System.out.println("执行doFirst()方法"); &#125; //目标方法 @Override public void doSecond() &#123; System.out.println("执行doSecond()方法"); &#125;&#125; （2） 定义前置通知 123456789101112131415//前置通知public class MyMethodBeforeAdvice implements MethodBeforeAdvice &#123; /** *当前方法在目标方法执行之前执行 *method：目标方法 *args：目标方法的参数列表 *target：目标对象 */ @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("执行前置通知方法"); &#125; &#125; （3） 定义 Spring 配置文件 1234567891011121314&lt;!-- 注册目标对象 --&gt;&lt;bean id="someService" class="com.huang.aop01.SomeServiceImpl"/&gt;&lt;!-- 注册切面：通知 --&gt;&lt;bean id="myAdvice" class="com.huang.aop01.MyMethodBeforeAdvice"/&gt;&lt;!-- 生成代理对象 --&gt;&lt;bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;!-- &lt;property name="targetName" value="someService"/&gt; --&gt; &lt;!-- 指定目标对象 --&gt; &lt;property name="target" ref="someService"/&gt; &lt;!-- 指定切面 --&gt; &lt;property name="interceptorNames" value="myAdvice"/&gt;&lt;/bean&gt; （4） 定义测试类 1234567891011121314public class MyTest &#123; @Test public void test01() &#123; String resource = "com/huang/aop01/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); //serviceProxy为代理对象，而非目标对象 ISomeService service = (ISomeService) ac.getBean("serviceProxy"); service.doFirst(); System.out.println("----------------------"); service.doSecond(); &#125;&#125; （5） 运行结果 使用 Debug 查看后台运行情况，可以看到代理生成使用的是 JDK 代理机制。 后置通知定义后置通知，需要实现接口AfterReturningAdvice。该接口中有一个方法afterReturning()，会在目标方法执行之后执行。后置通知的特点： 在目标方法执行之后执行。 不改变目标方法的执行流程，后置通知代码不能阻止目标方法执行。 不改变目标方法执行的结果。 （1） 修改业务接口与目标类 1String doSecond(); 123456//目标方法@Overridepublic String doSecond() &#123; System.out.println("执行doSecond()方法"); return "abcde";&#125; （2） 定义后置通知 1234567891011121314public class MyAfterReturningAdvice implements AfterReturningAdvice &#123; @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("执行后置通知方法 returnValue= " + returnValue); if (returnValue != null) &#123; returnValue = ((String) returnValue).toUpperCase(); System.out.println("修改过的结果 returnValue=" + returnValue); &#125; &#125;&#125; （3） 修改 Spring 配置文件 12&lt;!-- 注册切面：通知 --&gt; &lt;bean id="myAdvice" class="com.huang.aop02.MyAfterReturningAdvice"/&gt; （4） 修改测试类 1234567891011@Testpublic void test01() &#123; String resource = "com/huang/aop02/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); //serviceProxy为代理对象，而非目标对象 ISomeService service = (ISomeService) ac.getBean("serviceProxy"); service.doFirst(); System.out.println("----------------------"); String result = service.doSecond(); System.out.println(result);&#125; 环绕通知定义环绕通知，需要实现 MethodInterceptor 接口。环绕通知，也叫方法拦截器，可以在目标方法调用之前及之后做处理，可以改变目标方法的返回值，也可以改变程序执行流程。 （1） 定义后置通知 123456789101112131415public class MyMethodInterceptor implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println("执行环绕通知：目标方法执行之前"); Object result = invocation.proceed(); System.out.println("执行环绕通知：目标方法执行之后"); if (result != null) &#123; result = ((String)result).toUpperCase(); &#125; return result; &#125;&#125; （2） 修改 Spring 配置文件 12&lt;!-- 注册切面：通知 --&gt;&lt;bean id="myAdvice" class="com.huang.aop03.MyMethodInterceptor"/&gt; 异常通知定义异常通知，需要实现 ThrowsAdvice 接口。该接口的主要作用是，在目标方法抛出异常后，根据异常的不同做出相应的处理。当该接口处理完异常后，会简单地将异常再次抛出给目标方法。 不过，这个接口较为特殊，从形式上看，该接口中没有必须要实现的方法。但，这个接口却确实有必须要实现的方法 afterThrowing()。这个方法重载了四种形式。由于使用时，一般只使用其中一种，该接口定义为标识接口（没有方法的接口）。 这四种方法中，常用的形式如下： 1public void afterThrowing(自定义的异常类 e) 这里的参数 e 为，与具体业务相关的用户自定义的异常类对象。容器会根据异常类型的不同，自动选择不同的该方法执行。这些方法的执行是在目标方法执行结束后执行的。 （1） 定义异常类的父类 1234567891011public class UserException extends Exception &#123; public UserException() &#123; super(); &#125; public UserException(String message) &#123; super(message); &#125;&#125; （2） 定义两个异常类的子类 12345678910public class UsernameException extends UserException &#123; public UsernameException() &#123; super(); &#125; public UsernameException(String message) &#123; super(message); &#125;&#125; 1234567891011public class PasswordException extends UserException &#123; public PasswordException() &#123; super(); &#125; public PasswordException(String message) &#123; super(message); &#125;&#125; （3） 定义业务接口。要抛出异常父类 123456//主业务借口public interface ISomeService &#123; //目标方法 boolean login(String username,String password) throws UserException;&#125; （4） 定义目标类 12345678910111213141516171819//目标类public class SomeServiceImpl implements ISomeService &#123; @Override public boolean login(String username, String password) throws UserException &#123; if (!"huang".equals(username)) &#123; throw new UsernameException("用户名输错了"); &#125; if (!"111".equals(password)) &#123; throw new PasswordException("密码输错了"); &#125;// double a = 3 / 0; return true; &#125;&#125; （5） 定义异常通知 123456789101112131415161718192021public class MyThrowsAdvice implements ThrowsAdvice &#123; // 当目标方法抛出UsernameException异常时，执行当前方法 public void afterThrowing(UserException ex) &#123; System.out.println("发生用户名异常 ex = " + ex.getMessage()); &#125; // 当目标方法抛出PasswordException异常时，执行当前方法 public void afterThrowing(PasswordException ex) &#123; System.out.println("发生密码异常 ex = " + ex.getMessage()); &#125; // 当目标方法抛出其它异常时，执行当前方法 public void afterThrowing(Exception ex) &#123; System.out.println("发生异常 ex = " + ex.getMessage()); &#125;&#125; （6） 定义测试类 123456789101112public class MyTest &#123; @Test public void test01() throws UserException &#123; String resource = "com/huang/aop05/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); //serviceProxy为代理对象，而非目标对象 ISomeService service = (ISomeService) ac.getBean("serviceProxy"); service.login("huang", "111"); &#125;&#125; 通知的其它用法给目标方法织入多个切面若要给目标方法织入多个切面，则需要在配置代理对象的切面属性时，设定为 array。 123456&lt;property name="interceptorNames"&gt; &lt;array&gt; &lt;value&gt;myBeforeAdvice&lt;/value&gt; &lt;value&gt;myAfterAdvice&lt;/value&gt; &lt;/array&gt;&lt;/property&gt; 无接口的 CGLIB 代理生成若不存在接口，则 ProxyFactoryBean 会自动采用 CGLIB 方式生成动态代理(有接口使用 JDK 的 Proxy 动态代理)。 1234&lt;bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="target" ref="someService"/&gt; &lt;property name="interceptorNames" value="myAdvice"/&gt;&lt;/bean&gt; 查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。 有接口的 CGLIB 代理生成若存在接口，但又需要使用 CGLIB 生成代理对象，此时，只需要在配置文件中增加一个 proxyTargetClass 属性设置，用于指定强制使用 CGLIB 代理机制。 1&lt;property name="proxyTargetClass" value="true"/&gt; 也可指定 optimize（优化）的值为 true，强制使用 CGLIB 代理机制。 1&lt;property name="optimize" value="true"/&gt; 查看后台运行情况，可以看到代理生成使用的是 CGLIB 代理机制。 顾问 Advisor顾问（Advisor）是 Spring 提供的另一种切面。其可以完成更为复杂的切面织入功能。PointcutAdvisor 是顾问的一种， 可以指定具体的切入点。 顾问将通知进行了包装，会根据不同的通知类型，在不同的时间点，将切面织入到不同的切入点。PointcutAdvisor 接口有两个较为常用的实现类： NameMatchMethodPointcutAdvisor 名称匹配方法切入点顾问 RegexpMethodPointcutAdvisor 正则表达式匹配方法切入点顾问 名称匹配方法切入点顾问NameMatchMethodPointcutAdvisor，即名称匹配方法切入点顾问。容器可根据配置文件中指定的方法名来设置切入点。 （1） 修改配置文件 1234567&lt;!-- 指定切入点：这里匹配的对象是简单方法名 --&gt; &lt;!-- 指定doFirst方法为切入点方法 --&gt; &lt;!-- &lt;property name="mappedName" value="doFirst"/&gt; --&gt; &lt;!-- 指定doFirst、doSecond方法为切入点方法 --&gt; &lt;!-- &lt;property name="mappedNames" value="doFirst,doSecond"/&gt; --&gt; &lt;!-- 指定自定义匹配*ir*方法为切入点方法 --&gt; &lt;property name="mappedNames" value="*ir*"/&gt; 正则表达式方法切入点顾问RegexpMethodPointcutAdvisor，即正则表达式方法顾问。容器可根据正则表达式来设置切入点。注意，与正则表达式进行匹配的对象是接口中的方法名，而非目标类（接口的实现类）的方法名。 （1） 修改配置文件 123456&lt;!-- 这里的正则表达式匹配的对象是全限定性方法名 --&gt; &lt;!-- &lt;property name="pattern" value=".*doFirst"/&gt; --&gt; &lt;!-- &lt;property name="patterns" value=".*doFirst,.*doSecond"/&gt; --&gt; &lt;!-- 包含doS的或doT的方法为切入点方法 --&gt; &lt;!-- &lt;property name="pattern" value=".*doFirst|.*doSecond"/&gt; --&gt; &lt;property name="pattern" value=".*S.*"/&gt; 正则表达式常用的运算符有三个，如下表： 运算符 名称 意义 . 点号 表示任意单个字符 + 加号 表示前一个字符出现一次或者多次 * 星号 表示前一个字符出现0次或者多次 自动代理生成器ProxyFactoryBean 代理工具类存在着如下缺点：（1）一个代理对象只能代理一个 Bean，即如果有两个 Bean 同时都要织入同一个切面，这时，不仅要配置这两个 Bean，即两个目标对象，同时还要配置两个代理对象。（2）在客户类中获取 Bean 时，使用的是代理类的 id，而非我们定义的目标对象 Bean 的 id。我们真正想要执行的应该是目标对象。从形式上看，不符合正常的逻辑。 Spring 提供了自动代理生成器，用于解决 ProxyFactoryBean 的问题。常用的自动代理生成器有两个： 默认 advisor 自动代理生成器 Bean 名称自动代理生成器 注意：自动代理生成器均继承自 Bean 后处理器 BeanPostProcessor。容器中所有 Bean 在初始化时均会自动执行 Bean 后处理器中的方法，故其无需 id 属性。所以自动代理生成器的 Bean 也没有 id 属性，客户类直接使用目标对象 bean 的 id。 自动代理生成器，均是继承自 BeanPostProcessor， Bean 后处理器。查看源码： 默认 Advisor 自动代理生成器DefaultAdvisorAutoProxyCreator 代理的生成方式是，将所有的目标对象与 Advisor 自动结合，生成代理对象。无需给生成器做任何的注入配置。注意，只能与 Advisor 配合使用。 12&lt;!-- 注册自动代理生成器 --&gt;&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt; 缺点：（1）不能选择目标对象（2）不能选择切面类型，切面只能是advisor（3）不能选择advisor，所以advisor均将被作为切面织入到目标方法 Bean 名称自动代理生成器BeanNameAutoProxyCreator 的代理生成方式是，根据 bean 的 id，来为符合相应名称的类生成相应代理对象，且切面既可以是顾问 Advisor 又可以是通知 Advice。 12345&lt;!-- 注册自动代理生成器 --&gt;&lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt; &lt;property name="beanNames" value="someService"/&gt; &lt;property name="interceptorNames" value="myAdvisor"/&gt;&lt;/bean&gt; 缺点：1）若存在多个目标对象，就需要使用多次ProxyFactoryBean来创建多个代理对象，这会使配置文件变得臃肿，不便于管理2）用户真正想调用的是目标对象，而真正可以调用的却是代理对象，这不符合正常的逻辑 AspectJ 对 DAO 的实现对于 AOP 这种编程思想，很多框架都进行了实现。 Spring 就是其中之一， 可以完成面向切面编程。 然而， AspectJ 也实现了 AOP 的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发(在 Spring 中使用 AOP 开发时，一般使用 AspectJ 的实现方式)。 AspectJ 简介 AspectJ 是一个面向切面的框架，它扩展了 Java 语言。 AspectJ 定义了 AOP 语法，它有一个专门的编译器用来生成遵守 Java 字节编码规范的 Class 文件。——百度百科《AspectJ》 AspectJ 的通知类型AspectJ 中常用的通知有五种类型： （1）前置通知（2）后置通知（3）环绕通知（4）异常通知（5）最终通知 其中最终通知是指，无论程序执行是否正常，该通知都会执行。类似于 try..catch 中的 finally 代码块。 AspectJ 的切入点表达式AspectJ 除了提供了六种通知外，还定义了专门的表达式用于指定切入点。表达式的原型是： 123456execution ( [modifiers-pattern] 访问权限类型 ret-type-pattern 返回值类型(不可省) [declaring-type-pattern] 全限定性类名 name-pattern(param-pattern) 方法名(参数名) (不可省) [throws-pattern] 抛出异常类型 ) 注意：切入点表达式要匹配的对象就是目标方法的方法名。所以， execution 表达式中明显就是方法的签名。表达式中加[ ]的部分表示可省略部分，各部分间用空格分开。在其中可以使用以下符号： 符 号 意义 * 0至多个任意字符 .. 1. 用在方法参数中，表示任意多个参数。2. 用在包名后，表示当前及其子类 + 1. 用在类名后，表示当前类及其子类。2. 用在接口后，表示当前接口及其实现类 举例： 12//指定所有包下的 serivce 子包下所有类中的 doSome()方法为切入点execution(* *..service.*.doSome()) 12//指定只有一级包下的 serivce 子包下所有类中的 doSome()方法为切入点execution(* *.service.*.doSome()) AspectJ 基于注解的 AOP 实现AspectJ 提供了以注解方式对于 AOP 的实现。 实现步骤（1） 定义业务接口与实现类 12345678910//主业务接口public interface ISomeService &#123; //主业务方法 void doFirst(); //主业务方法 String doSecond(); //主业务方法 void doThird();&#125; 123456789101112131415161718192021222324//目标类public class SomeServiceImpl implements ISomeService &#123; //目标方法 @Override public void doFirst() &#123; System.out.println("执行doFirst()方法"); &#125; //目标方法 @Override public String doSecond() &#123; System.out.println("执行doSecond()方法"); return "abcde"; &#125; //目标方法 @Override public void doThird() &#123; System.out.println("执行doThird()方法"); System.out.println("执行doThird()方法"); &#125;&#125; （2） 定义切面 POJO 类，并添加@Aspect 注解和通知注解 该类为一个 POJO 类，将作为切面出现。其中定义了若干普通方法，将作为不同的通知方法；在定义的 POJO 类上添加@Aspect 注解，指定当前 POJO 类将作为切面。 1234567891011121314@Aspect // 表示当前类为切面public class MyAspectJ &#123; @Before("execution(* *..ISomeService.doFirst(..))") public void myBefore() &#123; System.out.println("执行前置通知方法"); &#125; @Before("execution(* *..ISomeService.doFirst(..))") public void myBefore(JoinPoint jp) &#123; System.out.println("执行前置通知方法 jp = " + jp); &#125;&#125; （3） 定义 Spring 配置文件 12345678&lt;!-- 注册切面 --&gt;&lt;bean id="myAspectJ" class="com.huang.annotation.MyAspectJ"/&gt;&lt;!-- 注册目标对象 --&gt;&lt;bean id="someService" class="com.huang.annotation.SomeServiceImpl"/&gt;&lt;!-- 注册AspectJ的自动代理 --&gt;&lt;aop:aspectj-autoproxy/&gt; （4） 定义测试类 1234567891011121314 @Test public void test01() &#123; String resource = "com/huang/annotation/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); //serviceProxy为代理对象，而非目标对象 ISomeService service = (ISomeService) ac.getBean("someService"); service.doFirst(); System.out.println("----------------------"); service.doSecond(); System.out.println("----------------------"); service.doThird(); &#125;&#125; @Before 前置通知-增强方法有 JoinPoint 参数在目标方法执行之前执行。被注解为前置通知的方法，可以包含一个 JoinPoint 类型参数。该类型的对象本身就是切入点表达式。通过该参数，可获取切入点表达式、方法签名、目标对象等。 12345678910//前置通知@Before("execution(* *..ISomeService.doFirst(..))")public void myBefore() &#123; System.out.println("执行前置通知方法");&#125;@Before("execution(* *..ISomeService.doFirst(..))")public void myBefore(JoinPoint jp) &#123; System.out.println("执行前置通知方法 jp = " + jp);&#125; 运行结果 @AfterReturning 后置通知-注解有 returning 属性在目标方法执行之后执行。由于是目标方法之后执行，所以可以获取到目标方法的返回值。 该注解的 returning 属性就是用于指定接收方法返回值的变量名的。 12345678910//后置通知@AfterReturning("execution(* *..ISomeService.doSecond(..))")public void myAfterReturning() &#123; System.out.println("执行后置通知方法");&#125;@AfterReturning(value="execution(* *..ISomeService.doSecond(..))",returning="result")public void myAfterReturning(Object result) &#123; System.out.println("执行后置通知方法 result = " + result);&#125; 运行结果 注意：被注解为后置通知的方法，除了可以包含 JoinPoint 参数外，还可以包含用于接收返回值的变量。该变量最好为 Object 类型，因为目标方法的返回值可能是任何类型。 @Around 环绕通知-增强方法有 ProceedingJoinPoint 参数在目标方法执行之前之后执行。被注解为环绕增强的方法要有返回值， Object 类型。 并且方法可以包含一个 ProceedingJoinPoint 类型的参数。接口 ProceedingJoinPoint 其有一个 proceed()方法，用于执行目标方法。若目标方法有返回值，则该方法的返回值就是目标方法的返回值。最后，环绕增强方法将其返回值返回。该增强方法实际是拦截了目标方法的执行。 12345678910111213//环绕通知@Around("execution(* *..ISomeService.doSecond(..))")public Object myAround(ProceedingJoinPoint pjp) throws Throwable&#123; System.out.println("执行环绕通知方法，目标方法执行之前"); //执行目标方法 Object result = pjp.proceed(); System.out.println("执行环绕通知方法，目标方法执行之后"); if (result != null) &#123; result = ((String)result).toUpperCase(); &#125; return result;&#125; 运行结果 @AfterThrowing 异常通知-注解中有 throwing 属性在目标方法抛出异常后执行。 该注解的 throwing 属性用于指定所发生的异常类对象。当然，被注解为异常通知的方法可以包含一个参数 Throwable，参数名称为 throwing 指定的名称，表示发生的异常对象。 在目标类定义一个异常 123456//目标方法@Overridepublic void doThird() &#123; System.out.println("执行doThird()方法" + 3 / 0); System.out.println("执行doThird()方法");&#125; 12345678910111213141516//异常通知@AfterThrowing("execution(* *..ISomeService.doThird(..))")public void myAfetrThrowing() &#123; System.out.println("执行异常通知方法");&#125;//使用切入点，叫 doThirdPointcut()@AfterThrowing(value="doThirdPointcut()",throwing="ex")public void myAfterThrowing(Exception ex) &#123; System.out.println("执行异常通知方法 ex = " + ex.getMessage());&#125;// 定义了一个切入点，叫 doThirdPointcut()@Pointcut("execution(* *..ISomeService.doThird(..))")public void doThirdPointcut() &#123;&#125; 运行结果 @After 最终通知无论目标方法是否抛出异常，该增强均会被执行。 12345//最终通知@After("doThirdPointcut()")public void myAfter() &#123; System.out.println("执行最终通知方法");&#125; 运行结果 @Pointcut 定义切入点当较多的通知增强方法使用相同的 execution 切入点表达式时，编写、维护均较为麻烦。AspectJ 提供了@Pointcut 注解，用于定义 execution 切入点表达式。其用法是，将@Pointcut 注解在一个方法之上，以后所有的 executeion 的 value 属性值均可使用该方法名作为切入点。代表的就是@Pointcut 定义的切入点。这个使用@Pointcute 注解的方法一般使用 private 的标识方法，即没有实际作用的方法。 123// 定义了一个切入点，叫 doThirdPointcut()@Pointcut("execution(* *..ISomeService.doThird(..))")public void doThirdPointcut() &#123;&#125; AspectJ 基于 XML 的 AOP 实现AspectJ 除了提供了基于注解的 AOP 的实现外，还提供了以 XML 方式的实现。切面就是一个 POJO 类，而用于增强的方法就是普通的方法。通过配置文件，将切面中的功能增强织入到了目标类的目标方法中。 实现步骤（1） 定义业务接口与实现类 12345678910//主业务接口public interface ISomeService &#123; //主业务方法 void doFirst(); //主业务方法 String doSecond(); //主业务方法 void doThird();&#125; 123456789101112131415161718192021222324//目标类public class SomeServiceImpl implements ISomeService &#123; //目标方法 @Override public void doFirst() &#123; System.out.println("执行doFirst()方法"); &#125; //目标方法 @Override public String doSecond() &#123; System.out.println("执行doSecond()方法"); return "abcde"; &#125; //目标方法 @Override public void doThird() &#123; System.out.println("执行doThird()方法" + 3 / 0); System.out.println("执行doThird()方法"); &#125;&#125; （2） 定义切面 POJO 类 该类为一个 POJO 类，将作为切面出现。其中定义了若干普通方法，将作为不同的通知方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 表示当前类为切面public class MyAspectJ &#123; //前置通知 public void myBefore() &#123; System.out.println("执行前置通知方法"); &#125; // @Before("execution(* *..ISomeService.doFirst(..))") public void myBefore(JoinPoint jp) &#123; System.out.println("执行前置通知方法 jp = " + jp); &#125; //后置通知 public void myAfterReturning() &#123; System.out.println("执行后置通知方法"); &#125; public void myAfterReturning(Object result) &#123; System.out.println("执行后置通知方法 result = " + result); &#125; //环绕通知 public Object myAround(ProceedingJoinPoint pjp) throws Throwable&#123; System.out.println("执行环绕通知方法，目标方法执行之前"); //执行目标方法 Object result = pjp.proceed(); System.out.println("执行环绕通知方法，目标方法执行之后"); if (result != null) &#123; result = ((String)result).toUpperCase(); &#125; return result; &#125; //异常通知 public void myAfetrThrowing() &#123; System.out.println("执行异常通知方法"); &#125; //使用切入点，叫 doThirdPointcut() public void myAfterThrowing(Exception ex) &#123; System.out.println("执行异常通知方法 ex = " + ex.getMessage()); &#125; //最终通知 public void myAfter() &#123; System.out.println("执行最终通知方法"); &#125; &#125; （3） 注册目标对象与 POJO 切面类 12345&lt;!-- 注册切面 --&gt;&lt;bean id="myAspectJ" class="com.huang.xml.MyAspectJ"/&gt;&lt;!-- 注册目标对象 --&gt;&lt;bean id="someService" class="com.huang.xml.SomeServiceImpl"/&gt; （4） 在容器中定义 AOP 配置 12345678910&lt;!-- AOP配置 --&gt; &lt;aop:config&gt; &lt;aop:aspect ref="myAspectJ"&gt; &lt;aop:pointcut expression="execution(* *..ISomeService.doFirst(..))" id="doFirstPointcut"/&gt; &lt;aop:pointcut expression="execution(* *..ISomeService.doSecond(..))" id="doSecondPointcut"/&gt; &lt;aop:pointcut expression="execution(* *..ISomeService.doThird(..))" id="doThirdPointcut"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 通过其子标签&lt;aop:pointcut/&gt;定义切入点，该标签有两个属性， id 与 expression。分别用于指定该切入点的名称及切入点的值。 expression 的值为 execution 表达式。 子标签&lt;aop:aspect/&gt;定义具体的织入规则：根据不同的通知类型，确定不同的织入时间；将 method 指定的增强方法，按照指定织入时间，织入到切入点指定的目标方法中。 &lt;aop:aspect/&gt;的 ref 属性用于指定使用哪个切面。&lt;aop:aspect/&gt;的子标签是各种不同的通知类型。不同的通知所包含的属性是不同的，但也有共同的属性。 method：指定该通知使用的切面中的增强方法。 pointcut-ref：指定该通知要应用的切入点。 AspectJ 的 6 种通知的 XML 标签如下： &lt;aop:before/&gt;：前置通知 lt;aop:after-returning/&gt;： 后置通知 &lt;aop:around/&gt;：环绕通知 &lt;aop:after-throwing/&gt;：异常通知 &lt;aop:after/&gt;：最终通知 &lt;aop:declare-parents/&gt;：引入通知 （5） 定义测试类 123456789101112@Testpublic void test01() &#123; String resource = "com/huang/xml/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); //serviceProxy为代理对象，而非目标对象 ISomeService service = (ISomeService) ac.getBean("someService"); service.doFirst(); System.out.println("----------------------"); service.doSecond(); System.out.println("----------------------"); service.doThird();&#125; &lt;aop:before/&gt;前置通知123&lt;!-- 前置通知 --&gt; &lt;aop:before method="myBefore" pointcut-ref="doFirstPointcut"/&gt; &lt;aop:before method="myBefore(org.aspectj.lang.JoinPoint)" pointcut-ref="doFirstPointcut"/&gt; 运行结果 &lt;aop:after-returning/&gt;后置通知其 XML 的配置中，有一个属性 returning，指定用于接收目标方法的返回值所使用的变量名。其可作为增强方法的参数出现。 123 &lt;!-- 后置通知 --&gt; &lt;aop:after-returning method="myAfterReturning" pointcut-ref="doSecondPointcut"/&gt;&lt;aop:after-returning method="myAfterReturning(java.lang.Object)" pointcut-ref="doSecondPointcut" returning="result"/&gt; 运行结果 &lt;aop:around/&gt;环绕通知环绕通知的增强方法一般返回类型为 Object，是目标方法的返回值。并且可以包含一个参数 ProceedingJoinPoint，其方法 proceed()可执行目标方法。 12&lt;!-- 环绕通知 --&gt;&lt;aop:around method="myAround" pointcut-ref="doSecondPointcut"/&gt; 运行结果 &lt;aop:after-throwing/&gt;异常通知其 XML 的配置中，有一个属性 throwing，指定用于接收目标方法所抛出异常的变量名。其可作为增强方法的参数出现，该参数为 Throwable 类型。 12&lt;!-- 异常通知 --&gt;&lt;aop:after-throwing method="myAfterThrowing(java.lang.Exception)" pointcut-ref="doThirdPointcut" throwing="ex"/&gt; 运行结果 &lt;aop:after/&gt;最终通知12&lt;!-- 最终通知 --&gt;&lt;aop:after method="myAfter" pointcut-ref="doThirdPointcut"/&gt; 运行结果]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring与IoC]]></title>
    <url>%2F2019%2F08%2F06%2FSpring%E4%B8%8EIoC%2F</url>
    <content type="text"><![CDATA[Spring是一个容器，用于降低代码间的耦合度，根据不同的代码(主业务逻辑、系统级服务)采用IoC和AOP两种进行的业务逻辑。 主业务逻辑与系统级业务逻辑的特点：主业务代码间逻辑联系紧密，有具体的专业业务应用场景，复用性相对较低；系统级业务相对功能独立，没有具体的专业业务应用场景，主要是为主业务提供系统级服务，如日志、安全、事务等，复用性强。 降低耦合度的方式分为了两类： IoC 与 AOP。 IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理自动“注入”。而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成“织入”。 Spring 体系结构 Spring 由 20 多个模块组成，它们可以分为数据访问/集成（Data Access/Integration）、Web、面向切面编程（AOP, Aspects）、 应用服务器设备管理（Instrumentation）、消息发送（Messaging）、 核心容器（Core Container）和测试（Test）。 Spring 的特点1. 非侵入式所谓非侵入式是指， Spring 框架的 API 不会在业务逻辑上出现， 即业务逻辑是 POJO(Plain Old Java Object)。由于业务逻辑中没有 Spring 的 API，所以业务逻辑可以从 Spring 框架快速的移植到其他框架，即与环境无关。 2. 容器Spring 作为一个容器，可以管理对象的生命周期、对象与对象之间的依赖关系。可以通过配置文件，来定义对象，以及设置与其他对象的依赖关系。(简单来说是一个xml配置文件) 3. IoC控制反转（IoC，Inversion of Control）， 即创建被调用者的实例不是由调用者完成，而是由 Spring 容器完成，并注入调用者。当应用了 IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。即，不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。 4. AOP面向切面编程（AOP， Aspect Orient Programming），是一种编程思想，是面向对象编程 OOP 的补充。 很多框架都实现了对 AOP 编程思想的实现。 Spring 也提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如日志和事务管理）进行开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或事务支持。 Spring 与 IoC控制反转（IoC， Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。当前比较流行的 IoC 实现方式有两种：依赖注入和依赖查找。 依赖查找： Dependency Lookup， DL，容器提供回调接口和上下文环境给组件，程序代码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。 依赖注入： Dependency Injection， DI，程序代码不做定位查询，这些工作由容器自行完成。 依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。 Spring 程序开发 定义接口与实体类 123public interface ISomeService &#123; void doSome();&#125; 1234567891011public class SomeServiceImpl implements ISomeService &#123; public SomeServiceImpl() &#123; System.out.println("执行无参构造器"); &#125; @Override public void doSome() &#123; System.out.println("执行doSome()方法"); &#125;&#125; 创建 Spring 配置文件 Spring 配置文件的文件名可以随意，但 Spring 建议的名称为 applicationContext.xml。 1&lt;bean id="myService" class="com.huang.service.SomeServiceImpl"/&gt; &lt;bean /&gt;： 用于定义一个实例对象。 一个实例对应一个 bean 元素。 id：该属性是 Bean 实例的唯一标识，程序通过 id 属性访问 Bean， Bean 与 Bean 间的依赖关系也是通过 id 属性关联的。 class：指定该 Bean 所属的类， 定义测试类 （1） ApplicationContext 接口容器ApplicationContext 用于加载 Spring 的配置文件，在程序中充当“容器”的角色。其实现类有两个：ClassPathXmlApplicationContext 和 FileSystemXmlApplicationContext 123456789@Testpublic void test02() &#123; // 创建容器对象，加载Spring配置文件 // 从类路径下查找配置文件 ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); //从容器中获取对象 ISomeService service = (ISomeService) ac.getBean("myService"); service.doSome();&#125; 123456789@Testpublic void test03() &#123; // 创建容器对象，加载Spring配置文件 // 从项目的根下查找配置文件 ApplicationContext ac = new FileSystemXmlApplicationContext("applicationContext.xml"); //从容器中获取对象 ISomeService service = (ISomeService) ac.getBean("myService"); service.doSome();&#125; 123456789@Testpublic void test04() &#123; //创建容器对象，加载Spring配置文件 //从当前文件系统的D盘根目录下查找配置文件 ApplicationContext ac = new FileSystemXmlApplicationContext("d:/applicationContext.xml"); //从容器中获取对象 ISomeService service = (ISomeService) ac.getBean("myService"); service.doSome();&#125; ClassPathXmlApplicationContext 和 FileSystemXmlApplicationContext 的区别 （2） BeanFactory 接口容器 BeanFactory 接口是 ApplicationContext 接口的父类。 123456@Testpublic void test05() &#123; BeanFactory bf = new XmlBeanFactory(new ClassPathResource("applicationContext.xml")); ISomeService service = (ISomeService) bf.getBean("myService"); service.doSome();&#125; Resouce 是一个接口，其具有两个实现类： ClassPathResource：指定类路径下的资源文件 FileSystemResource：指定项目根路径或本地磁盘路径下的资源文件。 注意：ApplicationContext与BeanFactory容器的区别： 这两上容器对于其中Bean的创建时机不同： ApplicationContext容器在进行初始化时，会将其中的所有Bean(对象)进行创建缺点：占用系统资源较多（内存、CPU等）优点：响应速度快 BeanFactory容器中的对象，在容器初始化时并不会被创建，而是在真正获取该对象时才被创建缺点：相对来说，响应速度慢优点：占用系统资源较少 Bean 的装配Bean 的装配，即 Bean 对象的创建。容器根据代码要求创建 Bean 对象后再传递给代码的过程，称为 Bean 的装配。 默认装配方式代码通过 getBean()方式从容器获取指定的 Bean 实例，容器默认调用 Bean 类的无参构造器，创建空值的实例对象。 动态工厂 Bean有些时候，项目中需要通过工厂类来创建 Bean 实例，使用工厂模式创建 Bean 实例，会使工厂类与要创建的 Bean 类耦合到一起。 123456public class ServiceFactory &#123; public ISomeService getSomeService() &#123; return new SomeServiceImpl(); &#125;&#125; 12345&lt;!-- 注册动态工厂 --&gt;&lt;bean id="factory" class="com.huang.ba02.ServiceFactory"/&gt;&lt;!-- 注册Service:动态工厂Bean --&gt;&lt;bean id="myService" factory-bean="factory" factory-method="getSomeService"/&gt; 12345678@Testpublic void test01() &#123; // 创建容器对象，加载Spring配置文件 String resource = "com/huang/ba02/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); ISomeService service = (ISomeService) ac.getBean("myService"); service.doSome();&#125; 静态工厂 Bean静态工厂无需工厂实例，所以不再需要定义静态工厂&lt;bean/&gt;。 而对于工厂所要创建的 Bean，其不是由自己的类创建的，所以无需指定自己的类。但其是由工厂类创建的，所以需要指定所用工厂类。故 class 属性指定的是工厂类而非自己的类。 容器中 Bean 的作用域当通过 Spring 容器创建一个 Bean 实例时，不仅可以完成 Bean 的实例化，还可以通过 scope 属性，为 Bean 指定特定的作用域。 Spring 支持 5 种作用域。 singleton： 单态模式。即在整个 Spring 容器中，使用 singleton 定义的 Bean 将是单例的，只有一个实例。 默认为单态的。 prototype： 原型模式。即每次使用 getBean 方法获取的同一个&lt;bean /&amp;gtl的实例都是一个新的实例。 request：对于每次 HTTP 请求，都将会产生一个不同的 Bean 实例。 session：对于每个不同的 HTTP session，都将产生一个不同的 Bean 实例。 global session：每个全局的 HTTP session 对应一个 Bean 实例。典型情况下，仅在使用 portlet 集群时有效，多个 Web 应用共享一个 session。一般应用中， global-session 与 session是等同的。 注意： 对于 scope 的值 request、 session 与 global session， 只有在 Web 应用中使用 Spring 时，该作用域才有效。 对于 scope 为 singleton 的单例模式， 该 Bean 是在容器被创建时即被装配好了。 对于 scope 为 prototype 的原型模式， Bean 实例是在代码中使用该 Bean 实例时才进行装配的。 Bean 后处理器Bean 后处理器是一种特殊的 Bean，容器中所有的 Bean 在初始化时，均会自动执行该类的两个方法。 123//该方法会在目标 Bean 初始化完毕之前由容器自动调用。public Object postProcessBeforeInitialization(Object bean, String beanId) throws BeansException 1234//该方法会在目标 Bean 初始化完毕之后由容器自动调用。public Object postProcessAfterInitialization(Object bean, String beanId) throws BeansException Bean 初始化完毕有一个标志：一个方法将被执行。即当该方法被执行时，表示该 Bean被初始化完毕。 它们的参数是：第一个参数是系统即将初始化的 Bean 实例，第二个参数是该 Bean 实例的 id 属性值。若 Bean 没有 id 就是 name 属性值。 （1） 定义接口 12345public interface ISomeService &#123; //主业务方法 String doSome(); String doOther();&#125; （2） 定义目标类 12345678910111213141516171819public class SomeServiceImpl implements ISomeService &#123; private int a; //目标方法 @Override public String doSome() &#123; System.out.println("执行doSome()方法"); return "abcde"; &#125; //目标方法 @Override public String doOther() &#123; System.out.println("执行doOther()方法"); return "fghij"; &#125; &#125; （3） 使用动态代理进行增强 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyBeanPostProcessor implements BeanPostProcessor &#123; // bean：表示当前正在进行初始化的Bean对象 // beanName：表示当前正在进行初始化的Bean对象的id @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("执行------before------()方法"); return bean; &#125; @Override public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException &#123; System.out.println("执行------after------()方法"); if ("myService".equals(beanName)) &#123; Object obj = Proxy.newProxyInstance(bean.getClass() .getClassLoader(),bean.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object invoke = method.invoke(bean, args); if ("doSome".equals(method.getName())) &#123; return ((String) invoke).toUpperCase(); &#125; return invoke; &#125; &#125;); return obj; &#125; return bean; &#125;&#125; （4） 创建 Spring 配置文件 1234&lt;!-- 注册Service --&gt; &lt;bean id="myService" class="com.huang.ba05.SomeServiceImpl"/&gt; &lt;bean class="com.huang.ba05.MyBeanPostProcessor"/&gt; （5） 定义测试类 123456789@Testpublic void test01() &#123; // 创建容器对象，加载Spring配置文件 String resource = "com/huang/ba05/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); ISomeService service = (ISomeService) ac.getBean("myService"); System.out.println(service.doSome()); System.out.println(service.doOther());&#125; （6） 运行结果 定制 Bean 的生命始末可以为 Bean 定制初始化后的生命行为，也可以为 Bean 定制销毁前的生命行为。 注意，若要看到 Bean 的 destroy-method 的执行结果，需要满足两个条件：（1） Bean 为 singleton，即单例（2）要确保容器关闭。接口 ApplicationContext 没有 close()方法，但其实现类有。所以，可以将 ApplicationContext 强转为其实现类对象，或直接创建的就是实现类对象。 Bean 的生命周期Step1：调用无参构造器，创建实例对象。Step2：调用参数的 setter，为属性注入值。Step3：若 Bean 实现了 BeanNameAware 接口，则会执行接口方法 setBeanName(String beanId)，使 Bean 类可以获取其在容器中的 id 名称。Step4：若 Bean 实现了 BeanFactoryAware 接口，则执行接口方法 setBeanFactory(BeanFactory factory)，使 Bean 类可以获取到 BeanFactory 对象。Step5：若定义并注册了 Bean 后处理器 BeanPostProcessor，则执行接口方法 postProcessBeforeInitialization()。Step6：若 Bean 实现了 InitializingBean 接口，则执行接口方法 afterPropertiesSet ()。 该方法在 Bean 的所有属性的 set 方法执行完毕后执行，是 Bean 初始化结束的标志，即 Bean 实例化结束。Step7：若设置了 init-method 方法，则执行。Step8：若定义并注册了 Bean 后处理器 BeanPostProcessor ， 则执行接口方法 postProcessAfterInitialization()。Step9：执行业务方法。Step10：若 Bean 实现了 DisposableBean 接口，则执行接口方法 destroy()。Step11：若设置了 destroy-method 方法，则执行。 &lt;bean/&gt;标签的 id 属性与 name一般情况下，命名&lt;bean/&gt;使用 id 属性，而不使用 name 属性。在没有 id 属性的情况下，name 属性与 id 属性作用是相同的。但，当&lt;bean/&gt;中含有一些特殊字符时，就需要使用 name属性了。 命名规范： id：必须以字母开头，可以包含字母、数字、下划线、连字符、句号、冒号。 name：属性值则可以包含各种字符。 基于 XML 的 DI注入分类Bean 实例在调用无参构造器创建了空值对象后，就要对 Bean 对象的属性进行初始化。初始化是由容器自动完成的， 称为注入。根据注入方式的不同， 常用的有两类： 设值注入、构造注入（接口注入几乎不用）。 设值注入设值注入是指，通过 setter 方法传入被调用者的实例(底层通过调用setter方法将值注入)。这种注入方式简单、直观，因而在 Spring 的依赖注入中大量使用。 （1） 定义实体类 1234public class School &#123; private String name;&#125; 123456789public class Student &#123; private String name; private int age; private School school; public void setName(String name) &#123; System.out.println("执行setName()"); this.name = name; &#125;&#125; （2） 创建 Spring 配置文件 1234567891011&lt;!-- 注册School --&gt;&lt;bean id="mySchool" class="com.huang.di01.School"&gt; &lt;property name="name" value="清华大学"/&gt;&lt;/bean&gt;&lt;!-- 注册Student --&gt;&lt;bean id="myStudent" class="com.huang.di01.Student"&gt; &lt;property name="name" value="张三"/&gt; &lt;property name="age" value="22"/&gt; &lt;property name="school" ref="mySchool"/&gt;&lt;/bean&gt; （3） 定义测试类 1234567@Testpublic void test01() &#123; String resource = "com/huang/di01/applicationContext.xml"; ApplicationContext ac = new ClassPathXmlApplicationContext(resource); Student student = (Student) ac.getBean("myStudent"); System.out.println(student);&#125; （4） 运行结果 当指定 bean 的某属性值为另一 bean 的实例时，通过 ref 指定它们间的引用关系。 ref 的值必须为某 bean 的 id 值(域属性(引用类型)的注入需要使用 ref 属性，字符串和基本数据类型使用 value)。对于其它 Bean 对象的引用，除了&lt;bean/&gt;标签的 ref 属性外，还可以使用&lt;ref/&gt;标签。 构造注入构造注入是指，在构造调用者实例的同时，完成被调用者的实例化。即，使用构造器设置依赖关系(底层调用的是构造器)。 （1） 修改实现类 （2） 修改 Spring 配置文件 &lt;constructor-arg /&gt;标签中用于指定参数的属性有： name：指定参数名称。 index：指明该参数对应着构造器的第几个参数，从 0 开始。不过，该属性不要也行，但要注意，若参数类型相同，或之间有包含关系，则需要保证赋值顺序要与构造器中的参数顺序一致。 命名空间注入对于设值注入与构造注入，在配置文件中，除了使用&lt;property/&gt;或&lt;constructor-arg/&gt;标签外，还可使用命名空间注入的方式，让注入的值以&lt;bean/&gt;标签属性的方式出现。根据注入实现方式的不同，分为： p 命名空间注入：采用设值注入方式，故需要有相应的 setterc 命名空间注入：采用构造注入方式，故需要有相应的构造器 p 命名空间设值注入 c 命名空间构造注入 集合属性注入（1） 定义实体类 123456789public class Some &#123; private School[] schools; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String, Object&gt; myMap; private Properties myPros;&#125; （2） 修改 Spring 配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!-- 注册School --&gt;&lt;bean id="mySchool" class="com.huang.di05.School"&gt; &lt;property name="name" value="清华大学"/&gt;&lt;/bean&gt;&lt;bean id="mySchool2" class="com.huang.di05.School"&gt; &lt;property name="name" value="北京大学"/&gt;&lt;/bean&gt;&lt;!-- 注册Student --&gt;&lt;bean id="mySome" class="com.huang.di05.Some"&gt; &lt;property name="schools"&gt; &lt;array&gt; &lt;ref bean="mySchool"/&gt; &lt;ref bean="mySchool2"/&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 为数组注入值 --&gt; &lt;property name="myStrs"&gt; &lt;array&gt; &lt;value&gt;中国&lt;/value&gt; &lt;value&gt;广东&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 为 List 注入值 --&gt; &lt;property name="myList"&gt; &lt;list&gt; &lt;value&gt;广州&lt;/value&gt; &lt;value&gt;天河&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 为 Set 注入值 --&gt; &lt;property name="mySet"&gt; &lt;set&gt; &lt;value&gt;现代学院&lt;/value&gt; &lt;value&gt;信息工程系&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 为 Map 注入值 --&gt; &lt;property name="myMap"&gt; &lt;map&gt; &lt;entry key="mobile" value="1234567"/&gt; &lt;entry key="QQ" value="7654321"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 为 Properties 注入值 --&gt; &lt;property name="myPros"&gt; &lt;props&gt; &lt;prop key="education"&gt;大学&lt;/prop&gt; &lt;prop key="gender"&gt;男&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; Spring 配置文件的简单赋值 对于域属性的自动注入对于域属性的注入，也可不在配置文件中显示的注入。可以通过为&lt;bean/&gt;标签设置 autowire 属性值，为域属性进行隐式自动注入。根据自动注入判断标准的不同，可以分为两种： byName：根据名称自动注入 byType：根据类型自动注入 （1） byName 方式自动注入 当配置文件中被调用者 Bean 的 id 值与代码中调用者 Bean 类的属性名相同时，可使用 byName 方式，让容器自动将被调用者 Bean 注入给调用者 Bean。容器是通过调用者的 Bean 类的属性名与配置文件的被调用者 bean 的 id 进行比较而实现自动注入的。 （2） byType 方式自动注入 使用 byType 方式自动注入，要求：配置文件中被调用者 bean 的 class 属性指定的类，要与代码中调用者 Bean 类的某域属性类型同源。即要么相同，要么有 is-a 关系（子类，或是实现类）。 使用 SPEL 注入SPEL(Spring Expression Language)，即 Spring EL 表达式语言。即，在 Spring 配置文件中为 Bean 的属性注入值时，可直接使用 SPEL 表达式计算的结果。 SPEL 表达式以#开头，后跟一对大括号。 用法： &lt;bean id=“abc” value=“#{…}”/&gt;。 其它用法：（1） &lt;property name=“school” value=“#{mySchool}”/&gt;：引用另一个 bean。指定 school 的值为另一个 Bean 实例 mySchool。（2） &lt;property name=“schoolName” value=“#{mySchool.name.toUpperCase()}”/&gt;：使用指定属性，并使用其方法。指定 schoolName 的值为 mySchool 的 name 属性值，并将其字母均转换为大写字母（toUpperCase()方法）。 使用内部 Bean 注入若不希望代码直接访问某个 bean，即，在代码中通过 getBean 方法获取该 Bean 实例，则可将该 Bean 的定义放入调用者 bean 定义的内部。 使用同类抽象 Bean 注入当若干Bean实例同属于一个类，且这些实例的属性值又有相同值时，可以使用抽象Bean，以简化配置文件。 抽象 Bean 是用于让其它 bean 继承的。这个 bean 在 Bean 类中是不能通过 getBean 方法获取的。设置 abstract 属性为 true 来指明该 bean 为抽象 bean， 默认值为 false。 不过，该 bean 不为抽象 bean 时，也可被继承。 只不过，在应用中，用于被继承的 bean 一般为抽象 bean。 使用异类抽象 Bean 注入当若干不同的类对象具有相同的属性，且其值也相同时，可使用异类抽象 Bean。 为应用指定多个 Spring 配置文件在实际应用里，随着应用规模的增加，系统中 Bean 数量也大量增加，导致配置文件变得非常庞大、臃肿。为了避免这种情况的产生，提高配置文件的可读性与可维护性，可以将 Spring 配置文件分解成多个配置文件。 （1）平等关系的配置文件将配置文件分解为地位平等的多个配置文件，并将所有配置文件的路径定义为一个 String 数组，将其作为容器初始化参数出现。 其将与可变参的容器构造器匹配。 （ 2）包含关系的配置文件各配置文件中有一个总文件，总配置文件将各其它子文件通过&lt;import/&gt;引入。在 Java 代码中只需要使用总配置文件对容器进行初始化即可。 Spring 配置文件中也可使用通配符*。但，此时要求总配置文件不要和子配置文件命名格式相同，否则将出现循环递归包含。 基于注解的 DI (底层使用AOP)对于 DI 使用注解，将不再需要在 Spring 配置文件中声明 Bean 实例。 定义 Bean@Component需要在类上使用注解@Component，该注解的 value 属性用于指定该 bean 的 id 值。 （1） 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041// @Scope("prototype") // 默认也是singleton@Component("myStudent")public class Student &#123; @Value("张三") private String name; @Value("23") private int age; // @Resource(name="mySchool") // byName方式的注解式注入 @Resource // byType方式的注解式注入 private School school; // 对象属性，域属性 public void setName(String name) &#123; System.out.println("执行setName()"); this.name = name; &#125; public void setAge(int age) &#123; System.out.println("执行setAge()"); this.age = age; &#125; public void setSchool(School school) &#123; this.school = school; &#125; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + ", school=" + school + "]"; &#125; @PostConstruct public void initAfter() &#123; System.out.println("当前Bean初始化刚完毕"); &#125; @PreDestroy public void preDestroy() &#123; System.out.println("当前Bean即将被销毁"); &#125; &#125; 1234567891011121314@Component("mySchool") // 组件，表示当前类被Spring容器所管理public class School &#123; @Value("清华大学") private String name; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "School [name=" + name + "]"; &#125;&#125; （2） Spring 配置文件 12345678 &lt;!-- 扫描指定包 --&gt;&lt;context:component-scan base-package="com.huang.di01"/&gt;&lt;!-- 扫描com.huang这个包及其子包 --&gt;&lt;!-- &lt;context:component-scan base-package="com.huang"/&gt; --&gt;&lt;!-- 扫描com.huang这个包的子包 --&gt;&lt;!-- &lt;context:component-scan base-package="com.huang.*"/&gt; --&gt; 注意：要在文件头部加上约束 与@Component注解功能相同，但意义不同的注解还有三个：（1）@Repository：注解在Dao实现类上（2）@Service：注解在Service实现类上（3）@Controller：注解在SpringMVC的处理器上 之所以创建这三个功能与@Component 等效的注解，是为了以后对其进行功能上的扩展，使它们不再等效。 Bean 的作用域@Scope要在类上使用注解@Scope，其 value 属性用于指定作用域。默认为 singleton。 基本类型属性注入@Value需要在属性上使用注解@Value，该注解的 value 属性用于指定要注入的值。 按类型注入域属性@Autowired需要在域属性上使用注解@Autowired，该注解默认使用按类型自动装配 Bean 的方式。 按名称注入域属性@Autowired 与@Qualifier需要在域属性上联合使用注解@Autowired 与@Qualifier。 @Qualifier 的 value 属性用于指定要匹配的 Bean 的 id 值。 注意：使用@Value、@Autowired、@Autowired 与@Qualifier注解完成属性注入时，类中无需 setter。当然，若属性有 setter，则也可将其加到 setter 上。 @Autowired 还有一个属性 required，默认值为 true，表示当匹配失败后，会终止程序运行。若将其值设置为 false，则匹配失败，将被忽略，未匹配的属性值为 null。 域属性注解@Resource@Resource 注解既可以按名称匹配 Bean，也可以按类型匹配 Bean。 使用该注解，要求 JDK 必须是 6 及以上版本。 Bean 的生命始末@PostConstruct 与@PreDestroy在方法上使用@PostConstruct，与原来的 init-method 等效。在方法上使用@PreDestroy，与 destroy-method 等效。 使用 JavaConfig 进行配置JavaConfig，是在 Spring 3.0 开始从一个独立的项目并入到 Spring 中的。 JavaConfig 可以看成一个用于完成 Bean 装配的 Spring 配置文件，即 Spring 容器， 只不过该容器不是 XML 文件，而是由程序员使用 Java 自己编写的 Java 类(表示当前类充当 Spring 容器，即所有的 Bean 将由这个类来创建)。 （1） byType 方式的域属性自动注入 （2） byName 方式的域属性自动注入 使用 Spring 的 JUnit4 测试 Spring使用 Spring 的 JUnit4 对 Spring 代码进行测试，将不再需要在程序的代码中直接写出创建 Spring 容器，以及从 Spring 容器中通过 getBean()获取对象。 （1） 定义 Spring 配置文件 （2）定义测试类 注解与 XML 共同使用注解的好处是，配置方便，直观。但其弊端也显而易见：以硬编码的方式写入到了 Java 代码中，其修改是需要重新编译代码的。 XML 配置方式的最大好处是，对其所做修改，无需编译代码，只需重启服务器即可将新的配置加载。 若注解与 XML 同用， XML 的优先级要高于注解。这样做的好处是，需要对某个 Bean 做修改，只需修改配置文件即可。当然，此时， Bean 类要有 setter 或构造器。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis注解式开发]]></title>
    <url>%2F2019%2F08%2F04%2FMyBatis%E6%B3%A8%E8%A7%A3%E5%BC%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[注解的基础知识MyBatis 的注解，主要是用于替换映射文件。而映射文件中无非存放着增、删、改、查的 SQL 映射标签。所以， MyBatis 注解，就是要替换映射文件中的 SQL 标签。 MyBatis 官方文档中指出，若要真正想发挥 MyBatis 功能，还是要用映射文件。即 MyBatis 官方并不建议通过注解方式来使用 MyBatis。 注解的基础语法 注解后是没有分号的。 注解首字母是大写的，因为注解与类、接口是同一级别的。一个注解，后台对应着。一个@interface 类。 在同一语法单元上，同一注解只能使用一次。 在注解与语法单元之间可以隔若干空行、注释等非代码内容。 注解的注解 打开@Deprecated 源码，看到其定义上还有三个注解： @Documented、 @Retention、 @Target。这三个注解的意义是： @Target： 用于指定该注解可以标注的语法类型。 CONSTRUCTOR（构造器）、LOCAL_VARIABLE（局部变量）、 METHOD（方法）、 FIELD（属性）、 PACKAGE（包）、 PARAMETER（参数）、 TYPE（类型）。 注意：对于 TYPE 常量，其意义有两个：一是指该注解可以用在类、接口、枚举等类上；二是指该注解可以作为其它注解的属性值，例如@Result、 @InterceptorRef。 @Documented： 用于指定该注解定义时的注释信息能否显示在 javaAPI 说明文档上。 没有添加的话，使用 javadoc 生成 API 文档时就不会该注解的信息添加到文档。 @RetentionPolicy： 这是一个 enum 类型， 共有三个值：SOURCE,CLASS 和 RUNTIME。 SOURCE： 代表这个 Annotation 类型的信息只会保留在程序源码里，源码如果经过了编译之后， Annotation 的数据就会消失， 并不会保留在编译好的.class 文件中。 ClASS： 代表这个 Annotation 类型的信息除了保留在程序源码里外， 同时也会保留在编译好的.class 文件里。但在执行时，并不会把这一些信息加载到虚拟机(JVM)中去。这是Retention 的默认值。 RUNTIME： 表示在源码、编译好的.class 文件中保留信息， 同时在执行时还会把这些信息加载到 JVM 中。 举例：@Override 中的 Retention 值为 SOURCE， 编译成功了就不要这一些检查的信息。相反@Deprecated 中 Retention 的值为 RUNTIME， 表示除了在编译时会警告我们使用了哪个被 Deprecated 的方法， 在执行的时候也可以查出该方法是否被 Deprecated。 注解的属性 数组问题该属性在源码定义时被声明为数组，但在具体使用时却只要赋予一个值，此时无需将该值再定义为一个数组后赋给该属性。直接将该值赋给该属性即可。例如，对于声明为字符串数组 String[]的 value 属性，可以将字符串 String 直接赋给该 value。 默认值问题若某属性在注解定义时声明了其默认值，则在注解使用时，可以不为其指定属性值。注解会自动使用其默认值。 value 属性问题若注解在使用时只需使用其 value 属性，其它属性要么有默认值，要么该注解只声明了一个 value 属性，此时，在注解使用时 value 属性名称可省略，而直接在注解的括号中写出该 value 属性的值。 在注解里面，对于数组，如果数组只有一个元素，{}可以省略不写；注解里面只用到一个属性，value可以省略不写 无属性问题有些注解在定义时，是没有属性的，如@Deprecated、 @Overide 都是没有属性声明的，那么在使用时只需给出注解名称即可。 MyBatis注解@Insert其 value 属性用于指定要执行的 insert 语句。 @SelectKey用于替换 XML 中的&lt;selectKey/&gt;标签，用于返回新插入数据的 id 值 1@SelectKey(statement="select @@identity", resultType=int.class, keyProperty="id", before=false) statement：获取新插入记录主键值的 SQL 语句 keyProperty：获取的该主键值返回后初始化对象的哪个属性 resultType：返回值类型 before：指定主键的生成相对于 insert 语句的执行先后顺序，该属性不能省略 @Delete其 value 属性用于指定要执行的 delete 语句。 @Update其 value 属性用于指定要执行的 update 语句。 @Select其 value 属性用于指定要执行的 select 语句。 总结 由于 MyBatis 注解替换的是映射文件，所以可以删除映射文件。 由于没有了映射文件，所以主配置文件中不能使用&lt;mapper/&gt;注册 mapper 的位置了。需要使用&lt;package/&gt;标签。 1234&lt;!-- 指定映射mapper --&gt;&lt;mappers&gt; &lt;package name="com.huang.dao"/&gt;&lt;/mappers&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis查询缓存]]></title>
    <url>%2F2019%2F08%2F03%2FMyBatis%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[查询缓存的使用，主要是为了提高查询访问速度。将用户对同一数据的重复查询过程简化，不再每次均从数据库查询获取结果数据，从而提高访问速度。 MyBatis 的查询缓存机制，根据缓存区的作用域（生命周期） 可划分为两种： 一级查询缓存与二级查询缓存。 一级查询缓存MyBatis 一级查询缓存是基于 org.apache.ibatis.cache.impl.PerpetualCache 类的 HashMap本地缓存，其作用域是 SqlSession。在同一个 SqlSession 中两次执行相同的 sql 查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。 当一个 SqlSession 结束后，该 SqlSession 中的一级查询缓存也就不存在了。 myBatis 默认一级查询缓存是开启状态，且不能关闭。 一级查询缓存的存在性证明（1） 测试类 123456789// 证明一级缓存是存在的@Testpublic void test01() &#123; Student student = dao.selectStudentById(4); System.out.println(student); Student student2 = dao.selectStudentById(4); System.out.println(student2);&#125; （2） 查看控制台 总结： 缓存的底层实现是一个Map，Map的value是查询结果 Map的key，即查询依据，使用的ORM构架不同，查询依据是不同的。 MyBatis的查询依据是：Sql的id + SQL语句 Hibernate的查询依据是：查询结果对象的id 从缓存读取数据的依据是 Sql 的 id一级缓存缓存的是相同 Sql 映射 id 的查询结果，而非相同 Sql 语句的查询结果。 因为 myBatis 内部对于查询缓存，无论是一级查询缓存还是二级查询缓存， 其底层均使用一个 HashMap 实现： key 为 Sql 的 id 相关内容， value 为从数据库中查询出的结果。 （1） 映射文件 这两个 SQL 映射除了映射 id (selectStudentById、selectStudentById2)不同，其它均相同，即查询结果肯定是相同的。 1234567891011&lt;select id="selectStudentById" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;xxx&#125;&lt;/select&gt;&lt;select id="selectStudentById2" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;xxx&#125;&lt;/select&gt; （2） Dao 接口 12345public interface IStudentDao &#123; Student selectStudentById(int id); Student selectStudentById2(int id);&#125; （3） 测试类 1234567public void test02() &#123; Student student = dao.selectStudentById(1); System.out.println(student); Student student2 = dao.selectStudentById2(1); System.out.println(student2);&#125; （4） 查看控制台 增删改对一级查询缓存的影响增、删、改操作，无论是否进行提交 sqlSession.commit()，均会清空一级查询缓存，使查询再次从 DB 中 select。 （1） 修改测试类 123456789101112131415 // 证明增删改操作的执行，均会清空一级缓存 @Test public void test03() &#123; //第一次查询 Student student = dao.selectStudentById(2); System.out.println(student); // 增删改操作都会清空一级缓存，无论是否提交 dao.insertStudent(new Student("赵六", 26, 96.5));// sqlSession.commit(); //第二次查询 Student student2 = dao.selectStudentById(2); System.out.println(student2); &#125; （2） 查看控制台 内置二级查询缓存myBatis 查询缓存的作用域是根据映射文件 mapper 的 namespace 划分的，相同 namespace 的 mapper 查询数据存放在同一个缓存区域。 不同 namespace 下的数据互不干扰。无论是一级缓存还是二级缓存，都是按照 namespace 进行分别存放的。但一、二级缓存的不同之处在于， SqlSession 一旦关闭，则 SqlSession 中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与 SqlSession 是否关闭无关。 使用二级缓存的目的，不是共享数据，因为 MyBatis 从缓存中读取数据的依据是 SQL 的 id，而非查询出的对象。所以， 二级缓存中的数据不是为了在多个查询之间共享（所有查询中只要查询结果中存在该对象的，就直接从缓存中读取，这是对数据的共享， Hibernate 中的缓存就是为了共享，但 MyBaits 的不是），而是为了延长该查询结果的保存时间，提高系统性能。 myBatis 内置的二级缓存为 org.apache.ibatis.cache.impl.PerpetualCache。 二级缓存用法（1）实体序列化 要求查询结果所涉及到的实体类要实现 java.io.Serializable 接口。若该实体类存在父类，或其具有域属性，则父类与域属性类也要实现序列化接口。 1234567public class Student implements Serializable&#123; private Integer id; private String name; private int age; private double score;&#125; （2）mapper 映射中添加&lt;cache/&gt;标签 12345678910111213141516 &lt;!-- 二级缓存的配置 --&gt;&lt;cache eviction="FIFO" flushInterval="10800000" readOnly="true" size="512"/&gt;&lt;insert id="insertStudent" flushCache="false"&gt; insert into student(name,age,score) values(#&#123;name&#125;, #&#123;age&#125;, #&#123;score&#125;)&lt;/insert&gt;&lt;!-- useCache="false"对当前Sql的二级缓存的局部关闭 --&gt;&lt;select id="selectStudentById" useCache="false" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;xxx&#125;&lt;/select&gt;&lt;select id="selectStudentById2" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;xxx&#125;&lt;/select&gt; （3）二级缓存的配置 为&lt;cache/&gt;标签添加一些相关属性设置，可以对二级缓存的运行性能进行控制。若不指定设置，则均保持默认值。 12&lt;cache eviction="FIFO" flushInterval="10800000" readOnly="true" size="512"/&gt; 二级缓存的配置说明： eviction：逐出策略。当二级缓存中的对象达到最大值时，就需要通过逐出策略将缓存中的对象移出缓存。默认为 LRU。常用的策略有： FIFO： First In First Out， 先进先出 LRU： Least Recently Used，未被使用时间最长的 flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存。 readOnly：设置缓存中数据是否只读。 只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，这提供了很重要的性能优势。但读写的缓存会返回缓存对象的拷贝。这会慢一些，但是安全，因此默认是 false。 size：二级缓存中可以存放的最多对象个数。默认为 1024 个。 二级缓存的关闭二级缓存默认为开启状态。 若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。 （1） 全局关闭 所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。全局开关设置在主配置文件的全局设置&lt;settings/&gt;中，该属性为 cacheEnabled，设置为 false，则关闭；设置为 true，则开启， 默认值为 true。 即二级缓存默认是开启的。 1234&lt;!-- 关闭二级缓存 --&gt;&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; （2） 局部关闭 所谓局部关闭是指，整个应用的二级缓存是开启的，但只是针对于某&lt;select/&gt;查询，不使用二级缓存。此时可以单独只关闭该&lt;select/&gt;标签的二级缓存。 在该要关闭二级缓存的&lt;select/&gt;标签中，将其属性 useCache 设置为 false，即可关闭该查询的二级缓存。 该属性默认为 true，即每个&lt;select/&gt;查询的二级缓存默认是开启的。 1234&lt;!-- useCache="false"对当前Sql的二级缓存的局部关闭 --&gt;&lt;select id="selectStudentById" useCache="false" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;xxx&#125;&lt;/select&gt; 二级缓存的使用原则1. 只能在一个命名空间下使用二级缓存由于二级缓存中的数据是基于 namespace 的，即不同 namespace 中的数据互不干扰。在多个 namespace 中若均存在对同一个表的操作，那么这多个 namespace 中的数据可能就会出现不一致现象。 2. 在单表上使用二级缓存如果一个表与其它表有关联关系，那么就非常有可能存在多个 namespace 对同一数据的操作。而不同 namespace 中的数据互不干扰，所以有可能出现这多个 namespace 中的数据不一致现象。 3. 查询多于修改时使用二级缓存在查询操作远远多于增删改操作的情况下可以使用二级缓存。因为任何增删改操作都将刷新二级缓存，对二级缓存的频繁刷新将降低系统性能。 ehcache二级查询缓存mybatis 的特长是 SQL 操作，缓存数据管理不是其特长，为了提高缓存的性能， myBatis 允许使用第三方缓存产品。 ehCache 就是其中的一种。 项目： cache-secondLevel-ehcache。 注意：使用 ehcache 二级缓存，实体类无需实现序列化接口。 ehcache二级查询缓存配置说明&lt;diskStore/&gt;标签12&lt;!-- 指定一个文件目录，当内存空间不够，需要将二级缓存中数据写到硬盘上时，会写到这个指定目录中。其值一般为 java.io.tmpdir， 表示当前系统的默认文件临时目录。 --&gt; &lt;diskStore path="java.io.tmpdir"/&gt; &lt;defaultCache/&gt;标签12345678910&lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" maxElementsOnDisk="10000000" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;persistence strategy="localTempSwap"/&gt;&lt;/defaultCache&gt; 设定缓存的默认属性数据： maxElementsInMemory： 指定该内存缓存区可以存放缓存对象的最多个数。 eternal： 设定缓存对象是否不会过期。若设为 true，表示对象永远不会过期，此时会忽略 timeToIdleSeconds 与 timeToLiveSeconds 属性。默认值为 false。 timeToIdleSeconds： 设定允许对象处于空闲状态的最长时间，以秒为单位。当对象自从最近一次被访问后，若处于空闲状态的时间超过了 timeToIdleSeconds 设定的值，这个对象就会过期。当对象过期， EHCache 就会将它从缓存中清除。 设置值为 0，则对象可以无限期地处于空闲状态。 timeToLiveSeconds： 设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存后，若处于缓存中的时间超过了 timeToLiveSeconds 设定的值，这个对象就会过期。当对象过期， EHCache 就会将它从缓存中清除。 设置值为 0，则对象可以无限期地存在于缓存中。 注意，只有 timeToLiveSeconds≥ timeToIdleSeconds，才有意义。 overflowToDisk： 设定为 true，表示当缓存对象达到了 maxElementsInMemory 界限，会将溢出的对象写到元素指定的硬盘目录缓存中。 maxElementsOnDisk： 指定硬盘缓存区可以存放缓存对象的最多个数。 diskPersistent： 指定当程序结束时，硬盘缓存区中的缓存对象是否做持久化。 diskExpiryThreadIntervalSeconds： 指定硬盘中缓存对象的失效时间间隔。 memoryStoreEvictionPolicy： 如果内存缓存区超过限制， 选择移向硬盘缓存区中的对象时使用的策略。 支持三种策略： FIFO： First In First Out， 先进先出 LFU： Less Frequently Used， 最少使用 LRU： Least Recently Used， 最近最少使用 启用 ehcache 缓存机制在映射文件的 mapper 中的&lt;cache/&gt;中通过 type 指定缓存机制为 Ehcache 缓存。默认为 myBatis 内置的二级缓存 org.apache.ibatis.cache.impl.PerpetualCache。 123&lt;cache type="org.mybatis.caches.ehcache.EhcacheCache"&gt; &lt;property name="timeToIdleSeconds" value="60"/&gt;&lt;/cache&gt; 注意：&lt;cache&gt;属性值的优先级高于 ehcache.xml 中的属性值。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis关联关系查询]]></title>
    <url>%2F2019%2F08%2F03%2FMyBatis%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[关联查询当查询内容涉及到具有关联关系的多个表时， 就需要使用关联查询。根据表与表间的关联关系的不同，关联查询分为四种： （1）一对一关联查询（2）一对多关联查询（3）多对一关联查询（4）多对多关联查询 由于日常工作中最常见的关联关系是一对多、多对一与多对多，所以这里就不专门只讲解一对一关联查询了，其解决方案与多对一解决方案是相同的。 一对多关联查询项目： one2many 这里的一对多关联查询是指，在查询一方对象的时候，同时将其所关联的多方对象也都查询出来。 下面以国家 Country 与部长 Minister 间的一对多关系进行演示。 （1） 定义实体 在定义实体时， 若定义的是双向关联，即双方的属性中均有对方对象作为域属性出现，那么它们在定义各自的 toString()方法时需要注意，只让某一方可以输出另一方即可，不要让双方的 toString()方法均可输出对方。这样会形成递归调用，程序出错。 1234567public class Country &#123; private Integer cid; private String cname; //关联属性 private Set&lt;Minister&gt; ministers;&#125; 12345public class Minister &#123; private Integer mid; private String mname;&#125; （2） 定义数据库表 （3） 定义 Dao 层接口 1234public interface ICountryDao &#123; Country selectCountryById(int cid);&#125; （4） 定义工具类 12345678910111213141516public class MyBatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; public static SqlSession getSqlSession() &#123; try &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); if (sqlSessionFactory == null) &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; return sqlSessionFactory.openSession(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; （5） 定义映射文件 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.huang.dao.ICountryDao"&gt; &lt;resultMap type="Country" id="countryMapper"&gt; &lt;id column="cid" property="cid"/&gt; &lt;result column="cname" property="cname"/&gt; &lt;!-- 关联属性的映射关系 --&gt; &lt;collection property="ministers" ofType="Minister"&gt; &lt;id column="mid" property="mid"/&gt; &lt;result column="mname" property="mname"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 多表连接查询 --&gt; &lt;select id="selectCountryById" resultMap="countryMapper"&gt; select cid,cname,mid,mname from country,minister where countryId=cid and cid=#&#123;xxx&#125; &lt;/select&gt; &lt;/mapper&gt; （6） 定义主配置文件 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 注册DB连接四要素属性文件 --&gt; &lt;properties resource="jdbc.properties" /&gt; &lt;!-- 定义类型别名 --&gt; &lt;typeAliases&gt; &lt;!-- 将指定包中所有类的简单类名当作其别名 --&gt; &lt;package name="com.huang.beans" /&gt; &lt;/typeAliases&gt; &lt;!-- 配置运行环境 --&gt; &lt;environments default="testEM"&gt; &lt;environment id="testEM"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.user&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 注册映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="com/huang/dao/mapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; （7） 定义测试类 12345678910111213141516171819202122232425public class MyTest &#123; private ICountryDao dao; private SqlSession sqlSession; @Before public void before() &#123; sqlSession = MyBatisUtils.getSqlSession(); dao = sqlSession.getMapper(ICountryDao.class); &#125; @After public void after() &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; @Test public void test01() &#123; Country country = dao.selectCountryById(2); System.out.println(country); &#125; &#125; （8） 运行结果 在映射文件中使用&lt;collection/&gt;标签体现出两个实体对象间的关联关系。 其两个属性的意义为： property： 指定关联属性， 即 Country 类中的集合属性 ofType：集合属性的泛型类型 多表单独查询方式多表连接查询方式是将多张表进行连接，连为一张表后进行查询。其查询的本质是一张表。 关联属性&lt;collection/&gt;的数据来自于另一个查询&lt;selectMinisterByCountry/&gt;。而该查询&lt;selectMinisterByCountry/&gt;的动态参数 countryId=#{ooo}的值来自于查询&lt;selectCountryById/&gt;的查询结果字段 cid。 多对一关联查询项目： many2one(基于one2many) 这里的多对一关联查询是指，在查询多方对象的时候，同时将其所关联的一方对象也查询出来。 由于在查询多方对象时也是一个一个查询，所以多对一关联查询，其实就是一对一关联查询。即一对一关联查询的实现方式与多对一的实现方式是相同的。 下面以部长 Minister 与国家 Country 间的多对一关系进行演示。 1. 多表连接查询方式（1） 修改实体 12345public class Country &#123; private Integer cid; private String cname;&#125; 1234567public class Minister &#123; private Integer mid; private String mname;// 关联属性 private Country country;&#125; （2） 修改数据库 （3） 修改 Dao 层接口 123public interface IMinisterDao &#123; Minister selectMinisterById(int mid);&#125; （4） 修改映射文件 1234567891011121314&lt;resultMap type="Minister" id="ministerMapper"&gt; &lt;id column="mid" property="mid"/&gt; &lt;result column="mname" property="mname"/&gt; &lt;association property="country" javaType="Country"&gt; &lt;id column="cid" property="cid"/&gt; &lt;result column="cname" property="cname"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id="selectMinisterById" resultMap="ministerMapper"&gt; select mid,mname,cid,cname from minister, country where countryId=cid and mid=#&#123;xxx&#125;&lt;/select&gt; （5） 修改测试类 12345678910111213141516171819202122232425public class MyTest &#123; private IMinisterDao dao; private SqlSession sqlSession; @Before public void before() &#123; sqlSession = MyBatisUtils.getSqlSession(); dao = sqlSession.getMapper(IMinisterDao.class); &#125; @After public void after() &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; @Test public void test01() &#123; Minister minister = dao.selectMinisterById(2); System.out.println(minister); &#125; &#125; （6） 运行结果 2. 多表单独查询方式（1） 修改映射文件 （2） 运行结果 自关联查询所谓自关联是指，自己即充当一方，又充当多方，是 1:n 或 n:1 的变型。例如，对于新闻栏目 NewsColumn，可以充当一方，即父栏目，也可以充当多方，即子栏目。而反映到 DB 表中，只有一张表，这张表中具有一个外键，用于表示该栏目的父栏目。一级栏目没有父栏目，所以可以将其外键值设为 0，而子栏目则具有外键值。 为了便于理解，将自关联分为两种情况来讲解。一种是当作 1:n 讲解，即当前类作为一方，其包含多方的集合域属性。一种是当作 n:1 讲解，即当前类作为多方，其包含一方的域属性。下面以新闻栏目为例: 1. 以一对多方式处理以一对多方式处理，即一方可以看到多方。 该处理方式的应用场景比较多，例如在页面上点击父栏目，显示出其子栏目。再如，将鼠标定位在窗口中的某菜单项上会显示其所有子菜单项等。 A. 查询指定栏目的所有子孙栏目 根据指定的 id，仅查询出其所有子栏目。当然，包括其所有辈份的孙子栏目。 即，给出的查询 id 实际为父栏目 id。 （1） 自关联的 DB 表 （2） 定义实体类 1234567// 新闻栏目：当前的新闻栏目被看作是一方，即父栏目public class NewsLabel &#123; private Integer id; private String name; // 栏目名称 private Set&lt;NewsLabel&gt; children;&#125; （3） 定义 Dao 接口 123public interface INewsLabelDao &#123; List&lt;NewsLabel&gt; selectChildrenByParent(int pid);&#125; （4） 定义 mapper 映射 12345678910111213141516171819202122&lt;mapper namespace="com.huang.dao.INewsLabelDao"&gt; &lt;!-- &lt;select id="" resultMap="newslabelMapper"&gt; select id,name from newslabel where pid=#&#123;ooo&#125; &lt;/select&gt; --&gt; &lt;resultMap type="NewsLabel" id="newslabelMapper"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;collection property="children" ofType="NewsLabel" select="selectChildrenByParent" column="id"/&gt; &lt;/resultMap&gt; &lt;select id="selectChildrenByParent" resultMap="newslabelMapper"&gt; select id,name from newslabel where pid=#&#123;xxx&#125; &lt;/select&gt; &lt;/mapper&gt; （5） 定义测试类 123456789101112131415161718192021222324252627public class MyTest &#123; private INewsLabelDao dao; private SqlSession sqlSession; @Before public void before() &#123; sqlSession = MyBatisUtils.getSqlSession(); dao = sqlSession.getMapper(INewsLabelDao.class); &#125; @After public void after() &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; @Test public void test01() &#123; List&lt;NewsLabel&gt; children = dao.selectChildrenByParent(3); for (NewsLabel newsLabel : children) &#123; System.out.println(newsLabel); &#125; &#125; &#125; （6） 运行结果 B. 查询指定栏目及其所有子孙栏目 这里的查询结果，即要包含指定 id 的当前栏目，还包含其所有辈份的孙子栏目。 即给出的 id 实际为当前要查询的栏目的 id。 （1） 修改 Dao 接口 123public interface INewsLabelDao &#123; NewsLabel selectNewsLabelById(int id);&#125; （2） 修改 mapper 映射 12345678910111213141516171819202122&lt;select id="selectNewslabelByParent" resultMap="newslabelMapper"&gt; select id,name from newslabel where pid=#&#123;ooo&#125; &lt;/select&gt; &lt;resultMap type="NewsLabel" id="newslabelMapper"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;collection property="children" ofType="NewsLabel" select="selectNewslabelByParent" column="id"/&gt; &lt;/resultMap&gt; &lt;select id="selectNewsLabelById" resultMap="newslabelMapper"&gt; select id,name from newslabel where id=#&#123;xxx&#125; &lt;/select&gt; &lt;/mapper&gt; （3） 修改测试类 123456@Testpublic void test01() &#123; NewsLabel newsLabel = dao.selectNewsLabelById(3); System.out.println(newsLabel); &#125; （4）运行结果 注意 A 和 B 查询的区别 2. 以多对一方式处理以多对一方式处理，即多方可以看到一方。 该处理方式的应用场景，例如在网页上显示当前页面的站内位置。 （1） 定义实体类 1234567// 新闻栏目：当前的新闻栏目被看作是一方，即父栏目public class NewsLabel &#123; private Integer id; private String name; // 栏目名称 private NewsLabel parent; //父栏目&#125; （2） 定义 Dao 接口 123public interface INewsLabelDao &#123; NewsLabel selectNewsLabelById(int id);&#125; （3） 定义 mapper 映射 1234567891011121314&lt;resultMap type="NewsLabel" id="newslabelMapper"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;collection property="parent" javaType="NewsLabel" select="selectNewsLabelById" column="pid"/&gt;&lt;/resultMap&gt;&lt;select id="selectNewsLabelById" resultMap="newslabelMapper"&gt; select id,name,pid from newslabel where id=#&#123;xxx&#125;&lt;/select&gt; （4） 定义测试类 123456@Testpublic void test01() &#123; NewsLabel newsLabel = dao.selectNewsLabelById(9); System.out.println(newsLabel); &#125; （5） 运行结果 多对多关联查询什么是多对多关联关系？一个学生可以选多门课程，而一门课程可以由多个学生选。这就是典型的多对多关系关系。所以，所谓多对多关系，其实是由两个互反的一对多关系组成。一般情况下，多对多关系都会通过一个中间表来建立， 例如选课表。 项目： many2many （1） 定义实体 123456public class Student &#123; private Integer sid; private String sname; private Set&lt;Course&gt; courses;&#125; 123456public class Course &#123; private Integer cid; private String cname; private Set&lt;Student&gt; students;&#125; （2） 定义数据库表 （3） 定义 Dao 层接口 123public interface IStudentDao &#123; Student selectStudentById(int sid);&#125; （4） 定义工具类 12345678910111213141516public class MyBatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; public static SqlSession getSqlSession() &#123; try &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); if (sqlSessionFactory == null) &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; return sqlSessionFactory.openSession(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; （5） 定义 mapper 映射 123456789101112131415161718&lt;resultMap type="Student" id="studentMapper"&gt; &lt;id column="sid" property="sid"/&gt; &lt;result column="sname" property="sname"/&gt; &lt;collection property="courses" ofType="Course"&gt; &lt;id column="cid" property="cid"/&gt; &lt;result column="cname" property="cname"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;select id="selectStudentById" resultMap="studentMapper"&gt; select sid,sname,cid,cname from student,middle,course where sid=studentId and cid=courseId and sid=#&#123;xxx&#125;&lt;/select&gt; （5） 定义测试类 123456@Testpublic void test01() &#123; Student student = dao.selectStudentById(1); System.out.println(student); &#125; （6） 运行结果 延迟加载MyBatis 中的延迟加载，也称为懒加载，是指在进行关联查询时， 按照设置延迟规则推迟对关联对象的 select 查询。 延迟加载可以有效的减少数据库压力。 注意：MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。 关联对象加载时机MyBatis 根据对关联对象查询的 select 语句的执行时机，分为三种类型：直接加载、侵入式延迟加载与深度延迟加载。 直接加载： 执行完对主加载对象的 select 语句，马上执行对关联对象的 select 查询。 侵入式延迟： 执行对主加载对象的查时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的 select 查询。 即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。 深度延迟： 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的 select 查询。只有当真正访问关联对象的详情时，才会执行对关联对象的 select 查询。 注意:延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的 select 语句，不能是使用多表连接所进行的 select 查询。 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。 MyBatis 中对于延迟加载设置，可以应用到一对一、一对多、多对一、多对多的所有关联关系查询中。下面以一对多关联关系查询为例： 直接加载在主配置文件的&lt;properties/&gt;与&lt;typeAliases/&gt;标签之间，添 &lt;settings/&gt;标签，用于完成全局参数设置。（可参考 MyBatis 官方文档） 12345&lt;!-- 设置整个应用所使用的常量 --&gt;&lt;settings&gt; &lt;!-- 延迟加载的总开关 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;/settings&gt; 标签的书写位置，是由约束文件进行规定好的，不能随便写 深度延迟加载修改主配置文件的&lt;settings/&gt;，将延迟加载开关 lazyLoadingEnabled 开启（置为 true），将侵入式延迟加载开关 aggressiveLazyLoading 关闭（置为 false）。 1234567&lt;!-- 设置整个应用所使用的常量 --&gt;&lt;settings&gt; &lt;!-- 延迟加载的总开关 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 侵入式延迟加载开关 --&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt; 侵入式延迟加载修改主配置文件的&lt;settings/&gt;，将延迟加载开关 lazyLoadingEnabled 开启（置为 true），将侵入式延迟加载开关 aggressiveLazyLoading 也开启（置为 true，默认为 true）。 1234567&lt;!-- 设置整个应用所使用的常量 --&gt;&lt;settings&gt; &lt;!-- 延迟加载的总开关 --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 侵入式延迟加载开关 --&gt; &lt;setting name="aggressiveLazyLoading" value="true"/&gt;&lt;/settings&gt; 注意：侵入式延迟加载需要在延迟加载开关 lazyLoadingEnabled开启时才会起作用。若 lazyLoadingEnabled 为 false，则 aggressiveLazyLoading 无论取何值，均不起作用。 延迟加载策略总结 加载策略 lazyLoadingEnabled取值 aggressiveLazyLoading取值 直接加载 false false 深度延迟加载 true false 侵入式延迟加载 true true]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis单表的CURD操作]]></title>
    <url>%2F2019%2F08%2F02%2FMyBatis%E5%8D%95%E8%A1%A8%E7%9A%84CURD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[CURD 操作，即指对数据库中实体对象的增 Create、改 Update、查 Read、删 Delete 操作。 自定义 Dao 接口实现类搭建测试环境项目： curd （1）定义实体类 12345public class Student &#123; private Integer id; private String name; private int age; private double score; （2）定义 Dao 接口 12345678910111213141516public interface IStudentDao &#123; void insertStudent(Student student); void insertStudentCacheId(Student student); void deleteStudentById(int id); void updateStudent(Student student); List&lt;Student&gt; selectAllStudents(); Map&lt;String, Student&gt; selectStudentMap(); Student selectStudentById(int id); Student selectStudentById(Map&lt;String, Object&gt; map); List&lt;Student&gt; selectStudentsByName(String name);&#125; （3）定义 Dao 实现类 123456789101112131415161718192021public class StudentDaoImpl implements IStudentDao &#123; private SqlSession sqlSession; @Override public void insertStudent(Student student) &#123; try &#123; //使用工具类获取SqlSession对象 sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.insert("insertStudent",student); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) sqlSession.close(); &#125; &#125; （4）创建工具类 1234567891011121314151617public class MyBatisUtil &#123; private static SqlSessionFactory sqlSessionFactory; public static SqlSession getSqlSession() &#123; try &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); if (sqlSessionFactory == null) &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; return sqlSessionFactory.openSession(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; （5）定义测试类 123456789public class MyTest &#123; private StudentDaoImpl dao; @Before public void setUp() &#123; dao= new StudentDaoImpl(); &#125;&#125; （6）数据库设计如下 单纯插入数据（1）修改映射文件 123456&lt;insert id="insertStudent"parameterType="com.huang.beans.Student"&gt; insert into student(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;, #&#123;score&#125;)&lt;/insert&gt; id：该 SQL 语句的唯一标识， Java 代码中要使用该标识 #{ }：对指定参数类型属性值的引用。其底层是通过反射机制，调用 Student 类相关属性的 get 方法来获取值的。因为底层使用的是反射，所以这里使用的是类的属性名，而非表的字段名。 （2）修改 Dao 实现类 使用 SqlSession 对象的 insert()方法。该方法默认返回 DB 中受影响条数。其方法原型为：insert(String id, Object obj)。 1234567891011121314151617@Override public void insertStudent(Student student) &#123; try &#123; //使用工具类获取SqlSession对象 sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.insert("insertStudent",student); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; 注意：执行完对 DB 的修改操作，必须要做 SqlSession 的提交。否则，修改将无法同步到 DB 中。因为使用无参的 openSession()方法已经将事务的自动提交功能给关闭了。 （3）修改测试类 12345678@Test public void test01() &#123; for (int i = 1; i &lt; 10; i++) &#123; Student student = new Student("n_" + i, 15 + i,85.5 + i); dao.insertStudent(student); &#125; &#125; （4）运行结果 插入后用新 id 初始化被插入对象（1）修改映射文件映射文件的标签中，有一个子标签用于获取新插入记录的主键值。 123456789&lt;insert id="insertStudentCacheId"parameterType="com.huang.beans.Student"&gt; insert into student(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;, #&#123;score&#125;) &lt;selectKey resultType="int" keyProperty="id" order="AFTER"&gt; select @@identity &lt;/selectKey&gt;&lt;/insert&gt; resultType：指出获取的主键的类型。 keyProperty：指出主键在 Java 类中对应的属性名。此处会将获取的主键值直接封装到被插入的 Student 对象中，即 dao 中 insert()方法的第二个参数对象中。 order：指出 id 的生成相对于 insert 语句的执行是在前还是在后。 MySql 数据库表中的 id，均是先执行 insert 语句，而后生成 id， 所以需要设置为 AFTER； Oracle 数据库表中的 id，则是在 insert 执行之前先生成，所以需要设置为 BEFORE。 当前的 MyBatis 版本，不指定 order 属性，则会根据所用 DBMS，自动选择其值。 （2）修改 Dao 实现类 12345678910111213141516@Override public void insertStudentCacheId(Student student) &#123; try &#123; //使用工具类获取SqlSession对象 sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.insert("insertStudentCacheId",student); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; （3）修改测试类 12345678@Test public void test02()&#123; Student student = new Student("张三", 28, 93.5); System.out.println("插入前student = " + student); dao.insertStudentCatchId(student); System.out.println("插入后student = " + student); &#125; （4）运行结果 删除数据（1）修改映射文件 123&lt;delete id="deleteStudentById"&gt; delete from student where id=#&#123;xxx&#125;&lt;/delete&gt; 注意：这里的动态参数 id 所赋值为#{xxx}。这个#{xxx}表示这就是个占位符，代表 delete()方法的第二个参数。 #{ }中可以放任意值，无需要与 delete()方法的第二个参数值相同。 （2）修改 Dao 实现类 123456789101112131415161718@Override public void deleteStudentById(int id) &#123; try &#123; //使用工具类获取SqlSession对象 sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.delete("deleteStudentById",id); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; （3）修改测试类 1234@Test public void test03() &#123; dao.deleteStudentById(5); &#125; 修改数据（1）修改映射文件 12345&lt;update id="updateStudent"&gt; update student set name=#&#123;name&#125;, age=#&#123;age&#125;, score=#&#123;score&#125; where id=#&#123;id&#125;&lt;/update&gt; 注意：这里的#{ }中，必须要填写 update()方法所传第二个参数 student 对象的属性名称，不能随意填写。 （2）修改 Dao 实现类 123456789101112131415161718@Override public void updateStudent(Student student) &#123; try &#123; //使用工具类获取SqlSession对象 sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.delete("updateStudent",student); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125; （3）修改测试类 1234567@Testpublic void test04() &#123; Student student = new Student("张小三", 18, 99.5); student.setId(1); dao.updateStudent(student);&#125; 查询所有对象-返回 List（1）修改映射文件 123&lt;select id="selectAllStudents" resultType="Student"&gt; select id,name,age,score from student&lt;/select&gt; 注意：resultType 属性并非指查询结果集最后的类型，而是每查出 DB 中的一条记录，将该记录封装成为的对象的类型。 （2）注册类的别名 123 &lt;!-- 将指定包中所有类的简单类名当作其别名 ,type：全限定性类名,alias：别名--&gt; &lt;package name="com.huang.beans"/&gt;&lt;/typeAliases&gt; （3）修改 Dao 实现类 完成 Dao 实现类的 selectAllStudent()方法。 使用 SqlSession 的 selectList()方法完成查询操作。 该方法会将查询出的每条记录封装为指定类型对象后，再将最后的结果集封装为 List 返回。 方法原型为： List selectList (String statement)。 statement：映射文件中配置的 SQL 语句的 id。 1234567891011121314@Override public List&lt;Student&gt; selectAllStudents() &#123; List&lt;Student&gt; students = null; try &#123; sqlSession = MyBatisUtils.getSqlSession(); students = sqlSession.selectList("selectAllStudents"); //sqlSession.commit(); &#125; finally &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return students; &#125; 说明：在写查询时，由于不是对 DB 中数据进行修改，所以无需进行 SqlSession 的提交。但最终 SqlSession 对象还是需要关闭的。 （4）修改测试类 12345678//查询所有：返回List@Testpublic void test05() &#123; List&lt;Student&gt; students = dao.selectAllStudents(); for (Student student : students) &#123; System.out.println(student); &#125;&#125; （5）运行结果 查询所有对象-返回 Map（1）修改 Dao 实现类 完成 Dao 实现类的 selectStudentMap()方法。 使用 SqlSession 的 selectMap()方法完成查询操作。 该查询方法会将查询出的每条记录先封装为指定对象，然后再将该对象作为 value，将该对象的指定属性所对应的字段名作为 key 封装为一个 Map 对象。 方法原型为： Map&lt;Object,Object&gt; selectMap (String statement, String mapKey)。 statement：映射文件中配置的 SQL 语句的 id。 mapKey：查询出的 Map 所要使用的 key。这个 key 为数据表的字段名。查询出的结果是一个 Map，每行记录将会对应一个 Map.entry 对象，该对象的 key 为指定字段的值， value为记录数据所封装的对象。 12345678910111213@Override public Map&lt;String, Object&gt; selectAllStudentsMap() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); try &#123; sqlSession = MyBatisUtils.getSqlSession(); map = sqlSession.selectMap("selectAllStudents", "name"); &#125; finally &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return map; &#125; （2）修改测试类 12345@Testpublic void test06() &#123; Map&lt;String, Object&gt; map = dao.selectAllStudentsMap(); System.out.println(map.get("张三"));&#125; （3）运行结果 说明：若指定的作为 key 的属性值在 DB 中并不唯一，则后面的记录值会覆盖掉前面的值。即指定 key 的 value 值，一定是 DB 中该同名属性的最后一条记录值。 查询单个对象（1）修改映射文件 1234&lt;!-- 符号jjj表示占位符 --&gt;&lt;select id="selectStudentById" resultType="Student"&gt; select id,name,age,score from student where id=#&#123;jjj&#125;&lt;/select&gt; （2）修改 Dao 实现类 使用 SqlSession 的 selectOne()方法。其会将查询的结果记录封装为一个指定类型的对象。方法原型为： Object selectOne (String statement, Object parameter) statement：映射文件中配置的 SQL 语句的 id parameter：查询条件中动态参数的值 12345678910111213@Overridepublic Student selectStudentById(int id) &#123; Student student = null; try &#123; sqlSession = MyBatisUtils.getSqlSession(); student = sqlSession.selectOne("selectStudentById", id); &#125; finally &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return student;&#125; （3）修改测试类 12345@Testpublic void test07() &#123; Student student = dao.selectStudentById(22); System.out.println(student);&#125; 模糊查询（1）修改映射文件 123&lt;select id="selectStudentsByName" resultType="Student"&gt; select id,name,age,score from student where name like '%' #&#123;xxx&#125; '%'&lt;/select&gt; 注意：在进行模糊查询时， 需要进行字符串的拼接。 SQL 中的字符串的拼接使用的是函数 concat(arg1,arg2,…)。注意不能使用 Java 中的字符串连接符+。 （2）修改 Dao 实现类 12345678910111213@Overridepublic List&lt;Student&gt; selectStudentsByName(String name) &#123; List&lt;Student&gt; students = null; try &#123; sqlSession = MyBatisUtils.getSqlSession(); students = sqlSession.selectList("selectStudentsByName", name); &#125; finally &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return students;&#125; （3）修改测试类 1234567@Testpublic void test08() &#123; List&lt;Student&gt; students = dao.selectStudentsByName("张"); for (Student student : students) &#123; System.out.println(student); &#125;&#125; （4）运行结果 $与#的区别 理论区别$与#的区别是很大的。 #为占位符，而$为字符串拼接符。字符串拼接是将参数值以硬编码的方式直接拼接到了 SQL 语句中。字符串拼接就会引发两个问题： SQL 注入问题与没有使用预编译所导致的执行效率低下问题。 执行区别 应用场景 一般情况下，动态参数的值是由用户输入的，则不能使用拼接符$，因为有可能会出现 SQL 注入；若动态参数的值是由系统计算生成的，则可以使用拼接符$。 但这样虽然不存在 SQL 注入的风险，但仍存在执行效率问题。 根据 Map 进行查询mapper 中 SQL 语句的动态参数也可以是 Map 的 key。 （1）修改映射文件 123&lt;select id="selectStudentByMap" resultType="Student"&gt; select * from student where id=#&#123;studentId&#125;&lt;/select&gt; （2）修改 Dao 实现类 123456789101112131415@Overridepublic Student selectStudentByMap(Map&lt;String, Object&gt; map) &#123; Student student = null; try &#123; sqlSession = MyBatisUtils.getSqlSession(); student = sqlSession.selectOne("selectStudentByMap"); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return student;&#125; （3）修改测试类 123456789101112@Testpublic void test09() &#123; Student student = new Student(); student.setId(6); Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("studentId", 10); map.put("student", student); student = dao.selectStudentByMap(map); System.out.println(student);&#125; 属性名与查询字段名不相同resultType 可以将查询结果直接映射为实体 Bean 对象的条件是， SQL 查询的字段名与实体 Bean 的属性名一致。 因为在将查询结果转换为指定类型对象时，系统自动将查询结果字段名称作为对象的属性名， 通过反射机制完成对象的创建。当 SQL 查询结果的字段名和实体 Bean 的属性名不一致时， 将无法创建出需要类型的对象。 搭建测试环境 基于 curd 项目作修改 （1）修改 student 表 （2）修改 Dao 接口 123public interface IStudentDao &#123; Student selectStudentById(int id);&#125; （3）定义 Dao 实现类 1234567891011121314151617181920public class StudentDaoImpl implements IStudentDao &#123; private SqlSession sqlSession; @Override public Student selectStudentById(int id) &#123; Student student = null; try &#123; sqlSession = MyBatisUtils.getSqlSession(); student = sqlSession.selectOne("selectStudentById", id); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; return student; &#125;&#125; （4）修改测试类 123456789101112131415public class MyTest &#123; private IStudentDao dao; @Before public void before() &#123; dao = new StudentDaoImpl(); &#125; @Test public void test01() &#123; Student student = dao.selectStudentById(1); System.out.println(student); &#125;&#125; 查询字段使用别名虽然属性名称与表中字段名称不一致，但可以为查询结果的字段名称赋予别名，让别名与实体 Bean 的属性名相同。这样框架也可以根据查询结果利用反射机制将对象创建。 在映射文件 mapper 中添加如下映射。 123&lt;select id="selectStudentById" resultType="Student"&gt; select tid id,tname name,tage age,score from student where tid=#&#123;xxx&#125;&lt;/select&gt; 运行结果如下： 使用结果映射 resultMap可以使用结果映射 resultMap（这里的 Map 是映射 mapper 的意思） 来建立映射关系，完成由字段到属性的映射，达到将查询结果封装为对象的目的。 resultMap 是对 resultType的增强。 修改映射文件 mapper.xml。 12345678910 &lt;resultMap type="Student" id="studentMapper"&gt; &lt;id column="tid" property="id"/&gt; &lt;result column="tname" property="name"/&gt; &lt;result column="tage" property="age"/&gt; &lt;/resultMap&gt;&lt;select id="selectStudentById" resultMap="studentMapper"&gt; select tid,tname,tage,score from student where tid=#&#123;xxx&#125;&lt;/select&gt; 运行结果如下： Mapper 动态代理在前面例子中自定义 Dao 接口实现类时发现一个问题： Dao 的实现类其实并没有干什么实质性的工作，它仅仅就是通过 SqlSession 的相关 API 定位到映射文件 mapper 中相应 id 的 SQL 语句，真正对 DB 进行操作的工作其实是由框架通过 mapper 中的 SQL 完成的。 所以， MyBatis 框架就抛开了 Dao 的实现类，直接定位到映射文件 mapper 中的相应 SQL语句，对 DB 进行操作。这种对 Dao 的实现方式称为 Mapper 的动态代理方式。Mapper 动态代理方式无需程序员实现 Dao 接口。接口是由 MyBatis 结合映射文件自动生成的动态代理实现的。 项目： dynamicMapper（基于 curd 项目修改） 映射文件的 namespace 属性值一般情况下，一个 Dao 接口的实现类方法使用的是同一个 SQL 映射文件中的 SQL 映射 id。 所以， MyBatis 框架要求，将映射文件中标签的 namespace 属性设为 Dao 接口的全类名，则系统会根据方法所属 Dao 接口，自动到相应 namespace 的映射文件中查找相关的 SQL 映射。 简单来说，通过接口名即可定位到映射文件 mapper。 1&lt;mapper namespace="com.huang.dao.IStudentDao"&gt; 修改日志输出控制文件mapper 的 namespace 修改了，则需要将日志输出控制文件中 logger 的输出对象进行修改。 12##define a loggerlog4j.logger.com.huang.dao.IStudentDao=trace,console Dao 接口方法名MyBatis 框架要求， 接口中的方法名，与映射文件中相应的 SQL 标签的 id 值相同。 系统会自动根据方法名到相应的映射文件中查找同名的 SQL 映射 id。简单来说，通过方法名就可定位到映射文件 mapper 中相应的 SQL 语句。 1234567891011public interface IStudentDao &#123; void insertStudent(Student student); void deleteStudentById(int id); void updateStudent(Student student); List&lt;Student&gt; selectAllStudents(); Student selectStudentById(int id); List&lt;Student&gt; selectStudentsByName(String name);&#125; 删除 Dao 实现类由于通过调用 Dao 接口的方法，不仅可以从 SQL 映射文件中找到所要执行 SQL 语句，还可通过方法参数及返回值，将 SQL 语句的动态参数传入，将查询结果返回。所以， Dao 的实现工作，完全可以由 MyBatis 系统自动根据映射文件完成。 修改测试类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyTest &#123; private IStudentDao dao; private SqlSession session; @Before public void setUp() &#123; session = MyBatisUtils.getSqlSession(); dao = session.getMapper(IStudentDao.class); &#125; @After public void tearDown() &#123; if (session != null) &#123; session.close(); &#125; &#125; @Test public void test01() &#123; Student student = new Student("张三", 23, 93.5); System.out.println("插入前：student = " + student); dao.insertStudent(student); System.out.println("插入后：student = " + student); //添加SqlSession的提交方法 session.commit(); &#125; /*@Test public void test02() &#123; Student student = new Student("张三", 23, 93.5); System.out.println("插入前：student = " + student); dao.insertStudentCacheId(student); System.out.println("插入后：student = " + student); &#125;*/ @Test public void test03() &#123; dao.deleteStudentById(22); //添加SqlSession的提交方法 session.commit(); &#125; @Test public void test04() &#123; Student student = new Student("张大三", 23, 93.5); student.setId(8); dao.updateStudent(student); //添加SqlSession的提交方法 session.commit(); &#125; 多查询条件无法整体接收问题的解决在实际工作中，表单中所给出的查询条件有时是无法将其封装为一个对象的，也就是说，查询方法只能携带多个参数，而不能携带将这多个参数进行封装的一个对象。对于这个问题，有两种解决方案。 1. 将这多个参数封装为一个 Map（1）修改 Dao 接口 123public interface IStudentDao &#123; List&lt;Student&gt; selectStudentsByCondition(Map&lt;String, Object&gt; map);&#125; （2）修改映射文件 1234567&lt;select id="selectStudentsByCondition" resultType="Student"&gt; select id,name,age,score from student where name like '%' #&#123;nameCon&#125; '%' and age &gt; #&#123;ageCon&#125; and score &gt; #&#123;scoreCon&#125; &lt;/select&gt; （3）修改测试类 1234567891011121314151617//根据吗map查询@Testpublic void test01() &#123; Student stu = new Student("王小五", 20, 96.5); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("nameCon", "王"); map.put("ageCon", 23); map.put("stu", stu); List&lt;Student&gt; students = dao.selectStudentsByCondition(map); for (Student student : students) &#123; System.out.println(student); &#125;&#125; 2. 多个参数逐个接收对于 mapper 中的 SQL 语句，可以通过参数索引#{index}的方式逐个接收每个参数。 （1）修改 Dao 接口 123public interface IStudentDao &#123; List&lt;Student&gt; selectStudentsByCondition(String name, int age);&#125; （2）修改映射文件 123456&lt;select id="selectStudentsByCondition" resultType="Student"&gt; select id,name,age,score from student where name like '%' #&#123;0&#125; '%' and age &gt; #&#123;1&#125; &lt;/select&gt; （3）修改测试类 12345678@Testpublic void test01() &#123; List&lt;Student&gt; students = dao.selectStudentsByCondition("张", 23); for (Student student : students) &#123; System.out.println(student); &#125;&#125; 问题：#{}中可以放什么内容？1）参数对象的属性2）随意内容，此时的#{}是个占位符3）参数为map时的key4）参数为map时，若key所对应的value为对象，则可将该对象的属性放入5）参数的索引号 动态SQL动态 SQL，主要用于解决查询条件不确定的情况：在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，执行的 SQL 语句不同。若将每种可能的情况均逐一列出，对所有条件进行排列组合，将会出现大量的 SQL 语句。此时，可使用动态 SQL 来解决这样的问题。 动态 SQL，即通过 MyBatis 提供的各种标签对条件作出判断以实现动态拼接 SQL 语句。这里的条件判断使用的表达式为 OGNL 表达式。 常用的动态 SQL 标签有&lt;if/&gt;、 &lt;where/&gt;、&lt;choose/&gt;、&lt;foreach/&gt;等。 MyBatis 的动态 SQL 语句，与 JSTL 中的语句非常相似。 项目： dynamicSql 搭建测试环境（1） 定义数据库表 {$ asset_img curd12.jpg $} （2） 定义实体 1234567public class Student &#123; private Integer id; private String name; private int age; private double score;&#125; （3） 创建工具类 12345678910111213141516public class MyBatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; public static SqlSession getSqlSession() &#123; try &#123; InputStream is = Resources.getResourceAsStream("mybatis.xml"); if (sqlSessionFactory == null) &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); &#125; return sqlSessionFactory.openSession(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; （4）定义测试类 定义@Before 与@After 方法 12345678910111213141516171819public class MyTest &#123; private IStudentDao dao; private SqlSession sqlSession; @Before public void setUp() &#123; sqlSession = MyBatisUtils.getSqlSession(); dao = sqlSession.getMapper(IStudentDao.class); &#125; @After public void tearDown() &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 注意：在 mapper 的动态 SQL 中若出现大于号（&gt;）、小于号（&lt;）、大于等于号（&gt;=），小于等于号（&lt;=）等符号，最好将其转换为实体符号。否则， XML 可能会出现解析出错问题。特别是对于小于号（&lt;），在 XML 中是绝对不能出现的。否则，一定出错。 &lt;if/&gt;标签对于该标签的执行，当 test 的值为 true 时，会将其包含的 SQL 片断拼接到其所在的 SQL语句中。这引发的问题是，查询条件不确定，查询条件依赖于用户提交的内容。此时，就可使用动态 SQL 语句，根据用户提交内容对将要执行的 SQL 进行拼接。 （1）定义 Dao 接口 1234public interface IStudentDao &#123; List&lt;Student&gt; selectStudentsByIf(Student student); &#125; （2）定义映射文件 为了解决两个条件均未做设定的情况，在 where 后添加了一个“1=1”的条件。这样就不至于两个条件均未设定而出现只剩下一个 where，而没有任何可拼接的条件的不完整 SQL语句。 123456789101112 &lt;!-- if标签 --&gt;&lt;select id="selectStudentsByIf" resultType="Student"&gt; select id,name,age,score from student where 1 = 1 &lt;if test="name != null and name != ''"&gt; and name like '%' #&#123;name&#125; '%' &lt;/if&gt; &lt;if test="age &gt; 0"&gt; and age &gt; #&#123;age&#125; &lt;/if&gt;&lt;/select&gt; （3）修改测试类 1234567891011 @Test public void test01() &#123; Student stu = new Student("张", 18, 0);// Student stu = new Student("", 23, 0);// Student stu = new Student("", 0, 0); List&lt;Student&gt; students = dao.selectStudentsByIf(stu); for (Student student : students) &#123; System.out.println(student); &#125; &#125; （4）运行结果 &lt;where/&gt;标签&lt;if/&gt;标签的中存在一个比较麻烦的地方：需要在 where 后手工添加 1=1 的子句。因为，若 where 后的所有&lt;if/&gt;条件均为 false，而 where 后若又没有 1=1 子句，则 SQL 中就会只剩下一个空的 where， SQL 出错。所以，在 where 后，需要添加永为真子句 1=1，以防止这种情况的发生。但当数据量很大时，会严重影响查询效率。 （1）修改 Dao 接口 1List&lt;Student&gt; selectStudentsByWhere(Student student); （2）定义映射文件 12345678910111213&lt;!-- where标签 --&gt;&lt;select id="selectStudentsByWhere" resultType="Student"&gt; select id,name,age,score from student &lt;where&gt; &lt;if test="name != null and name != ''"&gt; and name like '%' #&#123;name&#125; '%' &lt;/if&gt; &lt;if test="age &gt; 0"&gt; and age &gt; #&#123;age&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; （3）修改测试类 1234567891011 @Test public void test02() &#123; Student stu = new Student("张", 18, 0);// Student stu = new Student("", 23, 0);// Student stu = new Student("", 0, 0); List&lt;Student&gt; students = dao.selectStudentsByWhere(stu); for (Student student : students) &#123; System.out.println(student); &#125; &#125; （4）运行结果 &lt;choose/&gt;标签该标签中只可以包含&lt;when/&gt;&lt;otherwise/&gt;，可以包含多个与一个&lt;otherwise/&gt;。它们联合使用，完成 Java 中的开关语句 switch..case 功能。 （1）修改 Dao 接口 1List&lt;Student&gt; selectStudentsByChoose(Student student); （2）定义映射文件 123456789101112131415161718&lt;!-- choose标签 --&gt;&lt;select id="selectStudentsByChoose" resultType="Student"&gt; select id,name,age,score from student &lt;where&gt; &lt;choose&gt; &lt;when test="name != null and name !=''"&gt; and name like '%' #&#123;name&#125; '%' &lt;/when&gt; &lt;when test="age &gt; 0"&gt; and age &gt; #&#123;age&#125; &lt;/when&gt; &lt;otherwise&gt; 1 = 2 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; （3）修改测试类 1234567891011 @Test public void test03() &#123;// Student stu = new Student("张", 18, 0); Student stu = new Student("", 23, 0);// Student stu = new Student("", 0, 0); List&lt;Student&gt; students = dao.selectStudentsByChoose(stu); for (Student student : students) &#123; System.out.println(student); &#125; &#125; &lt;foreach/&gt;标签&lt;foreach/&gt;标签用于实现对于数组与集合的遍历。对其使用，需要注意： collection 表示要遍历的集合类型，这里是数组，即 array。 open、 close、 separator 为对遍历内容的 SQL 拼接。 （1）修改 Dao 接口 123List&lt;Student&gt; selectStudentsByForeach(int[] ids);List&lt;Student&gt; selectStudentsByForeach2(List&lt;Integer&gt; ids);List&lt;Student&gt; selectStudentsByForeach3(List&lt;Student&gt; ids); （2）定义映射文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- foreach标签 ，遍历数组--&gt;&lt;select id="selectStudentsByForeach" resultType="Student"&gt; &lt;!-- select id,name,age,score from student where id in (1,3,5) --&gt; select id,name,age,score from student &lt;if test="array.length &gt; 0"&gt; where id in &lt;foreach collection="array" item="myid" open="(" close=")" separator=","&gt; #&#123;myid&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/select&gt;&lt;!-- foreach标签 ，遍历泛型为基本类型的 List--&gt;&lt;select id="selectStudentsByForeach2" resultType="Student"&gt; &lt;!-- select id,name,age,score from student where id in (1,3,5) --&gt; select id,name,age,score from student &lt;if test="list.size &gt; 0"&gt; where id in &lt;foreach collection="list" item="myid" open="(" close=")" separator=","&gt; #&#123;myid&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/select&gt;&lt;!-- foreach标签遍历泛型为自定义类型的 List --&gt;&lt;select id="selectStudentsByForeach3" resultType="Student"&gt; &lt;!-- select id,name,age,score from student where id in (1,3,5) --&gt; select id,name,age,score from student &lt;if test="list.size &gt; 0"&gt; where id in &lt;foreach collection="list" item="stu" open="(" close=")" separator=","&gt; #&#123;stu.id&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/select&gt; （3）修改测试类 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void test04() &#123; int[] ids = &#123;1, 3, 4&#125;; List&lt;Student&gt; students = dao.selectStudentsByForeach(ids); for (Student student : students) &#123; System.out.println(student); &#125;&#125;@Testpublic void test05() &#123; List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); ids.add(1); ids.add(3); List&lt;Student&gt; students = dao.selectStudentsByForeach2(ids); for (Student student : students) &#123; System.out.println(student); &#125;&#125;@Testpublic void test06() &#123; Student stu1 = new Student(); stu1.setId(1); Student stu2 = new Student(); stu2.setId(3); List&lt;Student&gt; stus = new ArrayList&lt;&gt;(); stus.add(stu1); stus.add(stu2); List&lt;Student&gt; students = dao.selectStudentsByForeach3(stus); for (Student student : students) &#123; System.out.println(student); &#125;&#125; &lt;sql/&gt;标签&lt;sql/&gt; 标签用于定义 SQL 片断，以便其它 SQL 标签复用。而其它标签使用该 SQL 片断，需要使用 &lt;include/&gt; 子标签。 该 &lt;sql/&gt; 标签可以定义 SQL 语句中的任何部分，所以 &lt;include/&gt; 子标签可以放在动态 SQL 的任何位置。 （1）修改 Dao 接口 1List&lt;Student&gt; selectStudentsBySqlFragment(List&lt;Student&gt; ids); （2）定义映射文件 12345678910111213141516&lt;!-- sql标签 --&gt;&lt;select id="selectStudentsBySqlFragment" resultType="Student"&gt; &lt;!-- select id,name,age,score from student where id in (1,3,5) --&gt; select &lt;include refid="selectColumns"/&gt; from student &lt;if test="list.size &gt; 0"&gt; where id in &lt;foreach collection="list" item="stu" open="(" close=")" separator=","&gt; #&#123;stu.id&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/select&gt;&lt;sql id="selectColumns"&gt; id,name,age,score &lt;/sql&gt; （3）修改测试类 12345678910111213141516@Testpublic void test07() &#123; Student stu1 = new Student(); stu1.setId(1); Student stu2 = new Student(); stu2.setId(3); List&lt;Student&gt; stus = new ArrayList&lt;&gt;(); stus.add(stu1); stus.add(stu2); List&lt;Student&gt; students = dao.selectStudentsBySqlFragment(stus); for (Student student : students) &#123; System.out.println(student); &#125;&#125; （4）运行结果]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis入门]]></title>
    <url>%2F2019%2F07%2F31%2FMyBatis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[框架 框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；另一种定义认为，框架是可被应用开发者定制的应用骨架。可以说，一个框架是一个可复用的设计构件，它规定了应用的体系结构，阐明了整个设计、协作构件之间的依赖关系、责任分配和控制流程，表现为一组抽象类以及其实例之间协作的方法，它为构件复用提供上下文(Context)关系。——百度百科 对于程序员来说，框架是一套资源，这套资源中会包含 Jar 包、文档，还有些会包含源码、代码示例等。这套资源从相关的官网上可以下载。一般是以压缩文件的形式出现。 Mybatis 概述 MyBatis 本是 apache 的一个开源项目 iBatis， 2010 年这个项目由 apache 迁移到了 google，并更名为 MyBatis。 2013 年迁移到 Github。——百度百科《MyBatis》 Mybatis 简介MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注SQL 语句本身，而不用再花费精力去处理诸如注册驱动、创建 Connection、 配置 Statement等繁杂过程。 Mybatis通过xml或注解的方式将要执行的各种statement （statement、preparedStatement等）配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的SQL 语句，最后由 MyBatis 框架执行 SQL 并将结果映射成 Java 对象并返回。 Mybatis 与 HibernateHibernate 框架是提供了全面的数据库封装机制的“全自动” ORM，即实现了 POJO 和数据库表之间的映射，以及 SQL 的自动生成和执行。 相对于此， MyBatis 只能算作是“半自动” ORM。其着力点，是在 POJO 类 与 SQL 语句之间的映射关系。也就是说， MyBatis 并不会为程序员自动生成 SQL 语句。具体的 SQL 需要程序员自己编写，然后通过 SQL 语句映射文件，将 SQL 所需的参数，以及返回的结果字段映射到指定 POJO。因此， MyBatis 成为了“全自动” ORM 的一种有益补充。 与 Hibernate 相比， MyBatis 具有以下几个特点： 在 XML 文件中配置 SQL 语句，实现了 SQL 语句与代码的分离，给程序的维护带来了很大便利。 因为需要程序员自己去编写 SQL 语句，程序员可以结合数据库自身的特点灵活控制 SQL 语句，因此能够实现比 Hibernate 等全自动 ORM 框架更高的查询效率，能够完成复杂查询。 简单，易于学习，易于使用，上手快。 Mybatis 体系结构 Mybatis 工作原理 第一个 Mybatis 程序需求： 实现将 Student 信息写入到 DB 中 基本程序项目： primary 1. 导入 Jar 包除了需要导入 MyBatis 的核心 Jar 包及依赖 Jar 包外，还需要导入 MySql 的驱动 Jar 包，JUnit 测试的 Jar 包。 2.定义实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.huang.beans;public class Student &#123; private Integer id; private String name; private int age; private double score; public Student(String name, int age, double score) &#123; super(); this.name = name; this.age = age; this.score = score; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getScore() &#123; return score; &#125; public void setScore(double score) &#123; this.score = score; &#125; @Override public String toString() &#123; return "Student [id=" + id + ", name=" + name + ", age=" + age + ", score=" + score + "]"; &#125; &#125; 3. 在 DB 中生成表结构，即创建空表 注意：由于后面要创建的 MyBatis 映射文件映射的是 SQL 语句，而非像 Hibernate 一样，是类到表，属性到字段的映射。所以， MyBatis 要求， 在创建数据库表时，字段名要与属性名一致，如果不一致，需要通过 resultMap 解决。 4. 定义 Dao 接口12345678package com.huang.dao;import com.huang.beans.Student;public interface IStudentDao &#123; void insertStu(Student student);&#125; 5. 定义映射文件映射文件，简称为 mapper，主要完成 Dao 层中 SQL 语句的映射。映射文件名随意，一般放在 dao 包中。 这里映射文件名称定为 mapper.xml。 映射文件的约束文件常用有两种：.dtd、.xsd，约束文件 mybatis-3-mapper.dtd 文件，在 MyBatis 的核心 Jar 包的 org.apache.ibatis.builder.xml 包中存放。当然，主配置文件的约束 dtd 文件也在该位置存放。 映射文件内容为： 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="test"&gt; &lt;insert id="insertStudent" parameterType="com.huang.beans.Student"&gt; insert into student(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;, #&#123;score&#125;) &lt;/insert&gt;&lt;/mapper&gt; 注意：#{ }中写入的是 Student 类的属性名。 6. 定义主配置文件在主配置文件中添加约束，即配置文件头，配置文件名也可以随意命名，这里命名为 mybatis.xml。 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置运行环境 --&gt; &lt;environments default="onlineEM"&gt; &lt;environment id="onlineEM"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="testEM"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 注册映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="com/huang/dao/mapper.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 7. 定义 Dao 实现类123456789101112131415161718192021222324252627282930313233343536373839404142package com.huang.dao;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.huang.beans.Student;public class StudentDaoImpl implements IStudentDao &#123; private SqlSession sqlSession; @Override public void insertStu(Student student) &#123; try &#123; //1.读取主配置文件 InputStream inputStream = Resources.getResourceAsStream("mybatis.xml"); //2.创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //创建SqlSession对象 sqlSession = sqlSessionFactory.openSession(); //操作 sqlSession.insert("insertStudent",student); //SqlSession提交 sqlSession.commit(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125;&#125; 8. 定义测试类12345678910111213141516171819202122package com.huang.test;import org.junit.Before;import org.junit.Test;import com.huang.beans.Student;import com.huang.dao.StudentDaoImpl;public class MyTest &#123; private StudentDaoImpl dao; @Before public void before() &#123; dao= new StudentDaoImpl(); &#125; @Test public void test01() &#123; Student student = new Student("赵六", 26, 97.5); dao.insertStu(student); &#125;&#125; 9. 添加日志控制文件MyBatis 使用 Log4j 进行日志处理，而 Login4j2 对其支持并不好，所以在 MyBatis 中需要将 log4j.properties 放入到项目的 src 目录下。 若将日志级别设置为 debug，则可以显示出所执行的 SQL 语句、参数值、对 DB 的影响条数等信息。若将级别设置为 trace，则还可显示出查询出的每条记录的每个字段名及值。 注意:若日志对象使用根日志对象 rootLogger，则会输出太多的信息。在 MyBatis 中，可以指定要输出日志的工作空间 namespace 的名字。此时，只会输出该 namespace 下执行的 SQL 的日志内容。 12##define a loggerlog4j.logger.test=debug,console 10. 运行结果 使用工具类由于每一次执行 SqlSession 的方法，均需首先获取到该对象。而 SqlSession 对象的获取又相对比较繁琐，所以，可以将获取 SqlSession 对象定义为一个工具类方法。 SqlSession 对象是通过 SqlSessionFactory 对象创建的。由于 SqlSessionFactory 类为重量级对象，且为线程安全的，所以可以将 SqlSessionFactory 对象定义为单例的。 1. 创建工具类1234567891011121314151617181920212223242526272829package com.huang.dao;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;public class MyBatisUtil &#123; private static SqlSessionFactory factory; public static SqlSession getSqlSession() &#123; try &#123; if (factory == null) &#123; //读取主配置文件 InputStream inputStream = Resources.getResourceAsStream("mybatis.xml"); //创建SqlSession工厂 factory = new SqlSessionFactoryBuilder().build(inputStream); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return factory.openSession(); &#125;&#125; 2. 修改 Dao 接口的实现类12345678910111213141516171819202122232425262728package com.huang.dao;import org.apache.ibatis.session.SqlSession;import com.huang.beans.Student;public class StudentDaoImpl implements IStudentDao &#123; private SqlSession sqlSession; @Override public void insertStu(Student student) &#123; try &#123; sqlSession = MyBatisUtil.getSqlSession(); //操作 sqlSession.insert("insertStudent",student); //SqlSession提交 sqlSession.commit(); &#125; finally &#123; //SqlSession关闭，添加了close()不用作事务回滚 if (sqlSession != null) sqlSession.close(); &#125; &#125;&#125; 从属性文件中读取 DB 连接四要素为了方便对数据库连接的管理， DB 连接四要素数据一般都是存放在一个专门的属性文件中的。 MyBatis 主配置文件需要从这个属性文件中读取这些数据。 1. 定义属性文件在 src 下定义属性文件 jdbc.properties。 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.user=rootjdbc.password=123456 2. 修改主配置文件对主配置文件，第一，需要注册属性文件。第二，需要从属性文件中通过 key，将其 value 读取出来。 12&lt;!-- 注册属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; 主配置文件详解主配置文件名可以随意命名，其主要完成以下几个功能：（1）注册存放 DB 连接四要素的属性文件（2）注册实体类的全限定性类名的别名（3）配置 MyBatis 运行环境，即数据源与事务管理器（4）注册映射文件 注册 DB 连接四要素属性文件12&lt;!-- 注册DB连接四要素属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; 指定实体类全限定性类名的别名对于实体类的全限定性类名的别名指定方式，一般使用方式。这样做的好处是会将该包中所有实体类的简单类名指定为别名，写法简单方便。 12345&lt;!-- 定义类型别名 --&gt; &lt;typeAliases&gt; &lt;!-- 将指定包中所有类的简单类名当作其别名 --&gt; &lt;package name="com.huang.beans"/&gt; &lt;/typeAliases&gt; 不过，还有另外的指定方式：通过指定。 123&lt;typeAliases&gt; &lt;typeAlias type="com.huang.beans.Student" alias="Student"/&gt; &lt;/typeAliases&gt; type：全限定性类名 alias：别名 该方式的好处是，可以指定别名为简单类名以外的其它名称。当然，弊端是，必须逐个指定，比较繁琐。 另外，Mybatis 还提供了内置的类型别名： 基本类型： 别名 类型 别名 类型 int int integer int _short short _long long _double double _float float byte byte boolean boolean 常用包类型别名： 别名 类型 别名 类型 string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date object Object collection Collection list List arraylist ArrayList map Map hashmap HashMap iterator Iterator 配置 MyBatis 的运行环境配置 MyBatis 的运行环境，主要是配置数据源与事务管理器。 1. &lt;environments/&gt;标签12345678910&lt;!-- 指定默认运行环境 --&gt; &lt;environments default="onlineEM"&gt; &lt;!-- 项目上线环境 --&gt; &lt;environment id="onlineEM"&gt; &lt;/environment&gt; &lt;!-- 项目测试环境 --&gt; &lt;environment id="testEM"&gt; &lt;/environment&gt; &lt;/environments&gt; 在&lt;environments/&gt;中可包含多个运行环境&lt;environment/&gt;，但其 default 属性指定了当前 MyBatis 运行时所选择使用的环境。&lt;environment/&gt;的 id 属性为当前定义的运行环境的名称，可以任意命名。该名称会作为&lt;environments/&gt;的 default 属性的值出现。 2. &lt;transactionManager/&gt;标签12 &lt;!-- 使用jdbc事务管理 --&gt;&lt;transactionManager type="JDBC"/&gt; 该标签用于指定 MyBatis 所使用的事务管理器。 MyBatis 支持两种事务管理器类型： JDBC 与 MANAGED。 JDBC：使用 JDBC 的事务管理机制。即，通过 Connection 的 commit()方法提交，通过 rollback() 方法回滚。但默认情况下， MyBatis 将自动提交功能关闭了，改为了手动提交。即程序中需要显式的对事务进行提交或回滚。从日志的输出信息中可以看到。 MANAGED：由容器来管理事务的整个生命周期（如 Spring 容器）。 &lt;dataSource/&gt;标签该标签用于配置 MyBatis 使用的数据源类型与数据库连接基本属性。常见有类型有： UNPOOLED、 POOLED、 JDNI 等。 UNPOOLED ：不使用连接池。即每次请求，都会为其创建一个 DB 连接，使用完毕后，会马上将此连接关闭。 POOLED：使用数据库连接池来维护连接。 JNDI：数据源可以定义到应用的外部，通过 JNDI 容器获取数据库连接。 1234567&lt;!-- 数据库连接池 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt;&lt;/dataSource&gt; 若要从属性文件中读取 DB 连接四要素信息，则使用如下方式： 12345678&lt;!-- 数据库连接池 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.user&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt; 指定映射文件指定映射文件的方式有多种。但所有的方式，都是指定在&lt;mappers/&gt;标签中的。 &lt;mapper resource=””/&gt;指定映射文件若映射文件只有一个，则可直接使用如下形式： 1234&lt;!-- 注册映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="com/huang/dao/mapper.xml"/&gt; &lt;/mappers&gt; 若映射文件有多个，则可使用如下形式： 12345&lt;!-- 注册映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource="com/huang/dao/mapper.xml"/&gt; &lt;mapper resource="com/huang/dao/mapper2.xml"/&gt; &lt;/mappers&gt; API 详解Dao 中需要通过 SqlSession 对象来操作 DB。而 SqlSession 对象的建，需要其工厂对象 SqlSessionFactory。 SqlSessionFactory 对象，需要通过其构建器对象 SqlSessionFactoryBuilder 的 build()方法，在加载了主配置文件的输入流对象后创建。 Resources 类Resources 类，顾名思义就是资源，用于读取资源文件。其有很多方法通过加载并解析资源文件，返回不同类型的 IO 流对象。 SqlSessionFactoryBuilder 类SqlSessionFactory 的创建，需要使用 SqlSessionFactoryBuilder 对象的 build()方法。由于 SqlSessionFactoryBuilder 对象在创建完工厂对象后，就完成了其历史使命，即可被销毁。所以，一般会将该 SqlSessionFactoryBuilder 对象创建为一个方法内的局部对象，方法结束，对象销毁。 SqlSessionFactory 接口SqlSessionFactory 接口对象是一个重量级对象（系统开销大的对象），是线程安全的， 所以一个应用只需要一个该对象即可。 创建 SqlSession 需要使用 SqlSessionFactory 接口的的 openSession()方法。 openSession(true)：创建一个有自动提交功能的 SqlSession openSession(false)：创建一个非自动提交功能的 SqlSession，需手动提交 openSession()：同 openSession(false) SqlSession 接口SqlSession 接口对象用于执行持久化操作。一个 SqlSession 对应着一次数据库会话，一次会话以 SqlSession 对象的创建开始，以 SqlSession 对象的关闭结束。 SqlSession 接口对象是线程不安全的，所以每次数据库会话结束前，需要马上调用其 close()方法，将其关闭。再次需要会话，再次创建。 而在关闭时会判断当前的 SqlSession 是否被提交：若没有被提交，则会执行回滚后关闭；若已被提交，则直接将 SqlSession 关闭。所以， SqlSession 无需手工回滚。]]></content>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库基础入门与实战]]></title>
    <url>%2F2019%2F07%2F28%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[常见数据库 关系型数据库：MySQL、Oracle、SQL Server、JDBC、DB2等。 非关系型数据库：Redis、MongoDB、NoSQL等。 关系型数据库主要是用来描述实体与实体之间的关系，实实在在存在的事物。例如：男生和女生、学生和班级、员工和部门。 非关系型数据库非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。(本章主要讲关系型数据库) MySQL数据库服务器MySQL数据库：数据库管理软件。 服务器：就是一台电脑，这台安装相关的服务器软件，这些软件监听不同的端口号，根据用户访问的端口号，提供不同的服务。 数据库：通常一个应用对应一个数据库。 MySQL的SQL语句 SQL：Structure Query Languages结构化查询语言 数据定义语言(DDL)：定义数据库，数据表的结构：create(创建)、drop(删除)、alter(修改) 数据操纵语言(DML)：主要是用来操作数据：insert(插入)、update(修改)、delete(删除) 数据控制语言(DCL)：定义访问权限，取消访问权限，安全设置 grant 数据查询语言(DQL)：select(查询) from子句 where子句 数据库的CRUD的操作前置知识： 登录数据库：mysql –uroot –proot 退出数据库：exit、quit、\q、Ctrl+c 退出当前命令行：\c 复制命令行的内容：标记-&gt;选择内容-&gt;回车，不用Ctrl+C 导出数据库文件： 进入MySQL的安装目录的bin目录，如：D:\Program Files (x86)\MySQL\MySQLServer5.0\bin 用cmd打开 输入命令:mysqldump –h localhost –u root –p 数据库名字&gt;导出路径 1mysqldump –h localhost –u root –p worker&gt;e:worker.sql 启动MySQL服务：net start mysql 关闭MySQL服务：net stop mysql 创建数据库:create database 数据库名字; 1create database test; 创建数据库的时候，指定字符集 create database 数据库的名字 character set 字符集; 1create database test character set utf8; create database 数据库的名字 character set 字符集 collate 校对规则; 1create database test character utf8 collate utf8_bin; 查看数据库：show create database 数据库名字; 查看所有数据库 1show databases; 注意：三个文件不可删information_schema 相关信息约束performance_schema 相关表现约束mysql 修改数据库的操作修改数据库的字符集 alter database 数据库的名字 character set 字符集 1alter database test character set gbk; 删除数据库drop database 数据库名字; 切换数据库(选中数据库)use 数据库名字; ###查看当前正在使用的数据库 1select database (); 表的CRUD操作### 创建表 12345create database 数据库名字 create table 表名( 列名 列的类型(长度) 约束, 列名2 列的类型(长度) 约束 ); 列的类型 列的约束主键约束：primary key唯一约束：unique非空约束：not null 123456create table student(sid int primary key,sname varchar(10),sex int,age int); 查看表查看所有的表 1show tables; 查看表的创建过程 show create table 表名; 1show create table student; 查看表的结构 1desc student; 修改表添加(add)，修改列(modify)，修改列名(change)，删除列(drop)，修改表名(rename)，修改表的字符集 添加列(add) alter table 表名 add 列名 列的类型 列的约束 1alter table student add score int not null; 修改列(modify) 1alter table student modify sex varchar(2); 修改列名(change) 1alter table student change sex gender varchar(2); 删除列(drop) 1alter table student drop score; 修改表名(rename) 1rename table student to students; 修改表的字符集 1alter table student character set gbk; 删除表1drop table students; 移动列的顺序alter table 表名 modify 字段名 字段类型 after 字段alter table student modify sex int(11) after sname;(移动到sname后面)alter table student modify sex int(11) first;(移动到最前面) SQL完成对表中数据的CRUD的操作插入数据insert into 表名(列名1,列名2,列名3) values(值1,值2,值3); 1insert into student(sid,sname,sex,age) values(1,'zhangsan',1,22); 简单写法(插入部分列列名不可省略) 1insert into student values(2, 'zhangsan',1,22); 批量插入 1234insert into student values(3, 'zhangsan',1,22),(4, 'zhangsan',1,22),(5, 'zhangsan',1,22); 查看表中数据1select * from student; 解决表中插入数据中文乱码的问题1、 设置数据库的表字符编码为jbk；2、 停止MySQL服务(net stop mysql)；3、 找到MySQL的安装路径，找到my.ini文件，把default-character-set=utf8修改为default-character-set=gbk；4、 启动MySQL服务(net start mysql)，重新登录数据库。 删除记录delete from 表名 [where 条件] 1delete from student where sid=5; 把表中数据全部删除 1delete from student; 问题：delete删除数据和truncate删除数据有什么差别？delete:DML一条一条删除表中的数据truncate:DDL先删除表再重建表关于哪条执行效率高，具体要看表中的数据如果数据比较少，delete比较高效如果数据比较多，truncate比较高效 更新表记录update 表名 set 列名=列的值，列名2=列名2的值 [where 条件]如果参数是字符串、日期 要加上单引号 1update student set sname= '张三' where sid=5; 1update student set sname= '李四' ,sex='1'; 查询记录select [distinct] [ * ] [列名,列名2] from 表名 [where 条件] 说明：distinct：去除重复的数据select：选择显示哪些列的内容 简单查询查询所有 select * from 表名 查询姓名和性别 1select sname,sex from student; 别名查询，as的关键字，as关键字可以省略 表别名select s.sname,s.sex from student as s;(主要用在多表查询) 列别名select sname as 姓名,age as 年龄 from student; 去掉重复的值 1select age from student; 1select distinct age from student; 说明：select： 运算查询：仅在查询结果上做了运算 1select * ,age*2 from student; 1select * ,age*2 as 两倍年龄 from student; 条件查询[where关键字] 查询年龄大于20的学生 1select * from student where age &gt; 20; where 后的条件写法 说明：关系运算符：&gt; &gt;= &lt; &lt;= != &lt;&gt;&lt;&gt; 不等于 标准SQL语法!= 不等于 非标准SQL语法 查询学生年龄不等于20的所有学生 1select * from student where age &lt;&gt; 20; 1select * from student where age != 20; 查询年龄在20到30之间 1select * from student where age &gt; 20 and age &lt; 30; 使用 between… and… 查询 1select * from student where age between 20 and 30; 逻辑运算：and , or , not 查询年龄小于15 或者年龄大于20 1select * from student where age &lt; 15 or age &gt; 20; 复杂查询 模糊查询 —like： _ :代表的是一个字符% :代表的是多个字符 查询姓名中带有 张 的所有学生 ‘%张%’ 1select * from student where sname like '%张%'; 查询第二名字是三的所有学生 ‘_张%’ 1select * from student where sname like '_张%'; —in 在某个范围获得值 查询年龄在20,21,22里面的所有学生 1select * from student where age in (20,21,22); 排序查询 order by 关键字asc :ascend 升序(默认的排序方式)desc:descend 降序 查询所有学生的年龄，按照年龄进行排序 1select * from student order by age; 查询所有学生的年龄，按照年龄进行降序排序 1select * from student order by age desc; 查询学生姓名有 张 的学生，按年龄排序 查询学生姓名有 张 的所有学生 1select * from student where sname like '%张%'; 进行排序得出结果 1select * from student where sname like '%张%' order by age asc; 聚合函数sum(): 求和avg(): 求平均值count(): 统计数据max(): 最大值min(): 最小值 获得所有商品价格的总和 select sum(价格名称) from 表名; 1select sum(price) from product; 获得所商品的平均价格 1select avg(price) from product; 获得所有商品的个数 1select count(*) from product; 注意：where 条件后面不能接聚合函数 查出商品价格大于平均的所有商品 查出所有商品 1select from product; 大于平均价格 1select avg(price) from product; 如平均价格为100 1select * from product where price &gt; 100; 或者(子查询) 1select * from product where price &gt; (select avg(price) from product); 分组group by 根据cno字段分组，分组后统计商品的个数 1select cno,count(*) from product group by cno; 根据cno分组，分组统计每组商品的平均价格，并且商品平均价格 &gt; 60 123select cno,avg(price)from product group by cnohaving avg(price) &gt; 60; 说明：having 关键字 可以接聚合函数 出现在分组之后where 关键字 它是不可以接聚合函数 出现在在分组之前 编写顺序 S..F..W..G..H..O 1select..from..where..group by..having..order by 执行顺序 F..W..G..H..S..O 1from..where..group by..having..select..order by SQL多表操作SQL 会创建多表及多表的关系 需求:分类表和商品表之间是不是有关系? 如果有关系,在数据库中如何表示这种关系 12345create table category(cid int primary key auto_increment,cname varchar(10), cdesc varchar(31)); 12345insert into category values(null,'手机数码','电子产品,黑马生产');insert into category values(null,'鞋靴箱包','江南皮鞋厂倾情打造');insert into category values(null,'香烟酒水','黄鹤楼,茅台,二锅头');insert into category values(null,'酸奶饼干','娃哈哈,蒙牛酸酸乳');insert into category values(null,'馋嘴零食','瓜子花生,八宝粥,辣条'); 1select * from category; 1select cname,cdesc from category; 所有商品1.商品ID2.商品名称3.商品的价格4.生产日期5.商品分类ID 商品和商品分类 : 所属关系 1234567create table product(pid int primary key auto_increment,pname varchar(10),price double,pdate timestamp,cno int); 12345678insert into product values(null,'小米mix4',998,null,1);insert into product values(null,'锤子',2888,null,1);insert into product values(null,'阿迪王',99,null,2);insert into product values(null,'老村长',88,null,3);insert into product values(null,'劲酒',35,null,3);insert into product values(null,'小熊饼干',1,null,4);insert into product values(null,'卫龙辣条',1,null,5);insert into product values(null,'旺旺大饼',1,null,5); 多表之间的关系如何来维护外键约束: foreign key 给product中的这个cno 添加一个外键约束 1alter table product add foreign key(cno) references category(cid); 建数据库原则通常情况下,一个项目/应用建一个数据库 多表之间的建表原则 一对多 : 商品和分类建表原则: 在多的一方添加一个外键,指向一的一方的主键 多对多: 老师和学生, 学生和课程建表原则: 建立一张中间表,将多对多的关系,拆分成一对多的关系,中间表至少要有两个外键,分别指向原来的那两张表 一对一: 班级和班长, 公民和身份证, 国家和国旗 建表原则:将一对一的情况,当作是一对多情况处理,在任意一张表添加一个外键,并且这个外键要唯一,指向另外一张表直接将两张表合并成一张表将两张表的主键建立起连接,让两张表里面主键相等实际用途: 用的不是很多.(拆表操作)相亲网站:个人信息 : 姓名,性别,年龄,身高,体重,三围,兴趣爱好,(年收入,特长,学历, 职业, 择偶目标,要求)拆表操作 : 将个人的常用信息和不常用信息,减少表的臃肿, 网上商城表实例的分析:用户购物流程(用户表、订单表、商品表、商品分类表) 用户表 (用户的ID,用户名,密码,手机) 123456create table user( uid int primary key auto_increment, username varchar(31), password varchar(31), phone varchar(11) ); 1insert into user values(1,'zhangsan','123','13811118888'); 订单表 (订单编号,总价,订单时间 ,地址,外键用户的ID) 12345678create table orders( oid int primary key auto_increment, sum int not null, otime timestamp, address varchar(100), uno int, foreign key(uno) references user(uid) ); 12insert into orders values(1,200,null,'黑马前台旁边小黑屋',1);insert into orders values(2,250,null,'黑马后台旁边1702',1); 商品表 (商品ID, 商品名称,商品价格,外键cno) 1234567create table product( pid int primary key auto_increment, pname varchar(10), price double, cno int, foreign key(cno) references category(cid) ); 12345678insert into product values(null,'小米mix4',998,1);insert into product values(null,'锤子',2888,1);insert into product values(null,'阿迪王',99,2);insert into product values(null,'老村长',88,3);insert into product values(null,'劲酒',35,3);insert into product values(null,'小熊饼干',1,4);insert into product values(null,'卫龙辣条',1,5);insert into product values(null,'旺旺大饼',1,5); 订单项: 中间表(订单ID,商品ID,商品数量,订单项总价) 12345678create table orderitem( ono int, pno int, foreign key(ono) references orders(oid), foreign key(pno) references product(pid), ocount int, subsum double); 给1号订单添加商品 200块钱的商品 12insert into orderitem values(1,7,100,100);insert into orderitem values(1,8,101,100); 给2号订单添加商品 250块钱的商品 () 12insert into orderitem values(2,5,1,35);insert into orderitem values(2,3,3,99); 商品分类表(分类ID,分类名称,分类描述) 12345create table category( cid int primary key auto_increment, cname varchar(15), cdesc varchar(100) ); 12345insert into category values(null,'手机数码','电子产品,黑马生产');insert into category values(null,'鞋靴箱包','江南皮鞋厂倾情打造');insert into category values(null,'香烟酒水','黄鹤楼,茅台,二锅头');insert into category values(null,'酸奶饼干','娃哈哈,蒙牛酸酸乳');insert into category values(null,'馋嘴零食','瓜子花生,八宝粥,辣条'); 多表之间的关系如何维护外键约束 : foreign key 添加一个外键: 1alter table product add foreign key(cno) references category(cid); 删除的时候, 先删除外键关联的所有数据,再才能删除分类的数据 建表原则一对多:建表原则: 在多的一方增加一个外键,指向一的一方 多对多:建表原则: 将多对多转成一对多的关系,创建一张中间表 一对一: 不常用, 拆表操作建表原则: 将两张表合并成一张表将两张表的主键建立起关系将一对一的关系当作一对多的关系去处理 主键约束:默认就是不能为空, 唯一外键都是指向另外一张表的主键主键一张表只能有一个 唯一约束列面的内容, 必须是唯一, 不能出现重复情况, 为空唯一约束不可以作为其它表的外键可以有多个唯一约束 一对多 : 建表原则: 在多的一方添加一个外键,指向一的一方 多对多: 建表原则: 拆成一对多 创建一张中间表, 至少要有两个外键, 指向原来的表 一对一: 建表原则: 合并一张表, 将主键建立关系 , 将它当作一对多的情况来处理 交叉连接查询(笛卡尔积)1SELECT * FROM product; 1SELECT * FROM category; 笛卡尔积 ,查出来是两张表的乘积 ,查出来的结果没有意义 1SELECT * FROM product,category; 过滤出有意义的数据1SELECT * FROM product,category WHERE cno=cid; 1SELECT * FROM product AS p,category AS c WHERE p.cno=c.cid; 1SELECT * FROM product p,category c WHERE p.cno=c.cid; 数据准备 1INSERT INTO product VALUES(NULL,'耐克帝',10,NULL); 内连接查询隐式内链接 1SELECT * FROM product p,category c WHERE p.cno=c.cid; 显示内链接 1SELECT * FROM product p INNER JOIN category c ON p.cno=c.cid; 区别: 隐式内链接: 在查询出结果的基础上去做的WHERE条件过滤 显示内链接: 带着条件去查询结果, 执行效率要高 左外连接 左外连接,会将左表中的所有数据都查询出来, 如果右表中没有对应的数据,用NULL代替 1SELECT * FROM product p LEFT OUTER JOIN category c ON p.cno=c.cid; 准备工作 1INSERT INTO category VALUES(100,'电脑办公','电脑叉叉差'); 右外连接: 会将右表所有数据都查询出来, 如果左表没有对应数据的话, 用NULL代替 1SELECT * FROM product p RIGHT OUTER JOIN category c ON p.cno=c.cid; 分页查询 每页数据数据3起始索引从0第1页: 0第2页: 3起始索引: index 代表显示第几页 页数从1开始每页显示3条数据 1startIndex = (index-1)*3 第一个参数是索引第二个参数显示的个数 12select * from product limit 0,3;select * from product limit 3,3; 子查询查询出(商品名称,商品分类名称)信息查询分类名称为手机数码的所有商品 查询分类名为手机数码的ID 1select * from category where cname ='手机数码'; 得出ID为1的结果 1SELECT * FROM product WHERE cno = (SELECT cid FROM category WHERE cname='手机数码'); 查询出(商品名称,商品分类名称)信息 左连接 1SELECT p.pname,c.cname FROM product p LEFT OUTER JOIN category c ON p.cno = c.cid; 子查询 1SELECT pname ,(SELECT cname FROM category c WHERE p.cno=c.cid ) AS 商品分类名称 FROM product p; 总结下面这张表是本章的主要内容]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM入门基础知识]]></title>
    <url>%2F2019%2F07%2F28%2FSSM%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[系统架构所谓系统架构是指，整合应用系统程序大的结构。经常提到的系统结构有两种：三层架构与 MVC。这两种结构既有区别，又有联系。但这两种结构的使用，均是为了降低系统模块间的耦合度。 三层架构三层架构是指：视图层 View、服务层 Service 与持久层 Dao。 它们分别完成不同的功能。 View 层：用于接收用户提交请求的代码在这里编写。 Service 层：系统的业务逻辑主要在这里完成。 Dao 层：直接操作数据库的代码，对数据库进行增删改查。 关系Service 层是建立在 Dao 层之上的，建立了 Dao 层后才可以建立 Service 层，而 Service 层又是在 Controller 层之下的，因而 Service 层应该既调用 Dao 层的接口，又要提供接口给 Controller 层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个 Service 接口，每个接口分别封装各自的业务处理方法。 作用为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准（接口）是相同的，服务提供者（实现类）可以更换。这就实现了层间解耦合。 耦合性耦合性也叫耦合度，是程序结构中各个模块之间相互关联的度量，它取决于各个模块之间接口的复杂程度调用模块的方式以及哪些信息通过接口。关联性越高，耦合度越高，后期维护成本就越大，因此在开发过程中要尽量避免代码耦合度。 下面用一张图来表示三层架构的关系 MVCMVC，即 Model 模型、 View 视图，及 Controller 控制器。 View： 视图，为用户提供使用界面，与用户直接进行交互。 Model： 模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载 Bean，一类称为业务处理 Bean。所谓数据承载 Bean 是指实体类，专门用户承载业务数据的，如 Student、 User 等。而业务处理 Bean 则是指 Service 或 Dao 对象，专门用于处理用户提交请求的。 Controller： 控制器，用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应。 MVC 架构程序的工作流程： 用户通过 View 页面向服务端提出请求，可以是表单请求、超链接请求、 Ajax 请求等。 服务端 Controller 控制器接收到请求后对请求进行解析，找到相应的 Model 对用户请求进行处理。 Model 处理后，将处理结果再交给 Controller。 Controller 在接到处理结果后，根据处理结果找到要作为向客户端发回的响应 View 页面。页面经渲染（数据填充）后，再发送给客户端。 MVC与三层架构的关系MVC与三层架构很相似，但它们不一样。 相同点： 分层、解耦 相同的设计理念，把视图设计与数据持久化进行分离，从而降低耦合性，易于扩展，提高团队开发效率。 不同点： 三层是基于业务逻辑来分的，而mMVC是基于页面来分的。 MVC模式是一种复合设计模式，一种解决方案。 三层是种软件架构，通过接口实现编程。 三层模式是体系结构模式，MVC是设计模式。 三层模式又可归于部署模式，MVC可归于表示模式。 如图表示它们二者的关系 SSM与三层架构的关系SSM，即 SpringMVC、 Spring 与 MyBatis 三个框架。它们在三层架构中所处的位置是不同的，即它们在三层架构中的功能各不相同，各司其职。 SpringMVC：作为 View 层的实现者，完成用户的请求接收功能。SpringMVC 的 Controller 作为整个应用的控制器，完成用户请求的转发及对用户的响应。 MyBatis：作为 Dao 层的实现者，完成对数据库的增、删、改、查功能。 Spring：以整个应用大管家的身份出现。整个应用中所有 Bean 的生命周期行为，均由Spring 来管理。即整个应用中所有对象的创建、初始化、销毁，及对象间关联关系的维护，均由 Spring 进行管理。 环境设置解决乱码问题，可以在端口后面加上 URIEncoding=”UTF-8”，把8080改为80访问时可以不用输入端口号 代理模式 理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。——百度百科《代理模式》 换句话说， 使用代理对象，是为了在不修改目标对象的基础上， 增强主业务逻辑。客户类真正的想要访问的对象是目标对象，但客户类真正可以访问的对象是代理对象。客户类对目标对象的访问是通过访问代理对象来实现的。当然，代理类与目标类要实现同一个接口。 对于代理模式，需要注意以下几点： 代理类和目标类要实现同一个接口，即业务接口。 客户类对目标类的调用均是通过代理类完成的。 代理类的执行既执行了对目标类的增强业务逻辑，又调用了目标类的主业务逻辑。 根据代理关系建立的时间不同，可以将代理分为两类：静态代理与动态代理。 静态代理静态代理是指，代理类在程序运行前就已经定义好，其与目标类的关系在程序运行前就已经确立。(需要定义代理类) 代理实现与解析静态代理实现转账： （1）定义业务接口 IAccountService，其中含有抽象方法 transfer()。 123456package com.huang.service;public interface IAccountService &#123; //主业务逻辑:转账 void transfer();&#125; （2）定义目标类 AccountServiceImpl，该类实现了业务接口。在对接口方法的实现上，只实现主业务逻辑转账即可。这个方法称为目标方法。 1234567891011package com.huang.service;public class AccountServiceImpl implements IAccountService &#123; //目标方法 @Override public void transfer() &#123; System.out.println("调用Dao层，完成转账业务。"); &#125;&#125; （3）定义代理类 AccountServiceImplProxy。这个类要实现 IAccount 接口。并且该代理类要将接口对象作为一个成员变量，还要定义一个带参的构造器，这个参数为接口对象。目的是，将目标对象引入代理类，以便代理类调用目标类的目标法。 123456789101112131415161718192021222324252627282930package com.huang.proxy;import com.huang.service.IAccountService;import com.huang.service.AccountServiceImpl;//代理类public class AccountServiceImplProxy implements IAccountService &#123; //声明业务接口对象 private IAccountService target; public AccountServiceImplProxy() &#123; &#125; //业务接口对象作为构造器参数，用于接受目标对象 public AccountServiceImplProxy(IAccountService target) &#123; this.target = target; &#125; /** * 代理方法，实现对目标方法的功能增强 */ @Override public void transfer() &#123; //此处为对目标类的增强 System.out.println("对转账进行身份认证！"); target.transfer(); &#125;&#125; （4）定义客户类 Client。在客户类中首先要创建目标对象，再创建代理对象，并使用标对象对其进行初始化。然后由代理对象来调用执行业务方法。 12345678910111213141516171819package com.huang.test;import com.huang.proxy.AccountServiceImplProxy;import com.huang.service.AccountServiceImpl;import com.huang.service.IAccountService;public class MyTest &#123; public static void main(String[] args) &#123; //创建目标对象 IAccountService target = new AccountServiceImpl(); //创建代理对象，并使用目标对象来初始化它 IAccountService service = new AccountServiceImplProxy(target); //此时执行的内容，就是对目标对象增加过的内容 service.transfer(); &#125;&#125; 运行结果如下 JDK 动态代理动态代理是指， 程序在整个运行过程中根本就不存在目标类的代理类，目标对象的代理对象只是由代理生成工具（如代理工厂类）在程序运行时由 JVM 根据反射等机制动态生成的。代理对象与目标对象的代理关系在程序运行时才确立。 对比静态代理，静态代理是指在程序运行前就已经定义好了目标类的代理类。代理类与目标类的代理关系在程序运行之前就确立了。 动态代理的实现方式常用的有两种：使用 JDK 的 Proxy，与通过 CGLIB 生成代理。 动态代理的实现方式常用的有两种：使用 JDK 的 Proxy，与通过 CGLIB 生成代理。 12345public static newProxyInstance ( ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler handler)loader：目标类的类加载器，通过目标对象的反射可获取interfaces：目标类实现的接口数组，通过目标对象的反射可获取handler：业务增强逻辑，需要再定义。 InvocationHandler 是个接口，其具体介绍如下：实现了 InvocationHandler 接口的类用于加强目标类的主业务逻辑。这个接口中有一个方法 invoke()，具体加强的代码逻辑就是定义在该方法中的。程序调用主业务逻辑时，会自动调用 invoke()方法。 invoke()方法的介绍如下： 1234public Object invoke ( Object proxy, Method method, Object[] args)proxy：代表生成的代理对象method：代表目标方法args：代表目标方法的参数 由于该方法是由代理对象自动调用的，所以这三个参数的值不用程序员给出。 第二个参数为 Method 类对象，该类有一个方法也叫 invoke()，可以调用目标类的目标方法。这两个 invoke()方法，虽然同名，但无关。 123public Object invoke ( Object obj, Object... args)obj：表示目标对象args：表示目标方法参数，就是其上一层 invoke 方法的第三个参数 该方法的作用是：调用执行 obj 对象所属类的方法，这个方法由其调用者 Method 对象确定。在代码中，一般的写法为 1method.invoke(target, args); 其中， method 为上一层 invoke 方法的第二个参数。这样，即可调用了目标类的目标方法。 代理实现与解析动态代理实现转账： （1）定义业务接口 IAccounSevice，其中含有抽象方法 transfer()。 （2）定义目标类 AccountServiceImpl，该类实现了业务接口。在对接口方法的实现上，只实现主业务逻辑。这个方法称为目标方法。 以上两步与静态代理类第一二步中代码相同。 （3）定义主业务增强逻辑类 MyExtension，该类需实现接口 InvocationHandler。在该类中定义一个 Object 类型的成员变量，还要定义一个带参的构造器，这个参数为 Object 对象。目的是，将目标对象引入该类，以便通过反射调用目标方法。 1234567891011121314151617181920212223242526272829package com.huang.proxy;import com.huang.service.IAccountService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;//代理类public class MyExtension implements InvocationHandler &#123; //声明业务接口对象 private IAccountService target; public MyExtension() &#123; &#125; //业务接口对象作为构造器参数，用于接受目标对象 public MyExtension(IAccountService target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //增加主业务逻辑代码 System.out.println("对转账用户进行身份认证"); //无论业务方法有无参数，有无返回值，下面的写法均可兼顾 return method.invoke(target, args); &#125;&#125; （4）定义客户类 Client。客户类中主要语句有三句：A、定义目标对象。在生成代理对象时会需要目标对象对其初始化。B、定义代理对象。需要注意的是，代理类 Proxy 会通过反射机制，自动实现 IAccount接口。代理对象需要使用目标对象对其进行初始化。C、代理对象调用主业务方法。 123456789101112131415161718192021222324package com.huang.test;import java.lang.reflect.Proxy;import com.huang.proxy.MyExtension;import com.huang.service.AccountServiceImpl;import com.huang.service.IAccountService;public class MyTest &#123; public static void main(String[] args) &#123; //创建目标对象 IAccountService target = new AccountServiceImpl(); //创建代理对象，并使用目标对象来初始化它 IAccountService service = (IAccountService) Proxy.newProxyInstance( target.getClass().getClassLoader(), //获取目标对象类加载器 target.getClass().getInterfaces(), //获取目标类实现的所有接口 new MyExtension(target)); //增强业务逻辑 //此时执行的内容，就是对目标对象增加过的内容 service.transfer(); &#125;&#125; CGLIB 动态代理概念使用 JDK 的 Proxy 实现代理，要求目标类与代理类实现相同的接口。若目标类不存在接口， 则无法使用该方式实现。 但对于无接口的类，要为其创建动态代理，就要使用 CGLIB 来实现。 CGLIB 代理的生成原理是生成目标类的子类，而子类是增强过的，这个子类对象就是代理对象。 所以， 使用CGLIB 生成动态代理，要求目标类必须能够被继承，即不能是 final 的类。 CGLIB(Code Generation Library)是一个开源项目，是一个强大的、高性能的、高质量的代码生成类库。它可以在运行期扩展和增强 Java 类。 Hibernate 用它来实现持久对象的字节码的动态生成， Spring 用它来实现 AOP 编程。——百度百科《CGLIB》 CGLIB 包的底层是通过使用一个小而快的字节码处理框架 ASM(Java 字节码操控框架)，来转换字节码并生成新的类。 CGLIB 是通过对字节码进行增强来生成代理的。 代理实现与解析Setp1：导入 CGLIB 的 Jar 包： cglib-full.jar。 Step2：定义目标类。 12345678910111213141516package com.huang.service;//目标类public class SomeService &#123; //目标方法 public String doFirst() &#123; System.out.println("执行了doFirst()方法"); return "abcde"; &#125; //目标方法 public void doSecond() &#123; System.out.println("执行了doSecond()方法"); &#125;&#125; Step3：创建代理类的工厂。该类要实现 MethodInterceptor 接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.huang.factory;import java.lang.reflect.Method;import com.huang.service.SomeService;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;//代理类public class MyCglibFactory implements MethodInterceptor &#123; private SomeService target; public MyCglibFactory() &#123; target = new SomeService(); &#125; public SomeService myCglibCreator() &#123; // 创建增强器对象 Enhancer enhancer = new Enhancer(); // 指定目标类，即父类 enhancer.setSuperclass(SomeService.class); // 设置回调接口对象 enhancer.setCallback(this); return (SomeService) enhancer.create(); &#125; // 回调方法 @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; // 调用目标方法 Object result = method.invoke(target, args); if (result != null) &#123; result = ((String) result).toUpperCase(); &#125; return result; &#125;&#125; Step4：创建测试类。 1234567891011121314151617package com.huang.test;import java.lang.reflect.Proxy;import com.huang.service.SomeService;import com.huang.factory.MyCglibFactory;public class MyTest &#123; public static void main(String[] args) &#123; SomeService service = new MyCglibFactory().myCglibCreator(); String result = service.doFirst(); System.out.println("result = " + result); service.doSecond(); &#125;&#125; 运行结果如下 方法回调设计模式在 Java 中，就是类 A 调用类 B 中的某个方法 b，然后类 B 又在某个时候反过来调用类 A中的某个方法 a，对于 A 来说，这个 a 方法便叫做回调方法。Java 的接口提供了一种很好的方式来实现方法回调。这个方式就是定义一个简单的接口，在接口之中定义一个我们希望回调的方法。 这个接口称为回调接口。 在前面的例子中，我们定义的 AccountServiceCglibProxyFactory 类就相当于前面所说的 A类，而 Enhancer 类则是 B 类。 A 类中调用了 Enhancer 类 setCallback(this)方法，并将回调对象 this 作为实参传递给了 Enhancer 类。 Enhancer 类在后续执行过程中，会调用 A 类中的 intercept()方法，这个 intercept()方法就是回调方法。 适配器模式适配器模式的定义是， Convert the interface of a class into another interface clients expect，将某个类的接口转换为接口客户所需的类型。 换句话说， 适配器模式解决的问题是， 使得原本由于接口不兼容而不能一起工作、不能统一管理的那些类可以在一起工作、可以进行统一管理。 举个例子： 需求：厨师的工作是 cook()，程序员的工作是 program()，司机的工作是 drive()，教师的工作是 teach()，不同的工种，其具体工作内容不同。现在程序要将这些（例如有 30 个不同工种）不同工种的工作内容全部输出。 解决方案一：逐个访问每个工种对象的相应工作方法。无法循环遍历，无法统一管理。解决方案二：使用适配器设计模式，将这些不兼容的具体工作转换为一个统一的工作，实现循环遍历。 基本元素定义这里举个适配器模式的例子：这里有厨师接口 ICooker、程序员接口 IProgrammer，分别用于定义他们各自工种的具体工作。然后又定义了全聚德的厨师 QjdCooker、京东的程序员 JdProgrammer。这些不同的工种所做的工作都各自是不同的，无法进行统一管理，协同工作。 所以，此时就需要定义一个员工适配器接口 IWorkerAdapter，用于将这些不同的工种进行统一管理。 不使用适配器模式若不使用适配器模式，则调用者需要定义出所有的工种对象，然后逐个工种对象的工作方法进行调用。有 30 个工种，就应调用 30 个工作方法。很麻烦。 修改代码如下： （1）定义 IWorkerAdapter 1234567package com.huang.adapters;public interface IWorkerAdapter &#123; //为了兼顾所有工种员工，这里的参数必须为Object类型 String work(Object worker);&#125; （2）定义 WorkerAdapter 1234567891011121314151617181920212223package com.huang.adapters.impl;import com.huang.adapters.IWorkerAdapter;import com.huang.worker.ICooker;import com.huang.worker.IProgrammer;//适配器类public class WorkerAdapter implements IWorkerAdapter &#123; @Override public String work(Object worker) &#123; String workContent = ""; //若传来的对象是厨师，则其调用其cook()方法 if (worker instanceof ICooker) &#123; workContent = ((ICooker)worker).cook(); &#125;else if (worker instanceof IProgrammer) &#123; workContent = ((IProgrammer)worker).program(); &#125; return workContent; &#125;&#125; （3）定义测试类 12345678910111213141516171819202122232425package com.huang.test;import com.huang.adapters.IWorkerAdapter;import com.huang.adapters.impl.WorkerAdapter;import com.huang.worker.ICooker;import com.huang.worker.IProgrammer;import com.huang.worker.impl.GjProgrammer;import com.huang.worker.impl.QjdCooker;public class MyTest &#123; public static void main(String[] args) &#123; ICooker qjdCooker = new QjdCooker(); IProgrammer gjProgrammer = new GjProgrammer(); Object[] workers = &#123;qjdCooker,gjProgrammer&#125;; // 创建适配器对象 IWorkerAdapter adapter = new WorkerAdapter(); // 循环遍历每个工种对象，让每个工种对象在适配器中逐个进行匹配 for (Object worker : workers) &#123; String workContent = adapter.work(worker); System.out.println(workContent); &#125; &#125;&#125; 为每个工种都定义一个适配器为每一个工种定义一个适配器，其程序结构如下： 代码如下： （1）修改 IWorkerAdapter 12345678910package com.huang.adapters;public interface IWorkerAdapter &#123; //为了兼顾所有工种员工，这里的参数必须为Object类型 String work(Object worker); //判断当前适配器是否支持指定的工种对象 boolean supports(Object worker);&#125; （2）定义 CookerAdapter 12345678910111213141516171819package com.huang.adapters.impl;import com.huang.adapters.IWorkerAdapter;import com.huang.worker.ICooker;import com.huang.worker.IProgrammer;public class CookerAdapter implements IWorkerAdapter &#123; @Override public String work(Object worker) &#123; return ((ICooker)worker).cook(); &#125; @Override public boolean supports(Object worker) &#123; return (worker instanceof ICooker); &#125;&#125; （3）定义 ProgrammerAdapter 123456789101112131415161718package com.huang.adapters.impl;import com.huang.adapters.IWorkerAdapter;import com.huang.worker.IProgrammer;public class ProgrammerAdappter implements IWorkerAdapter &#123; @Override public String work(Object worker) &#123; return ((IProgrammer)worker).program(); &#125; @Override public boolean supports(Object worker) &#123; return ((worker instanceof IProgrammer)); &#125;&#125; （4）定义测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.huang.test;import java.util.ArrayList;import java.util.List;import com.huang.adapters.IWorkerAdapter;import com.huang.adapters.impl.CookerAdapter;import com.huang.adapters.impl.ProgrammerAdappter;import com.huang.worker.ICooker;import com.huang.worker.IProgrammer;import com.huang.worker.impl.GjProgrammer;import com.huang.worker.impl.QjdCooker;public class MyTest &#123; public static void main(String[] args) &#123; ICooker qjdCooker = new QjdCooker(); IProgrammer gjProgrammer = new GjProgrammer(); Object[] workers = &#123;qjdCooker,gjProgrammer&#125;; // 循环遍历每个工种对象，让每个工种对象在适配器中逐个进行匹配 for (Object worker : workers) &#123; IWorkerAdapter adapter = getAdapter(worker); System.out.println(adapter.work(worker)); &#125; &#125; //根据worker获取相应的适配器 private static IWorkerAdapter getAdapter(Object worker) &#123; List&lt;IWorkerAdapter&gt; adapters = getAllAdapters(); for (IWorkerAdapter adapter : adapters) &#123; if (adapter.supports(worker)) &#123; return adapter; &#125; &#125; return null; &#125; // 获取所有的适配器 private static List&lt;IWorkerAdapter&gt; getAllAdapters() &#123; List&lt;IWorkerAdapter&gt; adapters = new ArrayList&lt;&gt;(); adapters.add(new CookerAdapter()); adapters.add(new ProgrammerAdappter()); return adapters; &#125;&#125; 缺省适配器模式缺省适配器模式是由适配器模式简化而来， 省略了适配器模式中目标接口， 也就是源接口和目标接口相同， 源接口为接口， 目标接口为类。 典型的缺省适配器模式是 JavaEE 规范中的 Servlet 接口与 GenericServlet 抽象类。Servlet 接口中包含五个抽象方法，而其中的 service()方法才是用于实现业务逻辑的、必须要实现的方法，另外四个方法一般都是空实现，或简单实现。 GenericServlet 抽象类实现了 Servlet 接口的 service()方法以外的另外四个方法，所以自定义的 Servlet 只需要继承 GenericServlet 抽象类，实现 service()方法即可。无需再实现 Servlet 接口了。 模板方法设计模式在现实生活中，完成某件事情是需要 n 多个固定步骤的。如“在淘宝网进行购物”这件事情的完成一般需要三个步骤：登录网站、挑选商品(抽象方法)、 付款。但对于登录网站与付款这两步，每个人几乎都是相同的操作。但不同的地方是，每个人所挑选的商品是不同的。 在软件开发过程中同样存在这样的情况。某类的某个方法的实现，需要几个固定步骤。在这些固定步骤中，对于该类的不同对象，有些步骤的实现是固定不的，有些步骤的实现是大相径庭的，有些步骤的实现是可变可不变的。对于这种情况，就适合使用模板方法设计模式编程。 模板方法设计模式的定义是：定义一个操作中某种算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类在不改变一个算法结构的前提下，对某些步骤实现个性化定义。 模板方法程序构成在模板方法设计模式中，存在一个父类。其中包含两类方法：模板方法与步骤方法。 模板方法：即实现某种算法的方法步骤。而这些步骤都是调用的步骤方法完的。 步骤方法：即完成模板方法的每个阶段性方法。每个步骤方法完成某一特定的、完成总算法的一部分功能。 步骤方法有三种类型：抽象方法、最终方法与钩子方法。 抽象方法：是要求子类必须实现的方法，是完成模板方法的算法步骤中必须由子类完成的个性化定义。 最终方法：是子类不能重写的方法，是若要完成模板方法的算法步骤，对于所有子类执行都一样的步骤。 钩子方法：是父类给出了默认实现，但子类也可以重写的方法。 程序举例模拟“淘宝购物”，创建 templateMethod 工程，代码如下： （1）定义父类 123456789101112131415161718192021222324252627package com.huang.service;public abstract class Shopping &#123; //模板方法 public void buyGoods() &#123; userLogin(); //用户登录 buy(); //挑选商品 pay(); //付款 &#125; //子类不能重写的方法 public final void userLogin() &#123; System.out.println("用户登录"); &#125; //子类必须实现 public abstract void buy(); //钩子方法，子类可以重写 public void pay() &#123; System.out.println("使用银联支付"); &#125;&#125; （2）定义子类 12345678910package com.huang.service;public class ShoesShopping extends Shopping &#123; @Override public void buy() &#123; System.out.println("购买鸿星尔克运动鞋"); &#125;&#125; 123456789101112131415package com.huang.service;public class ClothesShopping extends Shopping &#123; @Override public void buy() &#123; System.out.println("购买七匹狼男装"); &#125; @Override public void pay() &#123; System.out.println("使用支付宝付款"); &#125;&#125; （3）定义测试类 123456789101112131415161718package com.huang.test;import com.huang.service.ClothesShopping;import com.huang.service.ShoesShopping;import com.huang.service.Shopping;public class MyTest &#123; public static void main(String[] args) &#123; Shopping shoesShopping = new ShoesShopping(); shoesShopping.buyGoods(); System.out.println("-----------------------"); Shopping clothesShopping = new ClothesShopping(); clothesShopping.buyGoods(); &#125;&#125; 运行结果如下： Junit测试Jar包的下载关于Junit的Jar包下载，百度有很多的详细下载教程，这里不再赘述。 测试类的创建对于测试类的创建有这样一些习惯： 在项目中新建一个 source folder，并命名为 test，将来所有测试类均定义在这个目录中。 对于测试类所在包，一般是被测类所在包的包名后加再加一个 test 子包。 对于测试类类名，一般是被测类类名后加上 Test。 测试类的创建常用的有两种方式： 1. 使用向导创建测试类直接创建 JUnit Test Case。此时，会自动导入其需要的 Jar 包。 创建过程中，勾选上 setUp()与 tearDown()方法，这两个方法的作用是： setUp()：测试方法执行之前执行，主要用于测试前的初始化，如连接数据库等。 tearDown()：测试方法执行之后执行，主要用于资源释放，如关闭数据库连接等。 创建好后，直接在 setUp()与 tearDown()中编写初始化语句与资源释放语句即可。 对于测试方法的命名， 一般是以小写 test 开头，该测试方法用于测试哪个方法，就将该方法名放于 test 之后。当然，首字母要大写。 如，要测试 modify()方法，则它的测试方法名一般为： testModify()。 2. 使用注解创建测试类Step1：导入包需的 JUnit Jar 包Step2：直接创建一个普通的 Java 类Step3：在其中可以定义初始化方法与资源释放方法。方法签名要求： public void，无参。方法名随意。当然，方法名最好按照规范命名。Step4：在方法前添加注解 添加@Before 则为初始化方法；添加@After 则为资源释放方法；添加@Test 则为测试方法。 测试方法的运行在测试方法的方法签名上右击，选择 Run As/JUnit Test 运行结果看到绿条，则说明运行成功；看到红条，说明运行出了问题。 Log4j 与Log4j2 一个完整的软件，日志是必不可少的。程序从开发、测试、维护、运行等环节，都需要向控制台或文件等位置输出大量信息 。这些信息的输出，在 很多时候是使 用 System.out.println() 无法完成的。 日志信息根据用途与记录内容的不同，分为调试日志、运行日志、异常日志等。 用于日志记录的技术很多，如 jdk 的 logger 技术， apache 的 log4j、 log4j2 技术等。 Log4j 的全称为 Log for java，即，专门用于 java 语言的日志记录工具。其目前有两个版本： Log4j 与 Log4j2。 Log4j基础日志级别为了方便对于日志信息的输出显示，对日志内容进行了分级管理。 日志级别由高到低 ，共分 6 个级别： fatal(致命的)、 error、 warn、 info、 debug、 trace(堆栈)。 日志输出控制文件Log4j 的日志输出控制文件，主要由三个部分构成： 日志信息的输出位置：控制日志信息将要输出的位置，是控制台还是文件等。 日志信息的输出格式：控制日志信息的显示格式，即以怎样的字符串形式显示。 日志信息的输出级别： 控制日志信息的显示内容，即显示哪些级别的日志信息。 Log4j技术在 Java 代码中进行日志输出，需要用到 Logger 类的静态方法 getLogger()。 123456789101112131415161718package com.huang.test;import org.apache.log4j.Logger;public class MyTest &#123; public static void main(String[] args) &#123; //创建日志记录对象Logger Logger logger = Logger.getLogger(MyTest.class); logger.fatal("fatal msg"); logger.error("error msg"); logger.warn("warn msg"); logger.info("info msg"); logger.debug("debug msg"); logger.trace("trace msg"); &#125;&#125; 运行结果如下： 将来这些日志输出语句，会根据 log4j.properties 文件中日志级别的设置进行输出，会输出到指定位置。 其输出结果是：输出指定级别及其更高级别的信息。如指定 info 级别，则会输出 fatal、 error、warn、 info 级别的信息。 日志输出控制文件分析日志属性文件 log4j.properties 是专门用于控制日志输出的。其主要进行三方面控制： 输出位置：控制日志将要输出的位置，是控制台还是文件等。 输出布局：控制日志信息的显示形式。 输出级别：控制要输出的日志级别。 日志属性文件由两个对象组成：日志附加器与根日志。 根日志，即为 Java 代码中的日志记录器，其主要由两个属性构成：日志输出级别与日志附加器。 日志附加器，则由日志输出位置定义，由其它很多属性进行修饰，如输出布局、文件位置、文件大小等。 定义日志附加器所谓日志附加器，就是为日志记录器附加上很多其它设置信息。附加器的本质是一个接口，其定义语法为： log4j.appender.appenderName = 输出位置， appenderName 为自定义名称。 常用的附加器实现类如下： org.apache.log4j.ConsoleAppender： 日志输出到控制台 org.apache.log4j.FileAppender： 日志输出到文件 org.apache.log4j.RollingFileAppender： 当日志文件大小到达指定尺寸的时候将产生一个新的日志文件 org.apache.log4j.DailyRollingFileAppender： 每天产生一个日志文件 修饰日志附加器所谓修饰日志附加器，就是为定义好的附加器添加一些属性，以控制到指定位置的输出。不同的附加器，其修饰属性不同。 Log4j常用布局类型 org.apache.log4j.HTMLLayout： 网页布局， 以 HTML 表格形式布局 org.apache.log4j.SimpleLayout： 简单布局， 包含日志信息的级别和信息字符串 org.apache.log4j.PatternLayout： 匹配器布局， 可以灵活地指定布局模式。其主要是通过设置 PatternLayout 的 ConversionPattern 属性值来控制具 体输出格式的 。 配置根 Logger配置 rootLogger，以便于代码加载来控制日志的输出。其语法为： 1log4j.rootLogger = [ level ] , appenderName, … 其中， level 是日志记录的优先级，分为 OFF、 FATAL、 ERROR、 WARN、 INFO、 DEBUG、ALL。 Log4j 建议只使用四个级别，优先级从高到低分别是 ERROR、 WARN、 INFO、 DEBUG。OFF 为关闭日志功能。 说明：低级别的可以显示高级别的，但高级别的不能显示低级别的。所以，级别越高，将来显示的信息就越少。 Log4j2 技术Log4j2，是对 Log4j 的升级，其在配置与使用上发生了较大变化。 log4j2 配置文件是 XML 文件，不再支持 properties 文件。默认的文件名为 log4j2.xml。其存放的位置为 classpath 中。 代码中实现日志记录在要输出日志的类中创建日志对象 Logger，并通过 Logger 的方法在代码中加入日志输出语句。该日志对象是通过静态类 LogManager 的 getLogger()方法获取的。 1234567891011121314151617package com.huang.test;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;public class MyTest &#123; public static void main(String[] args) &#123; //创建日志对象Logger Logger logger = LogManager.getLogger(MyTest.class); logger.debug("this debug msg"); logger.info("this info msg"); logger.warn("this warn msg"); logger.error("this error msg"); &#125;&#125; 运行结果如下： 注意: Logger 与 LogManager 均为 org.apache.logging.log4j 包中的类，非 org.apache.log4j 包中的。 日志输出控制文件分析Log4j2 配置文件是 XML 文件，不再支持 properties 文件。默认的文件名为 log4j2.xml。其存放的位置为 classpath 中。 若没有设置 log4j2.xml，则系统会使用默认的日志配置：只会输出到控制台 error 级别的信息。 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration status="OFF"&gt; &lt;appenders&gt; &lt;Console name="myConsole" target="SYSTEM_OUT"&gt; &lt;PatternLayout pattern="[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%c %L] %m%n" /&gt; &lt;/Console&gt; &lt;File name="myLogFile" fileName="log/test.log" append="true"&gt; &lt;PatternLayout pattern="[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%c %L] %m%n" /&gt; &lt;/File&gt; &lt;RollingFile name="myRollingFile" fileName="logs/app.log" filePattern="logs/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz"&gt; &lt;PatternLayout pattern="[%-5p][%d&#123;yyyy-MM-dd HH:mm:ss&#125;] [%c %L] %m%n" /&gt; &lt;SizeBasedTriggeringPolicy size="1KB" /&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;!-- &lt;logger name="全限定类名或接口名" level="info"&gt; &lt;appender-ref ref="myConsole" /&gt; &lt;/logger&gt; --&gt; &lt;root level="trace"&gt; &lt;appender-ref ref="myConsole" /&gt; &lt;!-- &lt;appender-ref ref="myLogFile" /&gt; &lt;appender-ref ref="myRollingFile" /&gt; --&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 配置文件说明： （1）&lt;configuration/&gt;标签标签的 status 属性用于设置 Log4j2 自身运行的日志显示级别，一般为 OFF，不显示。 当然，也可以设置为 ERROR、 DEBUG 等其它级别。 （2）&lt;Console/&gt;标签标签的 target 属性用于设置输出的目标形式，其值一般为：SYSTEM_OUT 或 SYSTEM_ERR （3）&lt;File/&gt;标签标签的 fileName 属性用于设置文件的文件保存路径及文件名。如本例的意思是，日志文件名为 test.log，将其存放在当前项目的根目录下的 log 子目录中。 append 属性用于设置是否以追加方式将日志写入指定文件。 （4）&lt;RollingFile/&gt;标签fileName 指定存放目录及第一个日志文件名。 filePattern 指定新创建的日志文件的文件名。本例还会对文件进行压缩。 （5）&lt;loggers/&gt;标签用于配置根 Logger 对象，以指定所使用的日志记录器，及显示的级别。 其子标签用于指定所使用的日志记录器。该子标签的属性 level 用于指定显示级别。而日志记录器是通过的子标签来引用中定义好的记录器的。 需要注意的是，只要在中定义了、 等，且在其中指定了日志存放的目录，那么这些目录就会自动创建。无论在的中是否声明使用它们。 &lt;\adfjdkf&gt;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务技术——Tomcat]]></title>
    <url>%2F2019%2F07%2F27%2FWeb%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Tomcat%2F</url>
    <content type="text"><![CDATA[服务器 其实服务器就是一台电脑。 配置比一般的电脑要好。 Web服务器软件 客户端在浏览器的地址栏上输入地址 ，然后web服务器软件，接收请求，然后响应消息。处理客户端的请求， 返回资源 | 信息。 Web应用：需要服务器支撑 服务器 所属公司 Tomcat-----------Apache WebLogic---------BEA WebSphere--------IBM IIS--------------微软Tomcat安装 直接解压 ，然后找到bin目录下的startup.bat文件启动。 启动之后，如果能够正常看到黑窗口，表明已经成功安装。 为了确保万无一失， 最好在浏览器的地址栏上输入 ： http://localhost:8080 , 如果有看到如下内容就表明成功了。 如果双击了startup.bat, 看到一闪而过的情形，一般都是 JDK的环境变量没有配置。 Tomcat目录介绍bin：包含了一些jar , bat文件 。 startup.bat conf：tomcat的配置，如 server.xml web.xml lib：tomcat运行所需的jar文件 logs：运行的日志文件 temp：临时文件 webapps：发布到tomcat服务器上的项目，就存放在这个目录。 work：jsp翻译成class文件存放地如何把一个项目发布到Tomcat中 需求： 如何能让其他的电脑访问我这台电脑上的资源？ 在电脑新建stu.xml文件，内容如下 1234&lt;person&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt;&lt;/person&gt; 直接拷贝stu.xml文件到webapps/ROOT目录下， 在浏览器里面访问默认访问方式：http://localhost:8080/stu.xml 可以使用IP地址访问：http://192.168.43.139:8080/stu.xml 注意： 如果Tomcat在运行需要重新启动，否则会报404错误。 需要把xml文件改为UTF-8编码，否则会报错。解决方法是使用记事本打开xml文件，选择文件——&gt;另存为，“编码”格式选则UTF-8，点击保存。 在webaps下面新建一个文件夹xml , 然后拷贝文件放置到这个文件夹中http://localhost:8080/xml/stu.xml 也可以使用IP地址访问：http://192.168.43.139:8080/xml/stu.xml 说明： http://localhost:8080 ： 其实对应的是到webapps/roothttp://localhost:8080/xml/ : 对应是 webapps/xml 配置虚拟路径(一) 查看使用文档说明 使用localhost：8080 打开tomcat首页， 在左侧找到tomcat的文档入口， 点击进去后， 在左侧接着找到 Context入口，点击进入。 也可以输入地址访问：http://localhost:8080/docs/config/context.html 在conf/server.xml 找到host元素节点 12&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; 加入以下内容 1&lt;Context docBase="D:\xml02" path="/a"&gt;&lt;/Context&gt; 在D盘新建xml02文件夹，在文件夹下新建person.xml文件，内容如下 12345&lt;person&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;body&gt;这里是虚拟路径&lt;/body&gt;&lt;/person&gt; 说明: 1). docBase： 项目的路径地址，如： D:\xml02\person.xml。 2). path : 对应的虚拟路径 一定要以/打头。 在浏览器地址栏上输入：http://localhost:8080/a/person.xml 配置虚拟路径(二) 在tomcat/conf/catalina/localhost/ 文件夹下新建一个xml文件，名字可以自己定义。如person.xml。 在person.xml文件里面写入以下内容 12&lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;Context docBase="D:\xml02"&gt;&lt;/Context&gt; 在浏览器上面访问：http://localhost:8080/person/person.xml 注意： XML文件的名字也就是项目部署成功后的web根路径，如定义这person.xml,那么后面的访问路径就是http://ip:port/person。 给Eclipse配置Tomcat 在server里面 右键新建一个服务器， 选择到Apache分类， 找到对应的Tomcat版本， 接着一步一步配置即可。 配置完毕后， 在server 里面， 右键刚才的服务器，然后Open ， 找到上面的Server Location , 选择中间的 Use Tomcat installation… 创建Web工程， 在WebContent下定义html文件， 右键工程， run as server 程序架构 C/S(Client/Server) QQ、微信、LOL 优点： 有一部分代码写在客户端， 用户体验比较好。 缺点： 服务器更新，客户端也要随着更新。 占用资源大。 B/S(Browser/Server) 网页游戏 ， WebQQ … 优点： 客户端只要有浏览器就可以了。 占用资源小， 不用更新。 缺点： 用户体验不佳。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接技术——JDBC(Java DataBase Connectivity)]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94JDBC%2F</url>
    <content type="text"><![CDATA[为什么会出现JDBC SUN公司提供的一种数据库访问规则、规范, 由于数据库种类较多，并且Java语言使用比较广泛，SUN公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的Java程序只要使用SUN公司提供的JDBC驱动即可。 使用JDBC的基本步骤 注册驱动： 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 建立连接：参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。 12//DriverManager.getConnection("jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb"); conn = DriverManager.getConnection("jdbc:mysql://localhost/student", "root", "root"); 创建statement：跟数据库打交道，一定需要这个对象。 1st = conn.createStatement(); 执行sql ，得到ResultSet：执行查询，得到结果集。 12String sql = "select * from t_stu";rs = st.executeQuery(sql); 遍历结果集：遍历查询每一条记录 。 123456while(rs.next())&#123; int id = rs.getInt("id"); String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println("id="+id + "===name="+name+"==age="+age); &#125; 释放资源： 1234567if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException sqlEx) &#123; &#125; // ignore rs = null; &#125;... JDBC 工具类构建 资源释放工作的整合 驱动防二次注册 1). river 这个类里面有静态代码块，一上来就执行了，所以等同于我们注册了两次驱动。 其实没这个必要的。 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 2). 静态代码块 ——&gt;类加载了，就执行。 1java.sql.DriverManager.registerDriver(new Driver()); 3).最后形成以下代码即可。 1Class.forName("com.mysql.jdbc.Driver"); 使用properties配置文件 1). 在src底下声明一个文件 xxx.properties ，里面的内容如下： 1234driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost/studentname=rootpassword=root 2). 在工具类里面，使用静态代码块，读取属性 123456789101112131415161718192021static&#123; try &#123; //创建一个属性配置对象 Properties properties = new Properties(); InputStream is = new FileInputStream("jdbc.properties"); //对应文件位于工程根目录 //使用类加载器，去读取src底下的资源文件。 后面在servlet //对应文件位于src目录底下 //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties"); //导入输入流。 properties.load(is); //读取属性 driverClass = properties.getProperty("driverClass"); url = properties.getProperty("url"); name = properties.getProperty("name"); password = properties.getProperty("password"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; ​ 数据库(SQL)的CRUD insert INSERT INTO t_stu (NAME , age) VALUES (&apos;wangqiang&apos;,28) //INSERT INTO t_stu VALUES (NULL,&apos;wangqiang2&apos;,28) 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "insert into t_stu values(null , 'aobama' , 59)";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql); if(result &gt;0 )&#123; System.out.println("添加成功");&#125;else&#123; System.out.println("添加失败");&#125; delete DELETE FROM t_stu WHERE id = 6 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "delete from t_stu where name='aobama'";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql); if(result &gt;0 )&#123; System.out.println("删除成功");&#125;else&#123; System.out.println("删除失败");&#125; query SELECT * FROM t_stu 12345678910111213141516// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();// 3. 执行sql语句，返回ResultSetString sql = "select * from t_stu";rs = st.executeQuery(sql);// 4. 遍历结果集while (rs.next()) &#123; String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println(name + " " + age); &#125; update UPDATE t_stu SET age = 38 WHERE id = 1; 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "update t_stu set age = 26 where name ='qyq'";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql);if(result &gt;0 )&#123; System.out.println("更新成功");&#125;else&#123; System.out.println("更新失败");&#125; 使用单元测试，测试代码 定义一个类， TestXXX , 里面定义方法 testXXX. 添加Junit的支持。右键工程 — add Library — Junit — Junit4 在方法的上面加上注解 ， 其实就是一个标记。 1234@Testpublic void testQuery() &#123; ...&#125; 光标选中方法名字，然后右键执行单元测试。 或者是打开outline视图， 然后选择方法右键执行。 Dao模式 Data Access Object 数据访问对象 新建一个dao的接口， 里面声明数据库访问规则 12345678910/** * 定义操作数据库的方法 */public interface UserDao &#123; /** * 查询所有 */ void findAll();&#125; 新建一个dao的实现类，具体实现早前定义的规则 123456789101112131415161718192021222324252627282930 public class UserDaoImpl implements UserDao&#123; @Override public void findAll() &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1. 获取连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); String sql = "select * from t_user"; rs = st.executeQuery(sql); while(rs.next())&#123; String userName = rs.getString("username"); String password = rs.getString("password"); System.out.println(userName+"="+password); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, st, rs); &#125; &#125;&#125; 直接使用实现 12345@Testpublic void testFindAll()&#123; UserDao dao = new UserDaoImpl(); dao.findAll();&#125; Statement安全问题 Statement执行 ，其实是拼接sql语句的。即先拼接sql语句，然后在一起执行。 123456789String sql = "select * from t_user where username='"+ username +"' and password='"+ password +"'";UserDao dao = new UserDaoImpl();dao.login("admin", "100234khsdf88' or '1=1"); SELECT * FROM t_user WHERE username='admin' AND PASSWORD='100234khsdf88' or '1=1' //前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 rs = st.executeQuery(sql); PrepareStatement 该对象就是替换前面的statement对象。 相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。 123456String sql = "insert into t_user values(null , ? , ?)";ps = conn.prepareStatement(sql); //给占位符赋值 从左到右数过来，1 代表第一个问号， 永远都是从1开始。ps.setString(1, userName); ps.setString(2, password); ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务技术——Servlet]]></title>
    <url>%2F2019%2F07%2F25%2FWeb%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Servlet%2F</url>
    <content type="text"><![CDATA[Servlet是什么? 其实就是一个Java程序，运行在我们的Web服务器上，用于接收和响应客户端的HTTP请求。 更多的是配合动态资源来做。 当然静态资源也需要使用到Servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet Servlet执行过程第一步：类的定义1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.huang.servlet;import java.io.IOException;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;/** * *@author 黄远志 *@date 2019年7月4日下午7:08:19 *@GitHub https://github.com/huangyuanzhi1997 */public class HelloServlet implements Servlet &#123; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println("HelloServlet"); &#125; @Override public void destroy() &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void init(ServletConfig config) throws ServletException &#123; &#125;&#125; 第二步：Servlet的配置1234567891011&lt;!-- 向tomcat报告， 我这个应用里面有这个servlet，名字叫做HelloServlet , 具体的路径是com.huang.servlet.HelloServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.huang.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 注册servlet的映射。 servletName : 找到上面注册的具体servlet，url-pattern: 在地址栏上的path一定要以/打头 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 找到Tomcat应用 找到项目 找web.xml，然后在里面找到url-pattern，有没有哪一个patten的内容是/a 找到servlet-mapping中的那个servlet-name【HelloServlet】 找到上面定义的servlet元素中的servlet-naem【HelloServlet】 找到下面定义的servlet-class，然后开始创建该类的实例 继而执行该servlet中的service方法 Servlet的通用写法Servlet (接口) | | GenericServlet | | HttpServlet （用于处理http的请求）定义一个类，继承HttpServlet 复写doGet 和 doPost12345678910111213141516171819202122232425262728293031323334353637package com.huang.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * *@author 黄远志 *@date 2019年7月4日下午7:51:01 *@GitHub https://github.com/huangyuanzhi1997 */public class HelloServlet02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("HelloServlet02..."); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); System.out.println("get..."); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); System.out.println("post..."); &#125;&#125; Servlet的生命周期 生命周期 从创建到销毁的一段时间。 生命周期方法 从创建到销毁，所调用的那些方法。 init方法 在创建该Servlet的实例时，就执行该方法。 一个Servlet只会初始化一次， init方法只会执行一次。 默认情况下是 ： 初次访问该Servlet，才会创建实例。 service方法 只要客户端来了一个请求，那么就执行这个方法了。 该方法可以被执行很多次。 一次请求，对应一次service方法的调用。 destroy方法 servlet销毁的时候，就会执行该方法。 1). 该项目从Tomcat的里面移除。 2). 正常关闭Tomcat就会执行 shutdown.bat。 doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。 让Servlet创建实例的时机提前 默认情况下，只有在初次访问Servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么有没有方法可以让这个初始化的时机提前一点。 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 12345&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt; 为什么需要有这个ServletConfig Servlet的配置，通过这个对象，可以获取Servlet在配置的时候一些信息 先说 ， 再写怎么用， 最后说有什么用。 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。它的代码放置在了自己的servlet类里面。 刚好这个Servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个Servlet的公司，在注册Servlet的时候，必须要在web.xml里面，声明init-params 在开发当中比较少用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
