<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web服务技术——Tomcat]]></title>
    <url>%2F2019%2F07%2F27%2FWeb%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Tomcat%2F</url>
    <content type="text"><![CDATA[服务器 其实服务器就是一台电脑。 配置比一般的电脑要好。 Web服务器软件 客户端在浏览器的地址栏上输入地址 ，然后web服务器软件，接收请求，然后响应消息。处理客户端的请求， 返回资源 | 信息。 Web应用：需要服务器支撑。 index.html 服务器 所属公司 Tomcat Apache WebLogic BEA WebSphere IBM IIS 微软Tomcat安装 直接解压 ，然后找到bin目录下的startup.bat文件启动。 启动之后，如果能够正常看到黑窗口，表明已经成功安装。 为了确保万无一失， 最好在浏览器的地址栏上输入 ： http://localhost:8080 , 如果有看到如下内容就表明成功了。 如果双击了startup.bat, 看到一闪而过的情形，一般都是 JDK的环境变量没有配置。 Tomcat目录介绍bin：包含了一些jar , bat文件 。 startup.bat conf：tomcat的配置，如 server.xml web.xml lib：tomcat运行所需的jar文件 logs：运行的日志文件 temp：临时文件 webapps：发布到tomcat服务器上的项目，就存放在这个目录。 work：jsp翻译成class文件存放地如何把一个项目发布到Tomcat中 需求： 如何能让其他的电脑访问我这台电脑上的资源？ 在电脑新建stu.xml文件，内容如下 1234&lt;person&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt;&lt;/person&gt; 1. 直接拷贝stu.xml文件到webapps/ROOT目录下， 在浏览器里面访问http://localhost:8080/stu.xml 可以使用IP地址访问：http://192.168.43.139:8080/stu.xml 注意： 1）. 如果Tomcat在运行需要重新启动，否则会报404错误。2）. 需要把xml文件改为UTF-8编码，否则会报错。解决方法是使用记事本打开xml文件，选择文件——&gt;另存为，“编码”格式选则UTF-8，点击保存。 2. 在webaps下面新建一个文件夹xml , 然后拷贝文件放置到这个文件夹中http://localhost:8080/xml/stu.xml 也可以使用IP地址访问：http://192.168.43.139:8080/xml/stu.xml 说明： http://localhost:8080 ： 其实对应的是到webapps/roothttp://localhost:8080/xml/ : 对应是 webapps/xml 3. 配置虚拟路径(一) 查看使用文档说明 使用localhost：8080 打开tomcat首页， 在左侧找到tomcat的文档入口， 点击进去后， 在左侧接着找到 Context入口，点击进入。 也可以输入地址访问：http://localhost:8080/docs/config/context.html1). 在conf/server.xml 找到host元素节点 2). 加入以下内容 1&lt;Context docBase="D:\xml02" path="/a"&gt;&lt;/Context&gt; 说明: docBase： 项目的路径地址，如： D:\xml02\person.xml。path : 对应的虚拟路径 一定要以/打头。 3). 在浏览器地址栏上输入： http://localhost:8080/a/person.xml 4. 配置虚拟路径(二)1). 在tomcat/conf/catalina/localhost/ 文件夹下新建一个xml文件，名字可以自己定义。如person.xml。 2). 在person.xml文件里面写入以下内容 12&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;Context docBase="D:\xml02"&gt;&lt;/Context&gt; 3). 在浏览器上面访问 http://localhost:8080/person/xml的名字 http://localhost:8080/person/person.xml 给Eclipse配置Tomcat 在server里面 右键新建一个服务器， 选择到apache分类， 找到对应的tomcat版本， 接着一步一步配置即可。 配置完毕后， 在server 里面， 右键刚才的服务器，然后open ， 找到上面的Server Location , 选择中间的 Use Tomcat installation… 创建web工程， 在WebContent下定义html文件， 右键工程， run as server 程序架构网页游戏 C/S(Client/Server) QQ、微信、LOL 优点： 有一部分代码写在客户端， 用户体验比较好。 缺点： 服务器更新，客户端也要随着更新。 占用资源大。 B/S(browser/server) 网页游戏 ， WebQQ … 优点： 客户端只要有浏览器就可以了。 占用资源小， 不用更新。 缺点： 用户体验不佳。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接技术——JDBC(Java DataBase Connectivity)]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94JDBC%2F</url>
    <content type="text"><![CDATA[为什么会出现JDBC SUN公司提供的一种数据库访问规则、规范, 由于数据库种类较多，并且Java语言使用比较广泛，SUN公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的Java程序只要使用SUN公司提供的JDBC驱动即可。 使用JDBC的基本步骤 注册驱动： 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 建立连接：参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。 12//DriverManager.getConnection("jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb"); conn = DriverManager.getConnection("jdbc:mysql://localhost/student", "root", "root"); 创建statement：跟数据库打交道，一定需要这个对象。 1st = conn.createStatement(); 执行sql ，得到ResultSet：执行查询，得到结果集。 12String sql = "select * from t_stu";rs = st.executeQuery(sql); 遍历结果集：遍历查询每一条记录 。 123456while(rs.next())&#123; int id = rs.getInt("id"); String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println("id="+id + "===name="+name+"==age="+age); &#125; 释放资源： 1234567if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException sqlEx) &#123; &#125; // ignore rs = null; &#125;... JDBC 工具类构建 资源释放工作的整合 驱动防二次注册 1). river 这个类里面有静态代码块，一上来就执行了，所以等同于我们注册了两次驱动。 其实没这个必要的。 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 2). 静态代码块 ——&gt;类加载了，就执行。 1java.sql.DriverManager.registerDriver(new Driver()); 3).最后形成以下代码即可。 1Class.forName("com.mysql.jdbc.Driver"); 使用properties配置文件 1). 在src底下声明一个文件 xxx.properties ，里面的内容如下： 1234driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost/studentname=rootpassword=root 2). 在工具类里面，使用静态代码块，读取属性 123456789101112131415161718192021static&#123; try &#123; //创建一个属性配置对象 Properties properties = new Properties(); InputStream is = new FileInputStream("jdbc.properties"); //对应文件位于工程根目录 //使用类加载器，去读取src底下的资源文件。 后面在servlet //对应文件位于src目录底下 //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties"); //导入输入流。 properties.load(is); //读取属性 driverClass = properties.getProperty("driverClass"); url = properties.getProperty("url"); name = properties.getProperty("name"); password = properties.getProperty("password"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; ​ 数据库(SQL)的CRUD insert INSERT INTO t_stu (NAME , age) VALUES (&apos;wangqiang&apos;,28) //INSERT INTO t_stu VALUES (NULL,&apos;wangqiang2&apos;,28) 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "insert into t_stu values(null , 'aobama' , 59)";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql); if(result &gt;0 )&#123; System.out.println("添加成功");&#125;else&#123; System.out.println("添加失败");&#125; delete DELETE FROM t_stu WHERE id = 6 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "delete from t_stu where name='aobama'";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql); if(result &gt;0 )&#123; System.out.println("删除成功");&#125;else&#123; System.out.println("删除失败");&#125; query SELECT * FROM t_stu 12345678910111213141516// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();// 3. 执行sql语句，返回ResultSetString sql = "select * from t_stu";rs = st.executeQuery(sql);// 4. 遍历结果集while (rs.next()) &#123; String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println(name + " " + age); &#125; update UPDATE t_stu SET age = 38 WHERE id = 1; 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "update t_stu set age = 26 where name ='qyq'";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql);if(result &gt;0 )&#123; System.out.println("更新成功");&#125;else&#123; System.out.println("更新失败");&#125; 使用单元测试，测试代码 定义一个类， TestXXX , 里面定义方法 testXXX. 添加Junit的支持。右键工程 — add Library — Junit — Junit4 在方法的上面加上注解 ， 其实就是一个标记。 1234@Testpublic void testQuery() &#123; ...&#125; 光标选中方法名字，然后右键执行单元测试。 或者是打开outline视图， 然后选择方法右键执行。 Dao模式 Data Access Object 数据访问对象 新建一个dao的接口， 里面声明数据库访问规则 12345678910/** * 定义操作数据库的方法 */public interface UserDao &#123; /** * 查询所有 */ void findAll();&#125; 新建一个dao的实现类，具体实现早前定义的规则 123456789101112131415161718192021222324252627282930 public class UserDaoImpl implements UserDao&#123; @Override public void findAll() &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1. 获取连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); String sql = "select * from t_user"; rs = st.executeQuery(sql); while(rs.next())&#123; String userName = rs.getString("username"); String password = rs.getString("password"); System.out.println(userName+"="+password); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, st, rs); &#125; &#125;&#125; 直接使用实现 12345@Testpublic void testFindAll()&#123; UserDao dao = new UserDaoImpl(); dao.findAll();&#125; Statement安全问题 Statement执行 ，其实是拼接sql语句的。即先拼接sql语句，然后在一起执行。 123456789String sql = "select * from t_user where username='"+ username +"' and password='"+ password +"'";UserDao dao = new UserDaoImpl();dao.login("admin", "100234khsdf88' or '1=1"); SELECT * FROM t_user WHERE username='admin' AND PASSWORD='100234khsdf88' or '1=1' //前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 rs = st.executeQuery(sql); PrepareStatement 该对象就是替换前面的statement对象。 相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。 123456String sql = "insert into t_user values(null , ? , ?)";ps = conn.prepareStatement(sql); //给占位符赋值 从左到右数过来，1 代表第一个问号， 永远都是从1开始。ps.setString(1, userName); ps.setString(2, password); ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务技术——Servlet]]></title>
    <url>%2F2019%2F07%2F25%2FWeb%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Servlet%2F</url>
    <content type="text"><![CDATA[Servlet是什么? 其实就是一个Java程序，运行在我们的Web服务器上，用于接收和响应客户端的HTTP请求。 更多的是配合动态资源来做。 当然静态资源也需要使用到Servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet Servlet执行过程第一步：类的定义1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.huang.servlet;import java.io.IOException;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;/** * *@author 黄远志 *@date 2019年7月4日下午7:08:19 *@GitHub https://github.com/huangyuanzhi1997 */public class HelloServlet implements Servlet &#123; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println("HelloServlet"); &#125; @Override public void destroy() &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void init(ServletConfig config) throws ServletException &#123; &#125;&#125; 第二步：Servlet的配置1234567891011&lt;!-- 向tomcat报告， 我这个应用里面有这个servlet，名字叫做HelloServlet , 具体的路径是com.huang.servlet.HelloServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.huang.servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- 注册servlet的映射。 servletName : 找到上面注册的具体servlet，url-pattern: 在地址栏上的path一定要以/打头 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 找到Tomcat应用 找到项目 找web.xml，然后在里面找到url-pattern，有没有哪一个patten的内容是/a 找到servlet-mapping中的那个servlet-name【HelloServlet】 找到上面定义的servlet元素中的servlet-naem【HelloServlet】 找到下面定义的servlet-class，然后开始创建该类的实例 继而执行该servlet中的service方法 Servlet的通用写法Servlet (接口) | | GenericServlet | | HttpServlet （用于处理http的请求）定义一个类，继承HttpServlet 复写doGet 和 doPost12345678910111213141516171819202122232425262728293031323334353637package com.huang.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * *@author 黄远志 *@date 2019年7月4日下午7:51:01 *@GitHub https://github.com/huangyuanzhi1997 */public class HelloServlet02 extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("HelloServlet02..."); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); System.out.println("get..."); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); System.out.println("post..."); &#125;&#125; Servlet的生命周期 生命周期 从创建到销毁的一段时间。 生命周期方法 从创建到销毁，所调用的那些方法。 init方法 在创建该Servlet的实例时，就执行该方法。 一个Servlet只会初始化一次， init方法只会执行一次。 默认情况下是 ： 初次访问该Servlet，才会创建实例。 service方法 只要客户端来了一个请求，那么就执行这个方法了。 该方法可以被执行很多次。 一次请求，对应一次service方法的调用。 destroy方法 servlet销毁的时候，就会执行该方法。 1). 该项目从Tomcat的里面移除。 2). 正常关闭Tomcat就会执行 shutdown.bat。 doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。 让Servlet创建实例的时机提前 默认情况下，只有在初次访问Servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么有没有方法可以让这个初始化的时机提前一点。 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 12345&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt; 为什么需要有这个ServletConfig Servlet的配置，通过这个对象，可以获取Servlet在配置的时候一些信息 先说 ， 再写怎么用， 最后说有什么用。 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。它的代码放置在了自己的servlet类里面。 刚好这个Servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个Servlet的公司，在注册Servlet的时候，必须要在web.xml里面，声明init-params 在开发当中比较少用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
