<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库连接技术——JDBC(Java DataBase Connectivity)]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94JDBC%2F</url>
    <content type="text"><![CDATA[为什么会出现JDBC SUN公司提供的一种数据库访问规则、规范, 由于数据库种类较多，并且Java语言使用比较广泛，SUN公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的Java程序只要使用SUN公司提供的JDBC驱动即可。 使用JDBC的基本步骤 注册驱动： ‘’’java DriverManager.registerDriver(new com.mysql.jdbc.Driver()); ‘’’ 建立连接：参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。 ‘’’java //DriverManager.getConnection(&quot;jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb&quot;); conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/student&quot;, &quot;root&quot;, &quot;root&quot;); ‘’’ 创建statement：跟数据库打交道，一定需要这个对象。 ‘’’java st = conn.createStatement(); ‘’’ 执行sql ，得到ResultSet：执行查询，得到结果集。 String sql = &quot;select * from t_stu&quot;; rs = st.executeQuery(sql); 遍历结果集：遍历查询每一条记录 。 while(rs.next()){ int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); System.out.println(&quot;id=&quot;+id + &quot;===name=&quot;+name+&quot;==age=&quot;+age); } 释放资源： if (rs != null) { try { rs.close(); } catch (SQLException sqlEx) { } // ignore rs = null; } ... JDBC 工具类构建 资源释放工作的整合 驱动防二次注册 1). river 这个类里面有静态代码块，一上来就执行了，所以等同于我们注册了两次驱动。 其实没这个必要的。 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 2). 静态代码块 ——&gt;类加载了，就执行。 java.sql.DriverManager.registerDriver(new Driver()); 3).最后形成以下代码即可。 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 使用properties配置文件 1). 在src底下声明一个文件 xxx.properties ，里面的内容如下： driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost/student name=root password=root 2). 在工具类里面，使用静态代码块，读取属性 static{ try { //创建一个属性配置对象 Properties properties = new Properties(); InputStream is = new FileInputStream(&quot;jdbc.properties&quot;); //对应文件位于工程根目录 //使用类加载器，去读取src底下的资源文件。 后面在servlet //对应文件位于src目录底下 //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); //导入输入流。 properties.load(is); //读取属性 driverClass = properties.getProperty(&quot;driverClass&quot;); url = properties.getProperty(&quot;url&quot;); name = properties.getProperty(&quot;name&quot;); password = properties.getProperty(&quot;password&quot;); } catch (Exception e) { e.printStackTrace(); } } ​ 数据库(SQL)的CRUD insert INSERT INTO t_stu (NAME , age) VALUES (&apos;wangqiang&apos;,28) INSERT INTO t_stu VALUES (NULL,&apos;wangqiang2&apos;,28) // 1. 获取连接对象 conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statement st = conn.createStatement(); //3. 执行添加 String sql = &quot;insert into t_stu values(null , &apos;aobama&apos; , 59)&quot;; //影响的行数， ，如果大于0 表明操作成功。 否则失败 int result = st.executeUpdate(sql); if(result &gt;0 ){ System.out.println(&quot;添加成功&quot;); }else{ System.out.println(&quot;添加失败&quot;); } delete DELETE FROM t_stu WHERE id = 6 // 1. 获取连接对象 conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statement st = conn.createStatement(); //3. 执行添加 String sql = &quot;delete from t_stu where name=&apos;aobama&apos;&quot;; //影响的行数， ，如果大于0 表明操作成功。 否则失败 int result = st.executeUpdate(sql); if(result &gt;0 ){ System.out.println(&quot;删除成功&quot;); }else{ System.out.println(&quot;删除失败&quot;); } query SELECT * FROM t_stu // 1. 获取连接对象 conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statement st = conn.createStatement(); // 3. 执行sql语句，返回ResultSet String sql = &quot;select * from t_stu&quot;; rs = st.executeQuery(sql); // 4. 遍历结果集 while (rs.next()) { String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); System.out.println(name + &quot; &quot; + age); } update UPDATE t_stu SET age = 38 WHERE id = 1; // 1. 获取连接对象 conn = JDBCUtil.getConn(); // 2. 根据连接对象，得到statement st = conn.createStatement(); //3. 执行添加 String sql = &quot;update t_stu set age = 26 where name =&apos;qyq&apos;&quot;; //影响的行数， ，如果大于0 表明操作成功。 否则失败 int result = st.executeUpdate(sql); if(result &gt;0 ){ System.out.println(&quot;更新成功&quot;); }else{ System.out.println(&quot;更新失败&quot;); } 使用单元测试，测试代码 定义一个类， TestXXX , 里面定义方法 testXXX. 添加Junit的支持。 右键工程 --- add Library --- Junit --- Junit4 在方法的上面加上注解 ， 其实就是一个标记。 @Test public void testQuery() { ... } 光标选中方法名字，然后右键执行单元测试。 或者是打开outline视图， 然后选择方法右键执行。 Dao模式 Data Access Object 数据访问对象 新建一个dao的接口， 里面声明数据库访问规则 /** * 定义操作数据库的方法 */ public interface UserDao { /** * 查询所有 */ void findAll(); } 新建一个dao的实现类，具体实现早前定义的规则 public class UserDaoImpl implements UserDao{ @Override public void findAll() { Connection conn = null; Statement st = null; ResultSet rs = null; try { //1. 获取连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); String sql = &quot;select * from t_user&quot;; rs = st.executeQuery(sql); while(rs.next()){ String userName = rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); System.out.println(userName+&quot;=&quot;+password); } } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, st, rs); } } } 直接使用实现 @Test public void testFindAll(){ UserDao dao = new UserDaoImpl(); dao.findAll(); } Statement安全问题 Statement执行 ，其实是拼接sql语句的。 先拼接sql语句，然后在一起执行。 String sql = &quot;select * from t_user where username=&apos;&quot;+ username +&quot;&apos; and password=&apos;&quot;+ password +&quot;&apos;&quot;; UserDao dao = new UserDaoImpl(); dao.login(&quot;admin&quot;, &quot;100234khsdf88&apos; or &apos;1=1&quot;); SELECT * FROM t_user WHERE username=&apos;admin&apos; AND PASSWORD=&apos;100234khsdf88&apos; or &apos;1=1&apos; //前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 rs = st.executeQuery(sql); PrepareStatement的用法 该对象就是替换前面的statement对象。 相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。 String sql = &quot;insert into t_user values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); //给占位符赋值 从左到右数过来，1 代表第一个问号， 永远都是从1开始。 ps.setString(1, userName); ps.setString(2, password); ​]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web服务技术——Servlet]]></title>
    <url>%2F2019%2F07%2F25%2FWeb%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94Servlet%2F</url>
    <content type="text"><![CDATA[Web资源在http协议当中，规定了请求和响应双方， 客户端和服务器端。与web相关的资源。 有两种分类 静态资源 html 、 js、 css 动态资源 servlet/jsp Servletservlet是什么? 其实就是一个java程序，运行在我们的web服务器上，用于接收和响应 客户端的http请求。 更多的是配合动态资源来做。 当然静态资源也需要使用到servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet Servlet执行过程 Servlet的通用写法Servlet (接口) | | GenericServlet | | HttpServlet （用于处理http的请求）定义一个类，继承HttpServlet 复写doGet 和 doPost Servlet的生命周期 生命周期 从创建到销毁的一段时间。 生命周期方法 从创建到销毁，所调用的那些方法。 init方法 在创建该servlet的实例时，就执行该方法。 一个servlet只会初始化一次， init方法只会执行一次 默认情况下是 ： 初次访问该servlet，才会创建实例。 service方法 只要客户端来了一个请求，那么就执行这个方法了。 该方法可以被执行很多次。 一次请求，对应一次service方法的调用 destroy方法 servlet销毁的时候，就会执行该方法 1). 该项目从tomcat的里面移除。 2). 正常关闭tomcat就会执行 shutdown.bat doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。 让Servlet创建实例的时机提前 默认情况下，只有在初次访问servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么有没有方法可以让这个初始化的时机提前一点。 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; 为什么需要有这个ServletConfig Servlet的配置，通过这个对象，可以获取servlet在配置的时候一些信息 先说 ， 再写怎么用， 最后说有什么用。 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。它的代码放置在了自己的servlet类里面。 刚好这个servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个servlet的公司，在注册servlet的时候，必须要在web.xml里面，声明init-params 在开发当中比较少用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
